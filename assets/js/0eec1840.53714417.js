"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[874],{4984:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>u});var n=a(3117),r=(a(7294),a(3905)),s=a(7689);const i={title:"Basic Datalog",sidebar_position:2},o=void 0,l={unversionedId:"fixedpoints/basicdatalog",id:"fixedpoints/basicdatalog",title:"Basic Datalog",description:"The default fixed-point engine is a bottom-up Datalog engine. It works with finite relations and uses finite table representations as hash tables as the default way to represent finite relations.",source:"@site/docs/fixedpoints/02 - basicdatalog.md",sourceDirName:"fixedpoints",slug:"/fixedpoints/basicdatalog",permalink:"/rise4fun/docs/fixedpoints/basicdatalog",draft:!1,editUrl:"https://github.com/microsoft/rise4fun/tree/main/website/docs/fixedpoints/02 - basicdatalog.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Basic Datalog",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/rise4fun/docs/fixedpoints/intro"},next:{title:"Engine for Property Directed Reachability",permalink:"/rise4fun/docs/fixedpoints/engineforpdr"}},d={},u=[{value:"Relations, rules and queries",id:"relations-rules-and-queries",level:2},{value:"Relations with arguments",id:"relations-with-arguments",level:2}],c={toc:u};function p(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The default fixed-point engine is a bottom-up Datalog engine. It works with finite relations and uses finite table representations as hash tables as the default way to represent finite relations."),(0,r.kt)("h2",{id:"relations-rules-and-queries"},"Relations, rules and queries"),(0,r.kt)("p",null,"The first example illustrates how to declare relations, rules and how to pose queries."),(0,r.kt)(s.Z,{input:{code:"(declare-rel a ())\n(declare-rel b ())\n(declare-rel c ())\n(rule (=> b a))\n(rule (=> c b))\n\n;(set-option :fixedpoint.engine datalog)\n(query a)\n\n(rule c)\n(query a\n :print-answer true)",result:{output:"unsat\nsat\ntrue\n",error:"",status:"z3-ran",hash:"4dde2315c86c2863adfd719f5f6082242d3340b6"}},mdxType:"Z3CodeBlock"}),(0,r.kt)("p",null,"The example illustrates some of the basic constructs."),(0,r.kt)(s.Z,{input:{code:" (declare-rel a ())",result:{output:"",error:"",status:"z3-ran",hash:"818066dbe2ea2ae189a8226f3cc68f49eab3c255"}},mdxType:"Z3CodeBlock"}),(0,r.kt)("p",null,"declares a 0-ary relation a."),(0,r.kt)(s.Z,{input:{code:"  (rule (=> b a))",result:{output:'(error "line 1 column 13: unknown constant b")\n',error:"",status:"z3-ran",hash:"2d89ecc3c94d32918a9e129b9fc70fa97794dd94"}},mdxType:"Z3CodeBlock"}),(0,r.kt)("p",null,"Create the rule that a follows from b. In general you can create a rule with multiple premises and a name using the format"),(0,r.kt)(s.Z,{input:{code:"   (rule (=> (and b c) a) name)",result:{output:'(error "line 1 column 19: unknown constant b")\n',error:"",status:"z3-ran",hash:"127367289d9cbd82112ce24c36bfdf9b6d5ecdfc"}},mdxType:"Z3CodeBlock"}),(0,r.kt)("p",null,"The name is optional. It is used for tracking the rule in derivation proofs. Continuing with the example, a is false unless b is established."),(0,r.kt)(s.Z,{input:{code:" (query r)",result:{output:'(error "line 1 column 9: invalid function declaration reference, unknown function r")\n',error:"",status:"z3-ran",hash:"77dec106ff7d84a34f0467917b5389437000ab35"}},mdxType:"Z3CodeBlock"}),(0,r.kt)("p",null,"Asks if relation a can be derived. The rules so far say that a follows if b is established and that b follows if c is established. But nothing establishes c and b is also not established, so a cannot be derived."),(0,r.kt)(s.Z,{input:{code:" (rule c)",result:{output:'(error "line 1 column 8: unknown constant c")\n',error:"",status:"z3-ran",hash:"1ddf1a8d59ac2ebf4b314ae1ddab6b3b66c398a9"}},mdxType:"Z3CodeBlock"}),(0,r.kt)("p",null,"Now it is the case that a can be derived."),(0,r.kt)("h2",{id:"relations-with-arguments"},"Relations with arguments"),(0,r.kt)("p",null,"Relations can take arguments. We illustrate relations with arguments using edges and paths in a graph."),(0,r.kt)(s.Z,{input:{code:";(set-option :fixedpoint.engine datalog)\n(define-sort s () (_ BitVec 3))\n(declare-rel edge (s s))\n(declare-rel path (s s))\n(declare-var a s)\n(declare-var b s)\n(declare-var c s)\n\n(rule (=> (edge a b) (path a b)))\n(rule (=> (and (path a b) (path b c)) (path a c)))\n\n(rule (edge #b001 #b010))\n(rule (edge #b001 #b011))\n(rule (edge #b010 #b100))\n\n(declare-rel q1 ())\n(declare-rel q2 ())\n(declare-rel q3 (s))\n(rule (=> (path #b001 #b100) q1))\n(rule (=> (path #b011 #b100) q2))\n(rule (=> (path #b001 b) (q3 b)))\n\n(query q1)\n(query q2)\n(query q3 :print-answer true)",result:{output:"sat\nunsat\nsat\n(or (= (:var 0) #b010) (= (:var 0) #b100) (= (:var 0) #b011))\n",error:"",status:"z3-ran",hash:"043542648e345e224aad7692e2250a113271738d"}},mdxType:"Z3CodeBlock"}),(0,r.kt)("p",null,"The example uses the declaration"),(0,r.kt)(s.Z,{input:{code:" (declare-var a s)",result:{output:"(error \"line 1 column 17: invalid command argument, sort expected: unknown sort 's'\")\n",error:"",status:"z3-ran",hash:"8a121a3447cbfee20f247f4c35dd608849d40c65"}},mdxType:"Z3CodeBlock"}),(0,r.kt)("p",null,"to instrument the fixed-point engine that a should be treated as a variable appearing in rules."))}p.isMDXComponent=!0}}]);