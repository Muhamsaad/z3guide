"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[717],{8509:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>d,toc:()=>_});var t=i(3117),r=(i(7294),i(3905)),a=i(7689);const o={title:"Quantifiers",sidebar_position:10},s=void 0,d={unversionedId:"Quantifiers",id:"Quantifiers",title:"Quantifiers",description:"Z3 is a decision procedure for the combination of the previous quantifier-free theories. That is, it can answer whether a quantifier-free formula, modulo the theories referenced by the formula, is satisfiable or whether it is unsatisfiable. Z3 also accepts and can work with formulas that use quantifiers. It is no longer a decision procedure for such formulas in general (and for good reasons, as there can be no decision procedure for first-order logic).",source:"@site/docs/09 - Quantifiers.md",sourceDirName:".",slug:"/Quantifiers",permalink:"/rise4fun/docs/Quantifiers",draft:!1,editUrl:"https://github.com/microsoft/rise4fun/tree/main/website/docs/09 - Quantifiers.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{title:"Quantifiers",sidebar_position:10},sidebar:"tutorialSidebar",previous:{title:"Strings, Sequences and Regular Expressions",permalink:"/rise4fun/docs/sequences"},next:{title:"Conclusion",permalink:"/rise4fun/docs/Conclusion"}},l={},_=[{value:"Modeling with Quantifiers",id:"modeling-with-quantifiers",level:3},{value:"Patterns",id:"patterns",level:3},{value:"Multi-patterns",id:"multi-patterns",level:3},{value:"No patterns",id:"no-patterns",level:3},{value:"Model-based Quantifier Instantiation",id:"model-based-quantifier-instantiation",level:3},{value:"Effectively Propositional",id:"effectively-propositional",level:4},{value:"Stratified Sorts Fragment",id:"stratified-sorts-fragment",level:4},{value:"Array Property Fragment",id:"array-property-fragment",level:4},{value:"List Fragment",id:"list-fragment",level:4},{value:"Essentially (Almost) Uninterpreted Fragment",id:"essentially-almost-uninterpreted-fragment",level:4},{value:"Quantified Bit-Vector Formulas",id:"quantified-bit-vector-formulas",level:4},{value:"Conditional (and Pseudo) Macros",id:"conditional-and-pseudo-macros",level:4},{value:"My formula is not in any of the fragments above",id:"my-formula-is-not-in-any-of-the-fragments-above",level:4}],u={toc:_};function p(e){let{components:n,...i}=e;return(0,r.kt)("wrapper",(0,t.Z)({},u,i,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Z3 is a ",(0,r.kt)("em",{parentName:"p"},"decision procedure")," for the combination of the previous quantifier-free theories. That is, it can answer whether a quantifier-free formula, modulo the theories referenced by the formula, is satisfiable or whether it is unsatisfiable. Z3 also accepts and can work with formulas that use quantifiers. It is no longer a decision procedure for such formulas in general (and for good reasons, as there can be no decision procedure for first-order logic)."),(0,r.kt)("p",null,"Nevertheless, Z3 is often able to handle formulas involving quantifiers. It uses several approaches to handle quantifiers. The most prolific approach is using ",(0,r.kt)("em",{parentName:"p"},"pattern-based")," quantifier instantiation. This approach allows instantiating quantified formulas with ground terms that appear in the current search context based on ",(0,r.kt)("em",{parentName:"p"},"pattern annotations")," on quantifiers. Another approach is based on ",(0,r.kt)("em",{parentName:"p"},"saturation theorem proving")," using a superposition calculus which is a modern method for applying resolution style rules with equalities. The pattern-based instantiation method is quite effective, even though it is inherently incomplete. The saturation based approach is complete for pure first-order formulas, but does not scale as nicely and is harder to predict."),(0,r.kt)("p",null,"Z3 also contains a model-based quantifier instantiation component that uses a model construction to find good terms to instantiate quantifiers with; and Z3 also handles many decidable fragments."),(0,r.kt)("h3",{id:"modeling-with-quantifiers"},"Modeling with Quantifiers"),(0,r.kt)("p",null,"Suppose we want to model an object oriented type system with single inheritance. We would need a predicate for sub-typing. Sub-typing should be a partial order, and respect single inheritance. For some built-in type constructors, such as for array-of, sub-typing should be monotone."),(0,r.kt)(a.Z,{input:{code:"(declare-sort Type)\n(declare-fun subtype (Type Type) Bool)\n(declare-fun array-of (Type) Type)\n(assert (forall ((x Type)) (subtype x x)))\n(assert (forall ((x Type) (y Type) (z Type))\n          (= (and (subtype x y) (subtype y z)) \n              (subtype x z)))) \n(assert (forall ((x Type) (y Type))\n          (= (and (subtype x y) (subtype y x)) \n              (= x y))))\n(assert (forall ((x Type) (y Type) (z Type))\n          (= (and (subtype x y) (subtype x z)) \n              (or (subtype y z) (subtype z y))))) \n(assert (forall ((x Type) (y Type))\n          (= (subtype x y) \n              (subtype (array-of x) (array-of y)))))\n(declare-const root-type Type)\n(assert (forall ((x Type)) (subtype x root-type)))\n(check-sat)"},mdxType:"Z3CodeBlock"}),(0,r.kt)("h3",{id:"patterns"},"Patterns"),(0,r.kt)("p",null,"The Stanford Pascal verifier and the subsequent Simplify theorem prover pioneered the use of pattern-based quantifier instantiation. The basic idea behind pattern-based quantifier instantiation is in a sense straight-forward Annotate a quantified formula using a ",(0,r.kt)("em",{parentName:"p"},"pattern")," that contains all the bound variables. So a pattern is an expression (that does not contain binding operations, such as quantifiers) that contains variables bound by a quantifier. Then instantiate the quantifier whenever a term that matches the pattern is created during search. This is a conceptually easy starting point, but there are several subtleties that are important."),(0,r.kt)("p",null,"In the following example, the first two options make sure that Model-based quantifier instantiation and saturation engines are disabled. We also annotate the quantified formula with the pattern (f (g x)). Since there is no ground instance of this pattern, the quantifier is not instantiated, and Z3 fails to show that the formula is unsatisfiable."),(0,r.kt)(a.Z,{input:{code:"(set-option smt.auto-config false) ; disable automatic self configuration\n(set-option smt.mbqi false) ; disable model-based quantifier instantiation\n(declare-fun f (Int) Int)\n(declare-fun g (Int) Int)\n(declare-const a Int)\n(declare-const b Int)\n(declare-const c Int)\n(assert (forall ((x Int))\n                (! (= (f (g x)) x)\n                   pattern ((f (g x))))))\n(assert (= (g a) c))\n(assert (= (g b) c))\n(assert (not (= a b)))\n(check-sat)"},mdxType:"Z3CodeBlock"}),(0,r.kt)("p",null,"When the more permissive pattern (g x) is used. Z3 proves the formula to be unsatisfiable. More restrive patterns minimize the number of instantiations (and potentially improve performance), but they may also make Z3 less complete."),(0,r.kt)(a.Z,{input:{code:"(set-option smt.auto-config false) ; disable automatic self configuration\n(set-option smt.mbqi false) ; disable model-based quantifier instantiation\n(declare-fun f (Int) Int)\n(declare-fun g (Int) Int)\n(declare-const a Int)\n(declare-const b Int)\n(declare-const c Int)\n(assert (forall ((x Int))\n                (! (= (f (g x)) x)\n                   pattern ((g x)))))\n(assert (= (g a) c))\n(assert (= (g b) c))\n(assert (not (= a b)))\n(check-sat)"},mdxType:"Z3CodeBlock"}),(0,r.kt)("p",null,"Some patterns may also create long instantiation chains. Consider the following assertion."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"(assert (forall (x Type) (y Type)\n(! (= (subtype x y) (subtype (array-of x) (array-of y)))\npattern ((subtype x y))\n))")),(0,r.kt)("p",null,"The axiom gets instantiated whenever there is some ground term of the form (subtype s t). The instantiation causes a fresh ground term (subtype (array-of s) (array-of t)), which enables a new instantiation. This undesirable situation is called a matching loop. Z3 uses many heuristics to break matching loops."),(0,r.kt)("p",null,"Before elaborating on the subtleties, we should address an important first question. What defines the terms that are created during search In the context of most SMT solvers, and of the Simplify theorem prover, terms exist as part of the input formula, they are of course also created by instantiating quantifiers, but terms are also implicitly created when equalities are asserted. The last point means that terms are considered up to congruence and pattern matching takes place modulo ground equalities. We call the matching problem E-matching. For example, if we have the following equalities"),(0,r.kt)(a.Z,{input:{code:"(set-option smt.auto-config false) ; disable automatic self configuration\n(set-option smt.mbqi false) ; disable model-based quantifier instantiation\n(declare-fun f (Int) Int)\n(declare-fun g (Int) Int)\n(declare-const a Int)\n(declare-const b Int)\n(declare-const c Int)\n(assert (forall ((x Int))\n                (! (= (f (g x)) x)\n                   pattern ((f (g x))))))\n(assert (= a (g b)))\n(assert (= b c))\n(assert (not (= (f a) c)))\n(check-sat)"},mdxType:"Z3CodeBlock"}),(0,r.kt)("p",null,"The terms (f a) and (f (g b)) are equal modulo the equalities. The pattern (f (g x)) can be matched and x bound to b (and the equality (= (f (g b)) b) is deduced."),(0,r.kt)("p",null,"While E-matching is an NP-complete problem, the main sources of overhead in larger verification problems comes from matching thousands of patterns in the context of an evolving set of terms and equalities. Z3 integrates an efficient E-matching engine using term indexing techniques."),(0,r.kt)("h3",{id:"multi-patterns"},"Multi-patterns"),(0,r.kt)("p",null,"In some cases, there is no pattern that contains all bound variables and does not contain interpreted symbols. In these cases, we use multi-patterns. In the following example, the quantified formula states that f is injective. This quantified formula is annotated with the multi-pattern (f x) (f y)"),(0,r.kt)(a.Z,{input:{code:"(declare-sort A)\n(declare-sort B)\n(declare-fun f (A) B)\n(assert (forall ((x A) (y A))\n                (! (= (= (f x) (f y)) (= x y))\n                   pattern ((f x) (f y))\n                   )))\n(declare-const a1 A)\n(declare-const a2 A)\n(declare-const b B)\n(assert (not (= a1 a2)))\n(assert (= (f a1) b))\n(assert (= (f a2) b))\n(check-sat)"},mdxType:"Z3CodeBlock"}),(0,r.kt)("p",null,"The quantified formula is instantiated for every pair of occurrences of f. A simple trick allows formulating injectivity of f in such a way that only a linear number of instantiations is required. The trick is to realize that f is injective if and only if it has a partial inverse."),(0,r.kt)(a.Z,{input:{code:"(declare-sort A)\n(declare-sort B)\n(declare-fun f (A) B)\n(declare-fun f-inv (B) A)\n(assert (forall ((x A))\n                (! (= (f-inv (f x)) x)\n                   pattern ((f x))\n                   )))\n(declare-const a1 A)\n(declare-const a2 A)\n(declare-const b B)\n(assert (not (= a1 a2)))\n(assert (= (f a1) b))\n(assert (= (f a2) b))\n(check-sat)"},mdxType:"Z3CodeBlock"}),(0,r.kt)("h3",{id:"no-patterns"},"No patterns"),(0,r.kt)("p",null,"The annotation no-pattern can be used to instrument Z3 not to use a certain sub-expression as a pattern. The pattern inference engine may otherwise choose arbitrary sub-expressions as patterns to direct quantifier instantiation."),(0,r.kt)("h3",{id:"model-based-quantifier-instantiation"},"Model-based Quantifier Instantiation"),(0,r.kt)("p",null,"The model-based quantifier instantiation (MBQI) is essentially a counter-example based refinement loop, where candidate models are built and checked. When the model checking step fails, it creates new quantifier instantiations. The models are returned as simple functional programs. In the following example, the model provides an interpretation for function f and constants a and b. One can easily check that the returned model does indeed satisfy the quantifier."),(0,r.kt)(a.Z,{input:{code:"(set-option smt.mbqi true)\n(declare-fun f (Int Int) Int)\n(declare-const a Int)\n(declare-const b Int)\n\n(assert (forall ((x Int)) (= (f x x) (+ x a))))\n\n(assert ( (f a b) a))\n(assert ( a 0))\n(check-sat)\n(get-model)\n\n(echo evaluating (f (+ a 10) 20)...)\n(eval (f (+ a 10) 20))"},mdxType:"Z3CodeBlock"}),(0,r.kt)("p",null,"The command eval evaluates an expression in the last model produced by Z3. It is essentially executing the function program produced by Z3."),(0,r.kt)("p",null,"MBQI is a decision procedure for several useful fragments. It may find models even for formulas that are not in any of these fragments. We describe some of these fragments."),(0,r.kt)("h4",{id:"effectively-propositional"},"Effectively Propositional"),(0,r.kt)("p",null,"The effectively propositional class of formulas (aka The Bernays-Schonfinkel class) is a decidable fragment of first-order logic formulas. It corresponds to formulas which, when written in prenex normal form contain only constants, universal quantifiers, and functions that return boolean values (aka predicates)."),(0,r.kt)("p",null,"Problems arising from program verification often involve establishing facts of quantifier-free formulas, but the facts themselves use relations and functions that are conveniently axiomatized using a background theory that uses quantified formulas. One set of examples of this situation comprise of formulas involving partial-orders. The following example axiomatizes a subtype partial order relation that has the tree property. That is, if x and y are subtypes of z, then x is a subtype of y or y is a subtype of x. The option (set-option model.compact true) instructs Z3 to eliminate trivial redundancies from the generated model. In this example, Z3 also creates a finite interpretation for the uninterpreted sort T."),(0,r.kt)(a.Z,{input:{code:"(set-option smt.mbqi true)\n(set-option model.compact true)\n\n;; T is an uninterpreted sort\n(declare-sort T) \n\n(declare-fun subtype (T T) Bool)\n\n;; subtype is reflexive\n(assert (forall ((x T)) (subtype x x)))\n\n;; subtype is antisymmetric\n(assert (forall ((x T) (y T)) (= (and (subtype x y)\n                                       (subtype y x))\n                                       (= x y))))\n;; subtype is transitive\n(assert (forall ((x T) (y T) (z T)) (= (and (subtype x y)\n                                             (subtype y z))\n                                             (subtype x z))))\n;; subtype has the tree-property\n(assert (forall ((x T) (y T) (z T)) (= (and (subtype x z)\n                                             (subtype y z))\n                                        (or (subtype x y)\n                                            (subtype y x)))))\n\n;; now we define a simple example using the axiomatization above.\n(declare-const obj-type T)\n(declare-const int-type T)\n(declare-const real-type T)\n(declare-const complex-type T)\n(declare-const string-type T)\n\n;; we have an additional axiom every type is a subtype of obj-type\n(assert (forall ((x T)) (subtype x obj-type)))\n\n(assert (subtype int-type real-type))\n(assert (subtype real-type complex-type))\n(assert (not (subtype string-type real-type)))\n(declare-const root-type T)\n(assert (subtype obj-type root-type))\n(check-sat)\n(get-model)\n\n(echo Is int-type a subtype of complex-type)\n(eval (subtype int-type complex-type))\n(echo Is int-type = obj-type)\n(eval (= int-type obj-type))\n(echo Is int-type a subtype of root-type)\n(eval (subtype int-type root-type))\n(echo Is root-type = obj-type)\n(eval (= root-type obj-type))"},mdxType:"Z3CodeBlock"}),(0,r.kt)("p",null,"Note that it uses two auxiliary functions (subtype!25 and k!24) that were not part of your formula. They are auxiliary definitions created by Z3 during the model construction procedure. We can also ask questions by using the eval command. For example,"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"(eval (subtype int-type complex-type))")),(0,r.kt)("p",null,"executes (evaluates) the given expression using the produced functional program (model)."),(0,r.kt)("p",null,"Constraints over sets (Boolean Algebras) can be encoded into this fragment by treating sets as unary predicates and lifting equalities between sets as formula equivalence."),(0,r.kt)(a.Z,{input:{code:"(set-option smt.mbqi true)\n(set-option model.compact true)\n\n;; A, B, C and D are sets of Int\n(declare-fun A (Int) Bool)\n(declare-fun B (Int) Bool)\n(declare-fun C (Int) Bool)\n(declare-fun D (Int) Bool)\n\n;; A union B is a subset of C\n(assert (forall ((x Int)) (= (or (A x) (B x)) (C x))))\n\n;; B minus A is not empty\n;; That is, there exists an integer e that is B but not in A\n(declare-const e Int)\n(assert (and (B e) (not (A e))))\n\n;; D is equal to C\n(assert (forall ((x Int)) (iff (D x) (C x))))\n\n;; 0, 1 and 2 are in B\n(assert (B 0))\n(assert (B 1))\n(assert (B 2))\n\n(check-sat)\n(get-model)\n(echo Is e an element of D)\n(eval (D e))\n\n(echo Now proving that A is a strict subset of D)\n;; This is true if the negation is unsatisfiable\n(push)\n(assert (not (and \n              ;; A is a subset of D\n              (forall ((x Int)) (= (A x) (D x)))\n              ;; but, D has an element that is not in A.\n              (exists ((x Int)) (and (D x) (not (A x)))))))\n(check-sat)\n(pop)"},mdxType:"Z3CodeBlock"}),(0,r.kt)("h4",{id:"stratified-sorts-fragment"},"Stratified Sorts Fragment"),(0,r.kt)("p",null,"The statified sorts fragment is another decidable fragment of many sorted first-order logic formulas. It corresponds to formulas which, when written in prenex normal form, there is a function level from sorts to naturals, and for every function"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"declare-fun f (S_1 ... S_n) R)"),(0,r.kt)("p",{parentName:"blockquote"},"level(R)  level(S_i).")),(0,r.kt)("h4",{id:"array-property-fragment"},"Array Property Fragment"),(0,r.kt)("p",null,"The array property fragment can encode properties about unidimensional, and is strong enough to say an array is sorted. More information about this fragment can be found in the paper ",(0,r.kt)("a",{parentName:"p",href:"httpacademic.research.microsoft.comPaper1843442.aspx"},"What's Decidable About Arrays"),"."),(0,r.kt)("p",null,"(set-option smt.mbqi true)\n(set-option model.compact true)"),(0,r.kt)(a.Z,{input:{code:";; A0, A1, A2, A3, A4 are arrays from Integers to Integers.\n(declare-fun A0 (Int) Int) (declare-fun A1 (Int) Int)\n(declare-fun A2 (Int) Int) (declare-fun A3 (Int) Int)\n(declare-fun A4 (Int) Int) \n(declare-const n Int) (declare-const l Int)\n(declare-const k Int) (declare-const x Int)\n(declare-const y Int) (declare-const w Int)\n(declare-const z Int)\n\n;; A1 = A0[k - w]\n(assert (= (A1 k) w))\n(assert (forall ((x Int)) (or (= x k) (= (A1 x) (A0 x)))))\n\n;; A2 = A1[l - x] = A0[k - w][l - x]\n(assert (= (A2 l) x))\n(assert (forall ((x Int)) (or (= x l) (= (A2 x) (A1 x)))))\n\n;; A3 = A0[k - y]\n(assert (= (A3 k) y))\n(assert (forall ((x Int)) (or (= x k) (= (A3 x) (A0 x)))))\n\n;; A4 = A3[l - z] = A0[k - y][l - z] \n(assert (= (A3 l) z))\n(assert (forall ((x Int)) (or (= x l) (= (A4 x) (A3 x)))))\n\n(assert (and ( w x) ( x y) ( y z)))\n(assert (and ( 0 k) ( k l) ( l n)))\n(assert ( (- l k) 1))\n\n;; A2 is sorted in the interval [0,n-1]\n(assert (forall ((i Int) (j Int))\n                (= (and (= 0 i) (= i j) (= j (- n 1)))\n                    (= (A2 i) (A2 j)))))\n\n(check-sat)\n(get-model)\n\n;; A4 is sorted in the interval [0,n-1]\n(assert (forall ((i Int) (j Int))\n                (= (and (= 0 i) (= i j) (= j (- n 1)))\n                    (= (A4 i) (A4 j)))))\n\n(check-sat)"},mdxType:"Z3CodeBlock"}),(0,r.kt)("h4",{id:"list-fragment"},"List Fragment"),(0,r.kt)("p",null,"The list fragment can encode properties about data-structures such as lists. For each quantified axiom q in this fragment, there is an easy way to satisfy q. More information about this fragment can be found in the paper ",(0,r.kt)("a",{parentName:"p",href:"httpwww.cs.berkeley.edu~neculaPapersverifier-cav05.pdf"},"Data Structure Specifications via Local Equality Axioms"),"."),(0,r.kt)(a.Z,{input:{code:"(set-option smt.mbqi true)\n;; Ptr is the pointer sort.\n(declare-sort Ptr)\n;; (next p) represents p.next\n;; The pointer reached by following the field next of p.\n(declare-fun next  (Ptr) Ptr)\n(declare-fun prev  (Ptr) Ptr)\n(declare-fun state (Ptr) Int)\n(declare-fun prio  (Ptr) Int)\n(declare-const null Ptr)\n(declare-const RUN  Int)\n(declare-const SLP  Int)\n(assert (distinct RUN SLP))\n\n;; Asserting data-structure invariants in the current state.\n\n;; p != null && p.next != null = p.next.prev = p\n(assert (forall ((p Ptr))\n                (= (and (not (= p null))\n                         (not (= (next p) null)))\n                    (= (prev (next p)) p))))\n\n;; p != null && p.prev != null = p.prev.next = p\n(assert (forall ((p Ptr))\n                (= (and (not (= p null))\n                         (not (= (prev p) null)))\n                    (= (next (prev p)) p))))\n\n;;  p != null && p.prev != null = p.state = p.next.state\n(assert (forall ((p Ptr))\n                (= (and (not (= p null))\n                         (not (= (next p) null)))\n                    (= (state p) (state (next p))))))\n\n;;  p != null && p.prev != null && p.state = RUN = p.prio = p.next.prio\n(assert (forall ((p Ptr))\n                (= (and (not (= p null))\n                         (not (= (next p) null))\n                         (= (state p) RUN))\n                    (= (prio p) (prio (next p))))))\n\n;; Verifying Verification Conditions (VCs) for remove procdure\n(declare-const x Ptr)\n;; new-state, new-next, new-prev and new-prio represent the state \n;; of the system after executing the remove procedure.\n(declare-fun new-state (Ptr) Int)\n(declare-fun new-next  (Ptr) Ptr)\n(declare-fun new-prev  (Ptr) Ptr)\n(declare-fun new-prio  (Ptr) Int)\n;; pre-conditions\n(assert (not (= x null)))\n(assert (not (= (prev x) null)))\n(assert (= (state x) RUN))\n;; updates\n;; --- new-prev = prev\n(assert (forall ((p Ptr)) (= (new-prev p) (prev p))))\n;; --- new-prio = prio\n(assert (forall ((p Ptr)) (= (new-prio p) (prio p))))\n;; --- new-state = state[x - SLP]\n(assert (= (new-state x) SLP))\n(assert (forall ((p Ptr)) (or (= p x) (= (new-state p) (state p)))))\n;; ----\n;; --- new-next  = next[(prev x) - (next x); x - null]\n(assert (= (new-next x) null))\n(assert (= (new-next (prev x)) (next x)))\n(assert (forall ((p Ptr)) (or (= p x) (= p (prev x)) (= (new-next p) (next p)))))\n;; ---\n\n;; Proving the data-structure invariants in the new state.\n\n(push)\n(assert (not (forall ((p Ptr))\n                     (= (and (not (= p null))\n                              (not (= (new-next p) null)))\n                         (= (new-prev (new-next p)) p)))))\n(check-sat)\n(get-model)\n(pop)\n(echo Why it is not valid)\n(echo Trying again using a fresh constant bad-ptr as an witness for the failure...)\n(push)\n(declare-const bad-ptr Ptr)\n(assert (not (= (and (not (= bad-ptr null))\n                      (not (= (new-next bad-ptr) null)))\n                 (= (new-prev (new-next bad-ptr)) bad-ptr))))\n(check-sat)\n(get-model)\n(echo null is)\n(eval null)\n(echo bad-ptr is)\n(eval bad-ptr)\n(echo In the new state, bad-ptr.next is)\n(eval (new-next bad-ptr))\n(echo In the new state, bad-ptr.next.prev is)\n(eval (new-prev (new-next bad-ptr)))\n(pop)"},mdxType:"Z3CodeBlock"}),(0,r.kt)("h4",{id:"essentially-almost-uninterpreted-fragment"},"Essentially (Almost) Uninterpreted Fragment"),(0,r.kt)("p",null,"The essentiallyalmost uninterpreted fragment subsumes the previous fragments, and uses a more relaxed notion of stratification. More information about this fragment can be found in the paper ",(0,r.kt)("a",{parentName:"p",href:"httpresearch.microsoft.comen-usumpeopleleonardoci.pdf"},"Complete instantiation for quantified formulas in Satisfiabiliby Modulo Theories.")," The model based quantifier instantiation approach used in Z3 is also described in this paper. Stratified data-structures (such as arrays of pointers) can be encoded in this fragment."),(0,r.kt)(a.Z,{input:{code:"(set-option smt.mbqi true)\n;; Ptr is the pointer sort.\n(declare-sort Ptr)\n;; (next p) represents p.next\n;; The pointer reached by following the field next of p.\n(declare-fun next  (Ptr) Ptr)\n(declare-fun prev  (Ptr) Ptr)\n(declare-fun state (Ptr) Int)\n(declare-fun prio  (Ptr) Int)\n(declare-const null Ptr)\n(declare-const RUN  Int)\n(declare-const SLP  Int)\n(assert (distinct RUN SLP))\n\n;; Asserting data-structure invariants in the current state.\n\n;; p != null && p.next != null = p.next.prev = p\n(assert (forall ((p Ptr))\n                (= (and (not (= p null))\n                         (not (= (next p) null)))\n                    (= (prev (next p)) p))))\n\n;; p != null && p.prev != null = p.prev.next = p\n(assert (forall ((p Ptr))\n                (= (and (not (= p null))\n                         (not (= (prev p) null)))\n                    (= (next (prev p)) p))))\n\n;;  p != null && p.prev != null = p.state = p.next.state\n(assert (forall ((p Ptr))\n                (= (and (not (= p null))\n                         (not (= (next p) null)))\n                    (= (state p) (state (next p))))))\n\n;;  p != null && p.prev != null && p.state = RUN = p.prio = p.next.prio\n(assert (forall ((p Ptr))\n                (= (and (not (= p null))\n                         (not (= (next p) null))\n                         (= (state p) RUN))\n                    (= (prio p) (prio (next p))))))\n\n;; Verifying Verification Conditions (VCs) for remove procdure\n(declare-const x Ptr)\n;; new-state, new-next, new-prev and new-prio represent the state \n;; of the system after executing the remove procedure.\n(declare-fun new-state (Ptr) Int)\n(declare-fun new-next  (Ptr) Ptr)\n(declare-fun new-prev  (Ptr) Ptr)\n(declare-fun new-prio  (Ptr) Int)\n;; pre-conditions\n(assert (not (= x null)))\n(assert (not (= (prev x) null)))\n(assert (= (state x) RUN))\n;; updates\n;; --- new-prev = prev\n(assert (forall ((p Ptr)) (= (new-prev p) (prev p))))\n;; --- new-prio = prio\n(assert (forall ((p Ptr)) (= (new-prio p) (prio p))))\n;; --- new-state = state[x - SLP]\n(assert (= (new-state x) SLP))\n(assert (forall ((p Ptr)) (or (= p x) (= (new-state p) (state p)))))\n;; ----\n;; --- new-next  = next[(prev x) - (next x); x - null]\n(assert (= (new-next x) null))\n(assert (= (new-next (prev x)) (next x)))\n(assert (forall ((p Ptr)) (or (= p x) (= p (prev x)) (= (new-next p) (next p)))))\n;; ---\n\n;; Proving the data-structure invariants in the new state.\n\n(push)\n(assert (not (forall ((p Ptr))\n                     (= (and (not (= p null))\n                              (not (= (new-next p) null)))\n                         (= (new-prev (new-next p)) p)))))\n(check-sat)\n(get-model)\n(pop)\n(echo Why it is not valid)\n(echo Trying again using a fresh constant bad-ptr as an witness for the failure...)\n(push)\n(declare-const bad-ptr Ptr)\n(assert (not (= (and (not (= bad-ptr null))\n                      (not (= (new-next bad-ptr) null)))\n                 (= (new-prev (new-next bad-ptr)) bad-ptr))))\n(check-sat)\n(get-model)\n(echo null is)\n(eval null)\n(echo bad-ptr is)\n(eval bad-ptr)\n(echo In the new state, bad-ptr.next is)\n(eval (new-next bad-ptr))\n(echo In the new state, bad-ptr.next.prev is)\n(eval (new-prev (new-next bad-ptr)))\n(pop)"},mdxType:"Z3CodeBlock"}),(0,r.kt)("p",null,"Shifts on streams (or arrays) can also be encoded."),(0,r.kt)(a.Z,{input:{code:"(set-option smt.mbqi true)\n;; f an g are streams\n(declare-fun f (Int) Int)\n(declare-fun g (Int) Int)\n\n;; the segment [a, n + a] of stream f is equal\n;; to the segment [0, n] of stream g.\n(declare-const n Int)\n(declare-const a Int)\n(assert (forall ((x Int)) (= (and (= 0 x) (= x n))\n                              (= (f (+ x a)) (g x)))))\n\n;; adding some constraints to a\n(assert ( a 10))\n(assert (= (f a) 2))\n(assert (= (g 3) (- 10)))\n\n(check-sat)\n(get-model)"},mdxType:"Z3CodeBlock"}),(0,r.kt)("h4",{id:"quantified-bit-vector-formulas"},"Quantified Bit-Vector Formulas"),(0,r.kt)("p",null,"A quantified bit-Vector formula (QBVF) is a many sorted first-order logic formula where the sort of every variable is a bit-vector sort. The QBVF satisfiability problem, is the problem of deciding whether a QBVF is satisfiable modulo the theory of bit-vectors. This problem is decidable because every universal (existental) quantifier can be expanded into a conjunction (disjunction) of potentially exponential, but finite size. A distinguishing feature in QBVF is the support for uninterpreted function and predicate symbols. More information about this fragment can be found in the paper ",(0,r.kt)("a",{parentName:"p",href:"httpresearch.microsoft.comen-usumpeopleleonardofmcad10.pdf"},"Efficiently Solving Quantified Bit-Vector Formulas"),"."),(0,r.kt)(a.Z,{input:{code:"(set-option smt.mbqi true)\n(define-sort Char () (_ BitVec 8))\n\n(declare-fun f  (Char) Char)\n(declare-fun f1 (Char) Char)\n(declare-const a Char)\n\n(assert (bvugt a #x00))\n(assert (= (f1 (bvadd a #x01)) #x00))\n(assert (forall ((x Char)) (or (= x (bvadd a #x01)) (= (f1 x) (f x)))))\n\n(check-sat)\n(get-model)"},mdxType:"Z3CodeBlock"}),(0,r.kt)("h4",{id:"conditional-and-pseudo-macros"},"Conditional (and Pseudo) Macros"),(0,r.kt)("p",null,"Quantifiers defining macros are also automatically detected by the Model Finder. In the following example, the first three quantifiers are defining f by cases."),(0,r.kt)(a.Z,{input:{code:"(set-option smt.mbqi true)\n(declare-fun f (Int) Int)\n(declare-fun p (Int) Bool)\n(declare-fun p2 (Int) Bool)\n(declare-const a Int)\n(declare-const b Int)\n(declare-const c Int)\n(assert (forall ((x Int)) \n                (= (not (p x)) (= (f x) (+ x 1)))))\n(assert (forall ((x Int)) \n                (= (and (p x) (not (p2 x))) (= (f x) x))))\n(assert (forall ((x Int)) \n                (= (p2 x) (= (f x) (- x 1)))))\n(assert (p b))\n(assert (p c))\n(assert (p2 a))\n(assert ( (f a) b))\n(check-sat)\n(get-model)"},mdxType:"Z3CodeBlock"}),(0,r.kt)("h4",{id:"my-formula-is-not-in-any-of-the-fragments-above"},"My formula is not in any of the fragments above"),(0,r.kt)("p",null,"Even if your formula is not in any of the fragments above. Z3 may still find a model for it. For example, The following simple example is not in the fragments described above."),(0,r.kt)(a.Z,{input:{code:"(set-option smt.mbqi true)\n(declare-fun n () Int)\n(declare-fun a_1 () Int)\n(declare-fun f (Int) Int)\n(declare-fun g_1 (Int) Int)\n(assert ( n 0))\n(assert (forall ((i Int))\n        (= (and (= 0 i) (= i n))\n            (and (= (f 0) 0)\n                 (= (f 2) 2)\n                 (= 0 (f i))\n                 (= (f i) 2)\n                 (= (= (f i) 2) (= i n))\n                 (= (= (f i) 0)\n                     (or (= (f (+ i 1)) 1) (= (f (+ i 1)) 2)))\n                 (= (= (f i) 1)\n                     (or (= (f (+ i 1)) 1) (= (f (+ i 1)) 2)))\n                 (= (g_1 0) 0)\n                 (= (= (f i) 0) (= (g_1 (+ i 1)) 0))\n                 (= (= (f i) 1) (= (g_1 (+ i 1)) (+ (g_1 i) 1)))\n                 (= (= (f i) 2)\n                     (= (g_1 (+ i 1)) (g_1 i)))\n                 (= (= (f i) 1) ( (g_1 i) a_1))\n                 (= (= (f i) 2) \n                     (and (= (g_1 i) a_1) ( (g_1 i) 2)))))))\n(check-sat)\n(get-model)\n\n(echo Property does not hold for n  1)\n(assert ( n 1))\n(check-sat)"},mdxType:"Z3CodeBlock"}),(0,r.kt)("p",null,"The Z3 preprocessor has many options that may improve the performace of the model finder. In the following example, macro-finder will expand quantifiers representing macros at preprocessing time."),(0,r.kt)(a.Z,{input:{code:"(set-option smt.mbqi true)\n(set-option smt.macro-finder true)\n\n(declare-sort Action)\n(declare-sort Role)\n(declare-sort Permission)\n(declare-sort Id)\n\n(declare-fun Client () Role)  \n(declare-fun FinAdmin () Role)\n(declare-fun FinClerk () Role)\n(declare-fun Manager () Role)\n(declare-fun POAdmin () Role)\n(declare-fun POClerk () Role)\n(declare-fun action2int (Action) Int)\n(declare-fun id1 () Id)\n(declare-fun id2 () Id)\n(declare-fun id2int (Id) Int)\n(declare-fun id3 () Id)\n(declare-fun id4 () Id)\n(declare-fun id5 () Id)\n(declare-fun id6 () Id)\n(declare-fun id7 () Id)\n(declare-fun p1 () Permission)\n(declare-fun p2 () Permission)\n(declare-fun p3 () Permission)\n(declare-fun p4 () Permission)\n(declare-fun p5 () Permission)\n(declare-fun p6 () Permission)\n(declare-fun permission2int (Permission) Int)\n(declare-fun role2int (Role) Int)\n(declare-fun role_level (Role) Int)\n(declare-fun t1_receive () Action)\n(declare-fun t2_invoke () Action)\n(declare-fun t3_split () Action)\n(declare-fun t4_join () Action)\n(declare-fun t5_invoke () Action)\n(declare-fun t6_invoke () Action)\n(declare-fun t7_invokeO () Action)\n(declare-fun t8_invokeI () Action)\n(declare-fun t9_invoke () Action)\n(declare-fun in_creator_ctrPay_0 () Int)\n(declare-fun in_creator_ctrPay_1 () Int)\n(declare-fun in_customer_crtPO_0 () Int)\n(declare-fun in_customer_crtPO_1 () Int)\n(declare-fun out_approverPOPayment_apprPay_0 () Int)\n(declare-fun out_approverPOPayment_apprPay_1 () Int)\n(declare-fun out_approverPO_apprPO_0 () Int)\n(declare-fun out_approverPO_apprPO_1 () Int)\n(declare-fun out_creator_ctrPay_0 () Int)\n(declare-fun out_creator_ctrPay_1 () Int)\n(declare-fun out_signerGRN_ctrsignGRN_0 () Int)\n(declare-fun out_signerGRN_ctrsignGRN_1 () Int)\n(declare-fun out_signerGRN_signGRN_0 () Int)\n(declare-fun out_signerGRN_signGRN_1 () Int)\n(declare-fun p10_final_0 () Int)\n(declare-fun p10_final_1 () Int)\n(declare-fun p11_final_0 () Int)\n(declare-fun p11_final_1 () Int)\n(declare-fun p1_final_0 () Int)\n(declare-fun p1_final_1 () Int)\n(declare-fun p2_final_0 () Int)\n(declare-fun p2_final_1 () Int)\n(declare-fun p3_running_0 () Int)\n(declare-fun p3_running_1 () Int)\n(declare-fun p4_final_0 () Int)\n(declare-fun p4_final_1 () Int)\n(declare-fun p5_final_0 () Int)\n(declare-fun p5_final_1 () Int)\n(declare-fun p6_initial_0 () Int)\n(declare-fun p6_initial_1 () Int)\n(declare-fun p7_final_0 () Int)\n(declare-fun p7_final_1 () Int)\n(declare-fun p8_initial_0 () Int)\n(declare-fun p8_initial_1 () Int)\n(declare-fun p9_initial_0 () Int)\n(declare-fun p9_initial_1 () Int)\n\n\n;PREDICATES\n\n(declare-fun has_permission (Id Action) Bool)\n(declare-fun permission (Permission Action) Bool)\n(declare-fun role (Role) Bool)\n(declare-fun role_le (Role Role) Bool)\n(declare-fun role_permission_assign (Role Permission) Bool)\n(declare-fun user (Id) Bool)\n(declare-fun user_role_assign (Id Role) Bool)\n(declare-fun can_exec_0 (Id Action) Bool)\n(declare-fun can_exec_1 (Id Action) Bool)\n(declare-fun executed_0 (Id Action) Bool) \n(declare-fun executed_1 (Id Action) Bool)\n(declare-fun initial_pm_0 () Bool)\n(declare-fun initial_wf_0 () Bool)\n(declare-fun t1_receive_0_1 (Id) Bool)\n(declare-fun t2_invoke_0_1 (Id) Bool)\n(declare-fun t3_split_0_1 (Id) Bool)\n(declare-fun t4_join_0_1 (Id) Bool)\n(declare-fun t5_invoke_0_1 (Id) Bool)\n(declare-fun t6_invoke_0_1 (Id) Bool)\n(declare-fun t7_invokeO_0_1 (Id) Bool)\n(declare-fun t8_invokeI_0_1 (Id) Bool)\n(declare-fun t9_invoke_0_1 (Id) Bool)\n\n(assert\n(forall ((U Action) (V Action)) (implies (= (action2int U) (action2int V)) (= U V))))\n \n\n;assumption 2\n(assert\n(forall ((U Action)) (and (= 1 (action2int U)) (= (action2int U) 9))))\n \n\n;assumption 3\n(assert\n(= (action2int t1_receive) 1))\n\n;assumption 4\n(assert\n(= (action2int t2_invoke) 2))\n\n;assumption 5\n(assert\n(= (action2int t3_split) 3))\n\n;assumption 6\n(assert\n(= (action2int t4_join) 4))\n\n;assumption 7\n(assert\n(= (action2int t5_invoke) 5))\n\n;assumption 8\n(assert\n(= (action2int t6_invoke) 6))\n\n;assumption 9\n(assert\n(= (action2int t7_invokeO) 7))\n\n;assumption 10\n(assert\n(= (action2int t8_invokeI) 8))\n\n;assumption 11\n(assert\n(= (action2int t9_invoke) 9))\n\n;assumption 12\n(assert\n(forall ((U Role) (V Role)) (implies (= (role2int U) (role2int V)) (= U V))))\n \n\n;assumption 13\n(assert\n(forall ((U Role)) (and (= 1 (role2int U)) (= (role2int U) 6))))\n \n\n;assumption 14\n(assert\n(= (role2int Manager) 1))\n\n;assumption 15\n(assert\n(= (role2int FinAdmin) 2))\n\n;assumption 16\n(assert\n(= (role2int FinClerk) 3))\n\n;assumption 17\n(assert\n(= (role2int POAdmin) 4))\n\n;assumption 18\n(assert\n(= (role2int POClerk) 5))\n\n;assumption 19\n(assert\n(= (role2int Client) 6))\n\n;assumption 20\n(assert\n(forall ((U Permission) (V Permission)) (implies (= (permission2int U) (permission2int V)) (= U V))))\n \n\n;assumption 21\n(assert\n(forall ((U Permission)) (and (= 1 (permission2int U)) (= (permission2int U) 6))))\n \n\n;assumption 22\n(assert\n(= (permission2int p1) 1))\n\n;assumption 23\n(assert\n(= (permission2int p2) 2))\n\n;assumption 24\n(assert\n(= (permission2int p3) 3))\n\n;assumption 25\n(assert\n(= (permission2int p4) 4))\n\n;assumption 26\n(assert\n(= (permission2int p5) 5))\n\n;assumption 27\n(assert\n(= (permission2int p6) 6))\n\n;assumption 28\n(assert\n(forall ((U Permission) (V Action)) (iff (permission U V) (or (and (= U p1) (= V t2_invoke)) (or (and (= U p2) (= V t5_invoke)) (or (and (= U p3) (= V t6_invoke)) (or (and (= U p4) (or (= V t7_invokeO) (= V t8_invokeI))) (or (and (= U p5) (= V t9_invoke)) (and (= U p6) (= V t1_receive))))))))))\n \n\n;assumption 29\n(assert\n(forall ((U Id) (V Role)) (iff (user_role_assign U V) (or (and (= U id7) (= V Manager)) (or (and (= U id1) (= V Manager)) (or (and (= U id2) (= V FinAdmin)) (or (and (= U id3) (= V FinClerk)) (or (and (= U id4) (= V POAdmin)) (or (and (= U id5) (= V POClerk)) (and (= U id6) (= V Client)))))))))))\n \n\n;assumption 30\n(assert\n(forall ((U Role) (V Permission)) (iff (role_permission_assign U V) (or (and (= U POClerk) (= V p3)) (or (and (= U FinClerk) (= V p4)) (or (and (= U POAdmin) (or (= V p1) (= V p3))) (or (and (= U FinAdmin) (or (= V p5) (= V p4))) (or (and (= U Client) (or (= V p6) (= V p2))) (and (= U Manager) (or (= V p1) (or (= V p3) (or (= V p4) (= V p5)))))))))))))\n \n\n;assumption 31\n(assert\n(forall ((U Id) (V Action)) (iff (has_permission U V) (or (and (user_role_assign U Manager) (and (role_permission_assign Manager p1) (permission p1 V))) (or (and (user_role_assign U Manager) (and (role_permission_assign Manager p2) (permission p2 V))) (or (and (user_role_assign U Manager) (and (role_permission_assign Manager p3) (permission p3 V))) (or (and (user_role_assign U Manager) (and (role_permission_assign Manager p4) (permission p4 V))) (or (and (user_role_assign U Manager) (and (role_permission_assign Manager p5) (permission p5 V))) (or (and (user_role_assign U Manager) (and (role_permission_assign Manager p6) (permission p6 V))) (or (and (user_role_assign U POClerk) (and (role_permission_assign POClerk p1) (permission p1 V))) (or (and (user_role_assign U POClerk) (and (role_permission_assign POClerk p2) (permission p2 V))) (or (and (user_role_assign U POClerk) (and (role_permission_assign POClerk p3) (permission p3 V))) (or (and (user_role_assign U POClerk) (and (role_permission_assign POClerk p4) (permission p4 V))) (or (and (user_role_assign U POClerk) (and (role_permission_assign POClerk p5) (permission p5 V))) (or (and (user_role_assign U POClerk) (and (role_permission_assign POClerk p6) (permission p6 V))) (or (and (user_role_assign U FinClerk) (and (role_permission_assign FinClerk p1) (permission p1 V))) (or (and (user_role_assign U FinClerk) (and (role_permission_assign FinClerk p2) (permission p2 V))) (or (and (user_role_assign U FinClerk) (and (role_permission_assign FinClerk p3) (permission p3 V))) (or (and (user_role_assign U FinClerk) (and (role_permission_assign FinClerk p4) (permission p4 V))) (or (and (user_role_assign U FinClerk) (and (role_permission_assign FinClerk p5) (permission p5 V))) (or (and (user_role_assign U FinClerk) (and (role_permission_assign FinClerk p6) (permission p6 V))) (or (and (user_role_assign U FinAdmin) (and (role_permission_assign FinAdmin p1) (permission p1 V))) (or (and (user_role_assign U FinAdmin) (and (role_permission_assign FinAdmin p2) (permission p2 V))) (or (and (user_role_assign U FinAdmin) (and (role_permission_assign FinAdmin p3) (permission p3 V))) (or (and (user_role_assign U FinAdmin) (and (role_permission_assign FinAdmin p4) (permission p4 V))) (or (and (user_role_assign U FinAdmin) (and (role_permission_assign FinAdmin p5) (permission p5 V))) (or (and (user_role_assign U FinAdmin) (and (role_permission_assign FinAdmin p6) (permission p6 V))) (or (and (user_role_assign U POAdmin) (and (role_permission_assign POAdmin p1) (permission p1 V))) (or (and (user_role_assign U POAdmin) (and (role_permission_assign POAdmin p2) (permission p2 V))) (or (and (user_role_assign U POAdmin) (and (role_permission_assign POAdmin p3) (permission p3 V))) (or (and (user_role_assign U POAdmin) (and (role_permission_assign POAdmin p4) (permission p4 V))) (or (and (user_role_assign U POAdmin) (and (role_permission_assign POAdmin p5) (permission p5 V))) (or (and (user_role_assign U POAdmin) (and (role_permission_assign POAdmin p6) (permission p6 V))) (or (and (user_role_assign U Client) (and (role_permission_assign Client p1) (permission p1 V))) (or (and (user_role_assign U Client) (and (role_permission_assign Client p2) (permission p2 V))) (or (and (user_role_assign U Client) (and (role_permission_assign Client p3) (permission p3 V))) (or (and (user_role_assign U Client) (and (role_permission_assign Client p4) (permission p4 V))) (or (and (user_role_assign U Client) (and (role_permission_assign Client p5) (permission p5 V))) (and (user_role_assign U Client) (and (role_permission_assign Client p6) (permission p6 V)))))))))))))))))))))))))))))))))))))))))\n \n\n;assumption 32\n(assert\n(forall ((U Role) (V Role)) (iff (role_le U V) ( (role_level U) (role_level V)))))\n \n\n;assumption 33\n(assert\n(= (role_level Manager) 3))\n\n;assumption 34\n(assert\n(= (role_level FinAdmin) 2))\n\n;assumption 35\n(assert\n(= (role_level FinClerk) 1))\n\n;assumption 36\n(assert\n(= (role_level POAdmin) 2))\n\n;assumption 37\n(assert\n(= (role_level POClerk) 1))\n\n;assumption 38\n(assert\n(= (role_level Client) 0))\n\n;assumption 39\n(assert\n(forall ((U Id) (V Id)) (implies (= (id2int U) (id2int V)) (= U V))))\n \n\n;assumption 40\n(assert\n(forall ((U Id)) (and (= 1 (id2int U)) (= (id2int U) 7))))\n \n\n;assumption 41\n(assert\n(= (id2int id1) 1))\n\n;assumption 42\n(assert\n(= (id2int id2) 2))\n\n;assumption 43\n(assert\n(= (id2int id3) 3))\n\n;assumption 44\n(assert\n(= (id2int id4) 4))\n\n;assumption 45\n(assert\n(= (id2int id5) 5))\n\n;assumption 46\n(assert\n(= (id2int id6) 6))\n\n;assumption 47\n(assert\n(= (id2int id7) 7))\n\n;assumption 48\n(assert\n(iff initial_wf_0 (and (= p1_final_0 0) (and (= p2_final_0 0) (and (= p3_running_0 0) (and (= p4_final_0 0) (and (= p5_final_0 0) (and (= p6_initial_0 0) (and (= p7_final_0 0) (and (= p8_initial_0 0) (and (= p9_initial_0 1) (and (= p10_final_0 0) (and (= p11_final_0 0) (and (= in_customer_crtPO_0 1) (and (= in_creator_ctrPay_0 1) (and (= out_approverPO_apprPO_0 0) (and (= out_approverPOPayment_apprPay_0 0) (and (= out_creator_ctrPay_0 0) (and (= out_signerGRN_ctrsignGRN_0 0) (= out_signerGRN_signGRN_0 0))))))))))))))))))))\n\n;assumption 49\n(assert\n(iff initial_pm_0 (forall ((U Id) (V Action)) (iff (executed_0 U V) false))\n ))\n\n;assumption 50\n(assert\n(forall ((U Id) (V Action)) (iff (can_exec_0 U V) (or (and (= V t5_invoke) (and (has_permission U t5_invoke) (or (and (not (= U id1)) (executed_0 id1 t2_invoke)) (or (and (not (= U id2)) (executed_0 id2 t2_invoke)) (or (and (not (= U id3)) (executed_0 id3 t2_invoke)) (or (and (not (= U id4)) (executed_0 id4 t2_invoke)) (or (and (not (= U id5)) (executed_0 id5 t2_invoke)) (or (and (not (= U id6)) (executed_0 id6 t2_invoke)) (and (not (= U id7)) (executed_0 id7 t2_invoke)))))))))) (or (and (= V t6_invoke) (and (and (has_permission U t6_invoke) (or (and (not (= U id1)) (executed_0 id1 t2_invoke)) (or (and (not (= U id2)) (executed_0 id2 t2_invoke)) (or (and (not (= U id3)) (executed_0 id3 t2_invoke)) (or (and (not (= U id4)) (executed_0 id4 t2_invoke)) (or (and (not (= U id5)) (executed_0 id5 t2_invoke)) (or (and (not (= U id6)) (executed_0 id6 t2_invoke)) (and (not (= U id7)) (executed_0 id7 t2_invoke))))))))) (and (has_permission U t6_invoke) (or (and (not (= U id1)) (executed_0 id1 t5_invoke)) (or (and (not (= U id2)) (executed_0 id2 t5_invoke)) (or (and (not (= U id3)) (executed_0 id3 t5_invoke)) (or (and (not (= U id4)) (executed_0 id4 t5_invoke)) (or (and (not (= U id5)) (executed_0 id5 t5_invoke)) (or (and (not (= U id6)) (executed_0 id6 t5_invoke)) (and (not (= U id7)) (executed_0 id7 t5_invoke))))))))))) (or (and (= V t9_invoke) (and (has_permission U t9_invoke) (exists ((W Role))  (and (user_role_assign U W) (and (or (and (user_role_assign id1 Manager) (and (role_le Manager W) (executed_0 id1 t7_invokeO))) (or (and (user_role_assign id2 Manager) (and (role_le Manager W) (executed_0 id2 t7_invokeO))) (or (and (user_role_assign id3 Manager) (and (role_le Manager W) (executed_0 id3 t7_invokeO))) (or (and (user_role_assign id4 Manager) (and (role_le Manager W) (executed_0 id4 t7_invokeO))) (or (and (user_role_assign id5 Manager) (and (role_le Manager W) (executed_0 id5 t7_invokeO))) (or (and (user_role_assign id6 Manager) (and (role_le Manager W) (executed_0 id6 t7_invokeO))) (or (and (user_role_assign id7 Manager) (and (role_le Manager W) (executed_0 id7 t7_invokeO))) (or (and (user_role_assign id1 POClerk) (and (role_le POClerk W) (executed_0 id1 t7_invokeO))) (or (and (user_role_assign id2 POClerk) (and (role_le POClerk W) (executed_0 id2 t7_invokeO))) (or (and (user_role_assign id3 POClerk) (and (role_le POClerk W) (executed_0 id3 t7_invokeO))) (or (and (user_role_assign id4 POClerk) (and (role_le POClerk W) (executed_0 id4 t7_invokeO))) (or (and (user_role_assign id5 POClerk) (and (role_le POClerk W) (executed_0 id5 t7_invokeO))) (or (and (user_role_assign id6 POClerk) (and (role_le POClerk W) (executed_0 id6 t7_invokeO))) (or (and (user_role_assign id7 POClerk) (and (role_le POClerk W) (executed_0 id7 t7_invokeO))) (or (and (user_role_assign id1 FinClerk) (and (role_le FinClerk W) (executed_0 id1 t7_invokeO))) (or (and (user_role_assign id2 FinClerk) (and (role_le FinClerk W) (executed_0 id2 t7_invokeO))) (or (and (user_role_assign id3 FinClerk) (and (role_le FinClerk W) (executed_0 id3 t7_invokeO))) (or (and (user_role_assign id4 FinClerk) (and (role_le FinClerk W) (executed_0 id4 t7_invokeO))) (or (and (user_role_assign id5 FinClerk) (and (role_le FinClerk W) (executed_0 id5 t7_invokeO))) (or (and (user_role_assign id6 FinClerk) (and (role_le FinClerk W) (executed_0 id6 t7_invokeO))) (or (and (user_role_assign id7 FinClerk) (and (role_le FinClerk W) (executed_0 id7 t7_invokeO))) (or (and (user_role_assign id1 FinAdmin) (and (role_le FinAdmin W) (executed_0 id1 t7_invokeO))) (or (and (user_role_assign id2 FinAdmin) (and (role_le FinAdmin W) (executed_0 id2 t7_invokeO))) (or (and (user_role_assign id3 FinAdmin) (and (role_le FinAdmin W) (executed_0 id3 t7_invokeO))) (or (and (user_role_assign id4 FinAdmin) (and (role_le FinAdmin W) (executed_0 id4 t7_invokeO))) (or (and (user_role_assign id5 FinAdmin) (and (role_le FinAdmin W) (executed_0 id5 t7_invokeO))) (or (and (user_role_assign id6 FinAdmin) (and (role_le FinAdmin W) (executed_0 id6 t7_invokeO))) (or (and (user_role_assign id7 FinAdmin) (and (role_le FinAdmin W) (executed_0 id7 t7_invokeO))) (or (and (user_role_assign id1 POAdmin) (and (role_le POAdmin W) (executed_0 id1 t7_invokeO))) (or (and (user_role_assign id2 POAdmin) (and (role_le POAdmin W) (executed_0 id2 t7_invokeO))) (or (and (user_role_assign id3 POAdmin) (and (role_le POAdmin W) (executed_0 id3 t7_invokeO))) (or (and (user_role_assign id4 POAdmin) (and (role_le POAdmin W) (executed_0 id4 t7_invokeO))) (or (and (user_role_assign id5 POAdmin) (and (role_le POAdmin W) (executed_0 id5 t7_invokeO))) (or (and (user_role_assign id6 POAdmin) (and (role_le POAdmin W) (executed_0 id6 t7_invokeO))) (or (and (user_role_assign id7 POAdmin) (and (role_le POAdmin W) (executed_0 id7 t7_invokeO))) (or (and (user_role_assign id1 Client) (and (role_le Client W) (executed_0 id1 t7_invokeO))) (or (and (user_role_assign id2 Client) (and (role_le Client W) (executed_0 id2 t7_invokeO))) (or (and (user_role_assign id3 Client) (and (role_le Client W) (executed_0 id3 t7_invokeO))) (or (and (user_role_assign id4 Client) (and (role_le Client W) (executed_0 id4 t7_invokeO))) (or (and (user_role_assign id5 Client) (and (role_le Client W) (executed_0 id5 t7_invokeO))) (or (and (user_role_assign id6 Client) (and (role_le Client W) (executed_0 id6 t7_invokeO))) (and (user_role_assign id7 Client) (and (role_le Client W) (executed_0 id7 t7_invokeO)))))))))))))))))))))))))))))))))))))))))))) (or (and (user_role_assign id1 Manager) (and (role_le Manager W) (executed_0 id1 t8_invokeI))) (or (and (user_role_assign id2 Manager) (and (role_le Manager W) (executed_0 id2 t8_invokeI))) (or (and (user_role_assign id3 Manager) (and (role_le Manager W) (executed_0 id3 t8_invokeI))) (or (and (user_role_assign id4 Manager) (and (role_le Manager W) (executed_0 id4 t8_invokeI))) (or (and (user_role_assign id5 Manager) (and (role_le Manager W) (executed_0 id5 t8_invokeI))) (or (and (user_role_assign id6 Manager) (and (role_le Manager W) (executed_0 id6 t8_invokeI))) (or (and (user_role_assign id7 Manager) (and (role_le Manager W) (executed_0 id7 t8_invokeI))) (or (and (user_role_assign id1 POClerk) (and (role_le POClerk W) (executed_0 id1 t8_invokeI))) (or (and (user_role_assign id2 POClerk) (and (role_le POClerk W) (executed_0 id2 t8_invokeI))) (or (and (user_role_assign id3 POClerk) (and (role_le POClerk W) (executed_0 id3 t8_invokeI))) (or (and (user_role_assign id4 POClerk) (and (role_le POClerk W) (executed_0 id4 t8_invokeI))) (or (and (user_role_assign id5 POClerk) (and (role_le POClerk W) (executed_0 id5 t8_invokeI))) (or (and (user_role_assign id6 POClerk) (and (role_le POClerk W) (executed_0 id6 t8_invokeI))) (or (and (user_role_assign id7 POClerk) (and (role_le POClerk W) (executed_0 id7 t8_invokeI))) (or (and (user_role_assign id1 FinClerk) (and (role_le FinClerk W) (executed_0 id1 t8_invokeI))) (or (and (user_role_assign id2 FinClerk) (and (role_le FinClerk W) (executed_0 id2 t8_invokeI))) (or (and (user_role_assign id3 FinClerk) (and (role_le FinClerk W) (executed_0 id3 t8_invokeI))) (or (and (user_role_assign id4 FinClerk) (and (role_le FinClerk W) (executed_0 id4 t8_invokeI))) (or (and (user_role_assign id5 FinClerk) (and (role_le FinClerk W) (executed_0 id5 t8_invokeI))) (or (and (user_role_assign id6 FinClerk) (and (role_le FinClerk W) (executed_0 id6 t8_invokeI))) (or (and (user_role_assign id7 FinClerk) (and (role_le FinClerk W) (executed_0 id7 t8_invokeI))) (or (and (user_role_assign id1 FinAdmin) (and (role_le FinAdmin W) (executed_0 id1 t8_invokeI))) (or (and (user_role_assign id2 FinAdmin) (and (role_le FinAdmin W) (executed_0 id2 t8_invokeI))) (or (and (user_role_assign id3 FinAdmin) (and (role_le FinAdmin W) (executed_0 id3 t8_invokeI))) (or (and (user_role_assign id4 FinAdmin) (and (role_le FinAdmin W) (executed_0 id4 t8_invokeI))) (or (and (user_role_assign id5 FinAdmin) (and (role_le FinAdmin W) (executed_0 id5 t8_invokeI))) (or (and (user_role_assign id6 FinAdmin) (and (role_le FinAdmin W) (executed_0 id6 t8_invokeI))) (or (and (user_role_assign id7 FinAdmin) (and (role_le FinAdmin W) (executed_0 id7 t8_invokeI))) (or (and (user_role_assign id1 POAdmin) (and (role_le POAdmin W) (executed_0 id1 t8_invokeI))) (or (and (user_role_assign id2 POAdmin) (and (role_le POAdmin W) (executed_0 id2 t8_invokeI))) (or (and (user_role_assign id3 POAdmin) (and (role_le POAdmin W) (executed_0 id3 t8_invokeI))) (or (and (user_role_assign id4 POAdmin) (and (role_le POAdmin W) (executed_0 id4 t8_invokeI))) (or (and (user_role_assign id5 POAdmin) (and (role_le POAdmin W) (executed_0 id5 t8_invokeI))) (or (and (user_role_assign id6 POAdmin) (and (role_le POAdmin W) (executed_0 id6 t8_invokeI))) (or (and (user_role_assign id7 POAdmin) (and (role_le POAdmin W) (executed_0 id7 t8_invokeI))) (or (and (user_role_assign id1 Client) (and (role_le Client W) (executed_0 id1 t8_invokeI))) (or (and (user_role_assign id2 Client) (and (role_le Client W) (executed_0 id2 t8_invokeI))) (or (and (user_role_assign id3 Client) (and (role_le Client W) (executed_0 id3 t8_invokeI))) (or (and (user_role_assign id4 Client) (and (role_le Client W) (executed_0 id4 t8_invokeI))) (or (and (user_role_assign id5 Client) (and (role_le Client W) (executed_0 id5 t8_invokeI))) (or (and (user_role_assign id6 Client) (and (role_le Client W) (executed_0 id6 t8_invokeI))) (and (user_role_assign id7 Client) (and (role_le Client W) (executed_0 id7 t8_invokeI))))))))))))))))))))))))))))))))))))))))))))) )) )) (or (and (= V t1_receive) (has_permission U t1_receive)) (or (and (= V t2_invoke) (has_permission U t2_invoke)) (or (and (= V t7_invokeO) (has_permission U t7_invokeO)) (and (= V t8_invokeI) (has_permission U t8_invokeI)))))))))))\n \n\n;assumption 51\n(assert\n(forall ((U Id) (V Action)) (iff (can_exec_1 U V) (or (and (= V t5_invoke) (and (has_permission U t5_invoke) (or (and (not (= U id1)) (executed_1 id1 t2_invoke)) (or (and (not (= U id2)) (executed_1 id2 t2_invoke)) (or (and (not (= U id3)) (executed_1 id3 t2_invoke)) (or (and (not (= U id4)) (executed_1 id4 t2_invoke)) (or (and (not (= U id5)) (executed_1 id5 t2_invoke)) (or (and (not (= U id6)) (executed_1 id6 t2_invoke)) (and (not (= U id7)) (executed_1 id7 t2_invoke)))))))))) (or (and (= V t6_invoke) (and (and (has_permission U t6_invoke) (or (and (not (= U id1)) (executed_1 id1 t2_invoke)) (or (and (not (= U id2)) (executed_1 id2 t2_invoke)) (or (and (not (= U id3)) (executed_1 id3 t2_invoke)) (or (and (not (= U id4)) (executed_1 id4 t2_invoke)) (or (and (not (= U id5)) (executed_1 id5 t2_invoke)) (or (and (not (= U id6)) (executed_1 id6 t2_invoke)) (and (not (= U id7)) (executed_1 id7 t2_invoke))))))))) (and (has_permission U t6_invoke) (or (and (not (= U id1)) (executed_1 id1 t5_invoke)) (or (and (not (= U id2)) (executed_1 id2 t5_invoke)) (or (and (not (= U id3)) (executed_1 id3 t5_invoke)) (or (and (not (= U id4)) (executed_1 id4 t5_invoke)) (or (and (not (= U id5)) (executed_1 id5 t5_invoke)) (or (and (not (= U id6)) (executed_1 id6 t5_invoke)) (and (not (= U id7)) (executed_1 id7 t5_invoke))))))))))) (or (and (= V t9_invoke) (and (has_permission U t9_invoke) (exists ((W Role))  (and (user_role_assign U W) (and (or (and (user_role_assign id1 Manager) (and (role_le Manager W) (executed_1 id1 t7_invokeO))) (or (and (user_role_assign id2 Manager) (and (role_le Manager W) (executed_1 id2 t7_invokeO))) (or (and (user_role_assign id3 Manager) (and (role_le Manager W) (executed_1 id3 t7_invokeO))) (or (and (user_role_assign id4 Manager) (and (role_le Manager W) (executed_1 id4 t7_invokeO))) (or (and (user_role_assign id5 Manager) (and (role_le Manager W) (executed_1 id5 t7_invokeO))) (or (and (user_role_assign id6 Manager) (and (role_le Manager W) (executed_1 id6 t7_invokeO))) (or (and (user_role_assign id7 Manager) (and (role_le Manager W) (executed_1 id7 t7_invokeO))) (or (and (user_role_assign id1 POClerk) (and (role_le POClerk W) (executed_1 id1 t7_invokeO))) (or (and (user_role_assign id2 POClerk) (and (role_le POClerk W) (executed_1 id2 t7_invokeO))) (or (and (user_role_assign id3 POClerk) (and (role_le POClerk W) (executed_1 id3 t7_invokeO))) (or (and (user_role_assign id4 POClerk) (and (role_le POClerk W) (executed_1 id4 t7_invokeO))) (or (and (user_role_assign id5 POClerk) (and (role_le POClerk W) (executed_1 id5 t7_invokeO))) (or (and (user_role_assign id6 POClerk) (and (role_le POClerk W) (executed_1 id6 t7_invokeO))) (or (and (user_role_assign id7 POClerk) (and (role_le POClerk W) (executed_1 id7 t7_invokeO))) (or (and (user_role_assign id1 FinClerk) (and (role_le FinClerk W) (executed_1 id1 t7_invokeO))) (or (and (user_role_assign id2 FinClerk) (and (role_le FinClerk W) (executed_1 id2 t7_invokeO))) (or (and (user_role_assign id3 FinClerk) (and (role_le FinClerk W) (executed_1 id3 t7_invokeO))) (or (and (user_role_assign id4 FinClerk) (and (role_le FinClerk W) (executed_1 id4 t7_invokeO))) (or (and (user_role_assign id5 FinClerk) (and (role_le FinClerk W) (executed_1 id5 t7_invokeO))) (or (and (user_role_assign id6 FinClerk) (and (role_le FinClerk W) (executed_1 id6 t7_invokeO))) (or (and (user_role_assign id7 FinClerk) (and (role_le FinClerk W) (executed_1 id7 t7_invokeO))) (or (and (user_role_assign id1 FinAdmin) (and (role_le FinAdmin W) (executed_1 id1 t7_invokeO))) (or (and (user_role_assign id2 FinAdmin) (and (role_le FinAdmin W) (executed_1 id2 t7_invokeO))) (or (and (user_role_assign id3 FinAdmin) (and (role_le FinAdmin W) (executed_1 id3 t7_invokeO))) (or (and (user_role_assign id4 FinAdmin) (and (role_le FinAdmin W) (executed_1 id4 t7_invokeO))) (or (and (user_role_assign id5 FinAdmin) (and (role_le FinAdmin W) (executed_1 id5 t7_invokeO))) (or (and (user_role_assign id6 FinAdmin) (and (role_le FinAdmin W) (executed_1 id6 t7_invokeO))) (or (and (user_role_assign id7 FinAdmin) (and (role_le FinAdmin W) (executed_1 id7 t7_invokeO))) (or (and (user_role_assign id1 POAdmin) (and (role_le POAdmin W) (executed_1 id1 t7_invokeO))) (or (and (user_role_assign id2 POAdmin) (and (role_le POAdmin W) (executed_1 id2 t7_invokeO))) (or (and (user_role_assign id3 POAdmin) (and (role_le POAdmin W) (executed_1 id3 t7_invokeO))) (or (and (user_role_assign id4 POAdmin) (and (role_le POAdmin W) (executed_1 id4 t7_invokeO))) (or (and (user_role_assign id5 POAdmin) (and (role_le POAdmin W) (executed_1 id5 t7_invokeO))) (or (and (user_role_assign id6 POAdmin) (and (role_le POAdmin W) (executed_1 id6 t7_invokeO))) (or (and (user_role_assign id7 POAdmin) (and (role_le POAdmin W) (executed_1 id7 t7_invokeO))) (or (and (user_role_assign id1 Client) (and (role_le Client W) (executed_1 id1 t7_invokeO))) (or (and (user_role_assign id2 Client) (and (role_le Client W) (executed_1 id2 t7_invokeO))) (or (and (user_role_assign id3 Client) (and (role_le Client W) (executed_1 id3 t7_invokeO))) (or (and (user_role_assign id4 Client) (and (role_le Client W) (executed_1 id4 t7_invokeO))) (or (and (user_role_assign id5 Client) (and (role_le Client W) (executed_1 id5 t7_invokeO))) (or (and (user_role_assign id6 Client) (and (role_le Client W) (executed_1 id6 t7_invokeO))) (and (user_role_assign id7 Client) (and (role_le Client W) (executed_1 id7 t7_invokeO)))))))))))))))))))))))))))))))))))))))))))) (or (and (user_role_assign id1 Manager) (and (role_le Manager W) (executed_1 id1 t8_invokeI))) (or (and (user_role_assign id2 Manager) (and (role_le Manager W) (executed_1 id2 t8_invokeI))) (or (and (user_role_assign id3 Manager) (and (role_le Manager W) (executed_1 id3 t8_invokeI))) (or (and (user_role_assign id4 Manager) (and (role_le Manager W) (executed_1 id4 t8_invokeI))) (or (and (user_role_assign id5 Manager) (and (role_le Manager W) (executed_1 id5 t8_invokeI))) (or (and (user_role_assign id6 Manager) (and (role_le Manager W) (executed_1 id6 t8_invokeI))) (or (and (user_role_assign id7 Manager) (and (role_le Manager W) (executed_1 id7 t8_invokeI))) (or (and (user_role_assign id1 POClerk) (and (role_le POClerk W) (executed_1 id1 t8_invokeI))) (or (and (user_role_assign id2 POClerk) (and (role_le POClerk W) (executed_1 id2 t8_invokeI))) (or (and (user_role_assign id3 POClerk) (and (role_le POClerk W) (executed_1 id3 t8_invokeI))) (or (and (user_role_assign id4 POClerk) (and (role_le POClerk W) (executed_1 id4 t8_invokeI))) (or (and (user_role_assign id5 POClerk) (and (role_le POClerk W) (executed_1 id5 t8_invokeI))) (or (and (user_role_assign id6 POClerk) (and (role_le POClerk W) (executed_1 id6 t8_invokeI))) (or (and (user_role_assign id7 POClerk) (and (role_le POClerk W) (executed_1 id7 t8_invokeI))) (or (and (user_role_assign id1 FinClerk) (and (role_le FinClerk W) (executed_1 id1 t8_invokeI))) (or (and (user_role_assign id2 FinClerk) (and (role_le FinClerk W) (executed_1 id2 t8_invokeI))) (or (and (user_role_assign id3 FinClerk) (and (role_le FinClerk W) (executed_1 id3 t8_invokeI))) (or (and (user_role_assign id4 FinClerk) (and (role_le FinClerk W) (executed_1 id4 t8_invokeI))) (or (and (user_role_assign id5 FinClerk) (and (role_le FinClerk W) (executed_1 id5 t8_invokeI))) (or (and (user_role_assign id6 FinClerk) (and (role_le FinClerk W) (executed_1 id6 t8_invokeI))) (or (and (user_role_assign id7 FinClerk) (and (role_le FinClerk W) (executed_1 id7 t8_invokeI))) (or (and (user_role_assign id1 FinAdmin) (and (role_le FinAdmin W) (executed_1 id1 t8_invokeI))) (or (and (user_role_assign id2 FinAdmin) (and (role_le FinAdmin W) (executed_1 id2 t8_invokeI))) (or (and (user_role_assign id3 FinAdmin) (and (role_le FinAdmin W) (executed_1 id3 t8_invokeI))) (or (and (user_role_assign id4 FinAdmin) (and (role_le FinAdmin W) (executed_1 id4 t8_invokeI))) (or (and (user_role_assign id5 FinAdmin) (and (role_le FinAdmin W) (executed_1 id5 t8_invokeI))) (or (and (user_role_assign id6 FinAdmin) (and (role_le FinAdmin W) (executed_1 id6 t8_invokeI))) (or (and (user_role_assign id7 FinAdmin) (and (role_le FinAdmin W) (executed_1 id7 t8_invokeI))) (or (and (user_role_assign id1 POAdmin) (and (role_le POAdmin W) (executed_1 id1 t8_invokeI))) (or (and (user_role_assign id2 POAdmin) (and (role_le POAdmin W) (executed_1 id2 t8_invokeI))) (or (and (user_role_assign id3 POAdmin) (and (role_le POAdmin W) (executed_1 id3 t8_invokeI))) (or (and (user_role_assign id4 POAdmin) (and (role_le POAdmin W) (executed_1 id4 t8_invokeI))) (or (and (user_role_assign id5 POAdmin) (and (role_le POAdmin W) (executed_1 id5 t8_invokeI))) (or (and (user_role_assign id6 POAdmin) (and (role_le POAdmin W) (executed_1 id6 t8_invokeI))) (or (and (user_role_assign id7 POAdmin) (and (role_le POAdmin W) (executed_1 id7 t8_invokeI))) (or (and (user_role_assign id1 Client) (and (role_le Client W) (executed_1 id1 t8_invokeI))) (or (and (user_role_assign id2 Client) (and (role_le Client W) (executed_1 id2 t8_invokeI))) (or (and (user_role_assign id3 Client) (and (role_le Client W) (executed_1 id3 t8_invokeI))) (or (and (user_role_assign id4 Client) (and (role_le Client W) (executed_1 id4 t8_invokeI))) (or (and (user_role_assign id5 Client) (and (role_le Client W) (executed_1 id5 t8_invokeI))) (or (and (user_role_assign id6 Client) (and (role_le Client W) (executed_1 id6 t8_invokeI))) (and (user_role_assign id7 Client) (and (role_le Client W) (executed_1 id7 t8_invokeI))))))))))))))))))))))))))))))))))))))))))))) )) )) (or (and (= V t1_receive) (has_permission U t1_receive)) (or (and (= V t2_invoke) (has_permission U t2_invoke)) (or (and (= V t7_invokeO) (has_permission U t7_invokeO)) (and (= V t8_invokeI) (has_permission U t8_invokeI)))))))))))\n \n\n;assumption 52\n(assert\n(forall ((U Id)) (iff (t1_receive_0_1 U)\n   (and (and (can_exec_0 U t1_receive) (and (= 1 in_customer_crtPO_0) (= 1 p9_initial_0)))\n  (and (and (= p1_final_1 p1_final_0) (and (= p2_final_1 p2_final_0) (and (= p3_running_1 p3_running_0) (and (= p4_final_1 p4_final_0) (and (= p5_final_1 p5_final_0) (and (= p6_initial_1 p6_initial_0) (and (= p7_final_1 p7_final_0) (and (= p8_initial_1 p8_initial_0) (and (= p9_initial_1 (+ (~ 1) p9_initial_0)) (and (= p10_final_1 (+ 1 p10_final_0)) (and (= p11_final_1 p11_final_0) (and (= in_customer_crtPO_1 (+ (~ 1) in_customer_crtPO_0)) (and (= in_creator_ctrPay_1 in_creator_ctrPay_0) (and (= out_creator_ctrPay_1 out_creator_ctrPay_0) (and (= out_approverPOPayment_apprPay_1 out_approverPOPayment_apprPay_0) (and (= out_approverPO_apprPO_1 out_approverPO_apprPO_0) (and (= out_signerGRN_signGRN_1 out_signerGRN_signGRN_0) (and (= out_signerGRN_ctrsignGRN_1 out_signerGRN_ctrsignGRN_0) true))))))))))))))))))\n  (forall ((V Id) (W Action)) (iff (executed_1 V W) (or (and (= V U) (= W t1_receive)) (executed_0 V W))))\n  )\n  )\n   )))\n \n\n;assumption 53\n(assert \n (not (and initial_wf_0 (and initial_pm_0 (t1_receive_0_1 id6))))\n )\n\n(set-info status sat)\n(check-sat)\n(get-model)"},mdxType:"Z3CodeBlock"}),(0,r.kt)("p",null,"It is very effective in this benchmark since it contains many quantifiers of the form"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"forall x.  p(x) = ....")),(0,r.kt)("p",null,"The Z3 model finder is more effective if the input formula does not contain nested quantifiers. If that is not the case for your formula, you can use the option"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"(set-option smt.pull-nested-quantifiers true)")),(0,r.kt)("p",null,"The following challenge problem from the paper ",(0,r.kt)("a",{parentName:"p",href:"httpacademic.research.microsoft.comPaper615910.aspx"},"SEM a system for enumerating models")," is proved to be unsatisfiable in less than one second by Z3."),(0,r.kt)(a.Z,{input:{code:"(set-option smt.mbqi true)\n(declare-sort S)\n(declare-fun g (S S) S)\n(declare-fun f (S S) S)\n(declare-const a S)\n(declare-const b S)\n\n(assert (forall ((x S) (y S))\n                (= (g (f x y) (f x x)) x)))\n(assert (forall ((x S) (y S))\n                (= (f (g x y) (g x x)) x)))\n(assert (forall ((x S) (y S) (z S))\n                (= (g (g x y) z) (g (g y z) x))))\n(assert (forall ((x S) (y S) (z S))\n                (= (f (f x y) z) (f (f y z) x))))\n(assert (distinct (g a (f b a)) (f a (g b a))))\n(check-sat)"},mdxType:"Z3CodeBlock"}))}p.isMDXComponent=!0}}]);