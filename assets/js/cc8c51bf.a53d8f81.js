"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[949],{2287:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>d,toc:()=>c});var n=a(3117),s=(a(7294),a(3905)),i=a(7689);const o={title:"Lambdas",sidebar_position:16},r=void 0,d={unversionedId:"logic/Lambdas",id:"logic/Lambdas",title:"Lambdas",description:"Lambda binding is available as an extension to the theory of arrays.",source:"@site/docs/01 - logic/16 - Lambdas.md",sourceDirName:"01 - logic",slug:"/logic/Lambdas",permalink:"/z3guide/docs/logic/Lambdas",draft:!1,editUrl:"https://github.com/microsoft/z3guide/tree/main/website/docs/01 - logic/16 - Lambdas.md",tags:[],version:"current",sidebarPosition:16,frontMatter:{title:"Lambdas",sidebar_position:16},sidebar:"tutorialSidebar",previous:{title:"Quantifiers",permalink:"/z3guide/docs/logic/Quantifiers"},next:{title:"Recursive Functions",permalink:"/z3guide/docs/logic/Recursive Functions"}},l={},c=[],m={toc:c};function u(e){let{components:t,...a}=e;return(0,s.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Lambda binding is available as an extension to the theory of arrays.\nThus, the type of a lambda expression is an array where the domain of the\narray are the argument types and the range is the sort of the body of the lambda expression."),(0,s.kt)(i.Z,{input:{code:"(declare-const m (Array Int Int))\n(declare-const m1 (Array Int Int))\n(declare-const z Int)\n(define-fun memset ((lo Int) (hi Int) (y Int) (m (Array Int Int))) \n                   (Array Int Int) \n           (lambda ((x Int)) (if (and (<= lo x) (<= x hi)) y (m x))))\n(assert (= m1 (memset 1 700 z m)))\n(assert (not (= (select m1 6) z)))\n(check-sat)",result:{output:"unsat\n",error:"",status:"z3-ran",hash:"d88d646d2d46f0439187e71470a116ee79f4f483"}},mdxType:"Z3CodeBlock"}),(0,s.kt)("p",null,"The main utility of lambdas in Z3 is for introducing inline definitions as the ",(0,s.kt)("inlineCode",{parentName:"p"},"memset")," example illustrates.\nThere is limited true higher order reasoning. One basic example that ",(0,s.kt)("em",{parentName:"p"},"does")," work thanks to model construction of MBQI instantiation procedure\nis establishing a second-order definition for equality."),(0,s.kt)(i.Z,{input:{code:"(declare-const x Int)\n(declare-const y Int)\n(assert (forall ((q (Array Int Bool))) (= (q x) (q y))))\n(assert (not (= x y)))\n(check-sat)",result:{output:"unsat\n",error:"",status:"z3-ran",hash:"d4b145e518d3f0f32e6f9d1c63275f3de42c3aa2"}},mdxType:"Z3CodeBlock"}))}u.isMDXComponent=!0}}]);