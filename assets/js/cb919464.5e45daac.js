"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2563],{6569:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>m,toc:()=>u});var a=s(8168),i=(s(6540),s(5680)),r=s(2317),n=s.n(r);const o={title:"Bitvectors",sidebar_position:2},l=void 0,m={unversionedId:"theories/Bitvectors",id:"theories/Bitvectors",title:"Bitvectors",description:"SMTLIB2 standard The Theory of fixed sized bit-vectors",source:"@site/docs-smtlib/02 - theories/02 - Bitvectors.md",sourceDirName:"02 - theories",slug:"/theories/Bitvectors",permalink:"/z3guide/docs/theories/Bitvectors",draft:!1,editUrl:"https://github.com/microsoft/z3guide/tree/main/website/docs-smtlib/02 - theories/02 - Bitvectors.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Bitvectors",sidebar_position:2},sidebar:"smtlibSidebar",previous:{title:"Arithmetic",permalink:"/z3guide/docs/theories/Arithmetic"},next:{title:"IEEE Floats",permalink:"/z3guide/docs/theories/IEEE Floats"}},c={},u=[{value:"Basic Bitvector Arithmetic",id:"basic-bitvector-arithmetic",level:3},{value:"Bitwise Operations",id:"bitwise-operations",level:3},{value:"Word operations",id:"word-operations",level:3},{value:"Predicates over Bitvectors",id:"predicates-over-bitvectors",level:3},{value:"BitVectors and Integers",id:"bitvectors-and-integers",level:3}],d={toc:u},p="wrapper";function h(e){let{components:t,...s}=e;return(0,i.yg)(p,(0,a.A)({},d,s,{components:t,mdxType:"MDXLayout"}),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"}," ",(0,i.yg)("strong",{parentName:"p"},"SMTLIB2")," standard ",(0,i.yg)("a",{parentName:"p",href:"https://smt-lib.org/theories-FixedSizeBitVectors.shtml"},"The Theory of fixed sized bit-vectors"))),(0,i.yg)("p",null,"Modern CPUs and main-stream programming languages use arithmetic over fixed-size bit-vectors. The theory of bit-vectors allows modeling the precise semantics of unsigned and of signed two-complements arithmetic. There are a large number of supported functions and relations over bit-vectors. They are summarized on Z3's documentation ",(0,i.yg)("a",{parentName:"p",href:"https://z3prover.github.io/api/html/z3__api_8h.html"},"link"),". We will not try to give a comprehensive overview here, but touch on some of the main features."),(0,i.yg)("p",null,"In contrast to programming languages, such as C, C++, C#, Java, there is no distinction between signed and unsigned bit-vectors as numbers. Instead, the theory of bit-vectors provides special signed versions of arithmetical operations where it makes a difference whether the bit-vector is treated as signed or unsigned."),(0,i.yg)("p",null,"Z3 supports Bitvectors of arbitrary size. (","_"," BitVec n) is the sort of bitvectors whose length is n. Bitvector literals may be defined using binary, decimal and hexadecimal notation. In the binary and hexadecimal cases, the bitvector size is inferred from the number of characters. For example, the bitvector literal #b010 in binary format is a bitvector of size 3, and the bitvector literal #x0a0 in hexadecimal format is a bitvector of size 12. The size must be specified for bitvector literals in decimal format. For example, (","_"," bv10 32) is a bitvector of size 32 that represents the numeral 10. By default, Z3 display bitvectors in hexadecimal format if the bitvector size is a multiple of 4, and in binary otherwise. The command (set-option pp.bv-literals false) can be used to force Z3 to display bitvector literals in decimal format."),(0,i.yg)(n(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(display #b0100)\n(display (_ bv20 8))\n(display (_ bv20 7))\n(display #x0a) \n(set-option :pp.bv-literals false)\n(display #b0100)\n(display (_ bv20 8))\n(display (_ bv20 7))\n(display #x0a) ",result:{output:"#x4\n#x14\n#b0010100\n#x0a\n(_ bv4 4)\n(_ bv20 8)\n(_ bv20 7)\n(_ bv10 8)\n",error:"",status:"z3-ran",hash:"b1b211c6cc2d3bfcbd13ad29ec01dfa6150ec93b"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,i.yg)("h3",{id:"basic-bitvector-arithmetic"},"Basic Bitvector Arithmetic"),(0,i.yg)(n(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(simplify (bvadd #x07 #x03)) ; addition\n(simplify (bvsub #x07 #x03)) ; subtraction\n(simplify (bvneg #x07)) ; unary minus\n(simplify (bvmul #x07 #x03)) ; multiplication\n(simplify (bvurem #x07 #x03)) ; unsigned remainder\n(simplify (bvsrem #x07 #x03)) ; signed remainder\n(simplify (bvsmod #x07 #x03)) ; signed modulo\n(simplify (bvshl #x07 #x03)) ; shift left\n(simplify (bvlshr #xf0 #x03)) ; unsigned (logical) shift right\n(simplify (bvashr #xf0 #x03)) ; signed (arithmetical) shift right",result:{output:"#x0a\n#x04\n#xf9\n#x15\n#x01\n#x01\n#x01\n#x38\n#x1e\n#xfe\n",error:"",status:"z3-ran",hash:"a8f60c9b869223fce655d1c2485a9bc63bb0b7b6"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,i.yg)("h3",{id:"bitwise-operations"},"Bitwise Operations"),(0,i.yg)(n(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(simplify (bvor #x6 #x3))   ; bitwise or\n(simplify (bvand #x6 #x3))  ; bitwise and\n(simplify (bvnot #x6)) ; bitwise not\n(simplify (bvnand #x6 #x3)) ; bitwise nand\n(simplify (bvnor #x6 #x3)) ; bitwise nor\n(simplify (bvxnor #x6 #x3)) ; bitwise xnor",result:{output:"#x7\n#x2\n#x9\n#xd\n#x8\n#xa\n",error:"",status:"z3-ran",hash:"8cb9f28fde344372da45b2c6ace0026163d89cd3"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,i.yg)("p",null,"We can prove a bitwise version of deMorgan's law"),(0,i.yg)(n(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x (_ BitVec 64))\n(declare-const y (_ BitVec 64))\n(assert (not (= (bvand (bvnot x) (bvnot y)) (bvnot (bvor x y)))))\n(check-sat)",result:{output:"unsat\n",error:"",status:"z3-ran",hash:"5700f66db565882868f1d83ba855aee79ec2fae7"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,i.yg)("p",null,"Let us illustrate a simple property of bit-wise arithmetic. There is a fast way to check that fixed size numbers are powers of two. It turns out that a bit-vector x is a power of two or zero if and only if x & (x - 1) is zero, where & represents the bitwise and. We check this for four bits below."),(0,i.yg)(n(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(define-fun is-power-of-two ((x (_ BitVec 4))) Bool \n  (= #x0 (bvand x (bvsub x #x1))))\n(declare-const a (_ BitVec 4))\n(assert \n (not (= (is-power-of-two a) \n         (or (= a #x0) \n             (= a #x1) \n             (= a #x2) \n             (= a #x4) \n             (= a #x8)))))\n(check-sat)",result:{output:"unsat\n",error:"",status:"z3-ran",hash:"5d0317eef640c2e2c0699495c555e27e479f4991"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,i.yg)("h3",{id:"word-operations"},"Word operations"),(0,i.yg)(n(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const a (_ BitVec 4))\n(simplify (concat a #x0 #x1 #x2))\n(simplify ((_ zero_extend 4) #xF))\n(simplify ((_ sign_extend 4) #xF))\n(simplify ((_ extract 15 8) #xABCD1234))\n(simplify ((_ rotate_left 4) #xABCD))\n(simplify ((_ rotate_right 4) #xABCD))\n(simplify ((_ repeat 3) #xABC))",result:{output:"(concat a #x012)\n#x0f\n#xff\n#x12\n#xbcda\n#xdabc\n#xabcabcabc\n",error:"",status:"z3-ran",hash:"b7ec1e2aaaea1afa80a1bb8cb30ed8b3d0bf09df"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,i.yg)("h3",{id:"predicates-over-bitvectors"},"Predicates over Bitvectors"),(0,i.yg)(n(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(simplify (bvule #x0a #xf0))  ; unsigned less or equal\n(simplify (bvult #x0a #xf0))  ; unsigned less than\n(simplify (bvuge #x0a #xf0))  ; unsigned greater or equal\n(simplify (bvugt #x0a #xf0))  ; unsigned greater than\n(simplify (bvsle #x0a #xf0))  ; signed less or equal\n(simplify (bvslt #x0a #xf0))  ; signed less than\n(simplify (bvsge #x0a #xf0))  ; signed greater or equal\n(simplify (bvsgt #x0a #xf0))  ; signed greater than",result:{output:"true\ntrue\nfalse\nfalse\nfalse\nfalse\ntrue\ntrue\n",error:"",status:"z3-ran",hash:"019a690e4caef13ac059c48da847c5d9585baf9f"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,i.yg)("p",null,"Signed comparison, such as bvsle, takes the sign bit of bitvectors into account for comparison, while unsigned comparison treats the bitvector as unsigned (treats the bitvector as a natural number)."),(0,i.yg)(n(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const a (_ BitVec 4))\n(declare-const b (_ BitVec 4))\n(assert (not (= (bvule a b) (bvsle a b))))\n(check-sat)\n(get-model)",result:{output:"sat\n(\n  (define-fun b () (_ BitVec 4)\n    #x6)\n  (define-fun a () (_ BitVec 4)\n    #x8)\n)\n",error:"",status:"z3-ran",hash:"216e910e4ce7a9f0338553fe1a08d0be3587f1fb"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,i.yg)("h3",{id:"bitvectors-and-integers"},"BitVectors and Integers"),(0,i.yg)("p",null,"You can mix integers and bit-vectors.\nNote that reasoning in the combination has significant overhead so you\nwill be better off if you can model your problems entirely only using bit-vectors\nor entirely using integers (reals).\nIn the conversion function from bit-vectors to integers, bit-vectors correspond to non-negative integers.\nFor the conversion function that maps integers to bit-vectors you have to supply the bit-width ",(0,i.yg)("span",{parentName:"p",className:"math math-inline"},(0,i.yg)("span",{parentName:"span",className:"katex"},(0,i.yg)("span",{parentName:"span",className:"katex-mathml"},(0,i.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.yg)("semantics",{parentName:"math"},(0,i.yg)("mrow",{parentName:"semantics"},(0,i.yg)("mi",{parentName:"mrow"},"n")),(0,i.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n")))),(0,i.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.yg)("span",{parentName:"span",className:"base"},(0,i.yg)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,i.yg)("span",{parentName:"span",className:"mord mathnormal"},"n"))))),". Then the\nbit-vector corresponding to the integer argument represents the unsigned number obtained by taking the modulus\nwith respect to ",(0,i.yg)("span",{parentName:"p",className:"math math-inline"},(0,i.yg)("span",{parentName:"span",className:"katex"},(0,i.yg)("span",{parentName:"span",className:"katex-mathml"},(0,i.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.yg)("semantics",{parentName:"math"},(0,i.yg)("mrow",{parentName:"semantics"},(0,i.yg)("msup",{parentName:"mrow"},(0,i.yg)("mn",{parentName:"msup"},"2"),(0,i.yg)("mi",{parentName:"msup"},"n"))),(0,i.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"2^n")))),(0,i.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.yg)("span",{parentName:"span",className:"base"},(0,i.yg)("span",{parentName:"span",className:"strut",style:{height:"0.6644em"}}),(0,i.yg)("span",{parentName:"span",className:"mord"},(0,i.yg)("span",{parentName:"span",className:"mord"},"2"),(0,i.yg)("span",{parentName:"span",className:"msupsub"},(0,i.yg)("span",{parentName:"span",className:"vlist-t"},(0,i.yg)("span",{parentName:"span",className:"vlist-r"},(0,i.yg)("span",{parentName:"span",className:"vlist",style:{height:"0.6644em"}},(0,i.yg)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,i.yg)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,i.yg)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,i.yg)("span",{parentName:"span",className:"mord mathnormal mtight"},"n")))))))))))),"."),(0,i.yg)(n(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(simplify (bv2int #xa0))\n(simplify ((_ int2bv 32) -3))",result:{output:"160\n#xfffffffd\n",error:"",status:"z3-ran",hash:"749ef8bb127d93a9314411020915597b638d7bc2"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}))}h.isMDXComponent=!0}}]);