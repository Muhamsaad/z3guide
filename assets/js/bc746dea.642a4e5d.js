"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9449],{5016:(t,a,e)=>{e.r(a),e.d(a,{assets:()=>p,contentTitle:()=>o,default:()=>k,frontMatter:()=>i,metadata:()=>m,toc:()=>d});var n=e(3117),r=(e(7294),e(3905)),l=e(7634),s=e.n(l);const i={title:"Tactics Summary",sidebar_position:5},o=void 0,m={unversionedId:"strategies/summary",id:"strategies/summary",title:"Tactics Summary",description:"Tactic blast-term-ite",source:"@site/docs-smtlib/03 - strategies/05 - summary.md",sourceDirName:"03 - strategies",slug:"/strategies/summary",permalink:"/z3guide/docs/strategies/summary",draft:!1,editUrl:"https://github.com/microsoft/z3guide/tree/main/website/docs-smtlib/03 - strategies/05 - summary.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"Tactics Summary",sidebar_position:5},sidebar:"smtlibSidebar",previous:{title:"Probes",permalink:"/z3guide/docs/strategies/probes"},next:{title:"Introduction",permalink:"/z3guide/docs/optimization/intro"}},p={},d=[{value:"Tactic blast-term-ite",id:"tactic-blast-term-ite",level:2},{value:"Short Description:",id:"short-description",level:3},{value:"Example",id:"example",level:3},{value:"Notes",id:"notes",level:3},{value:"Parameters",id:"parameters",level:3},{value:"Tactic card2bv",id:"tactic-card2bv",level:2},{value:"Short Description",id:"short-description-1",level:3},{value:"Long Description",id:"long-description",level:3},{value:"Example",id:"example-1",level:3},{value:"Notes",id:"notes-1",level:3},{value:"Parameters",id:"parameters-1",level:3},{value:"Tactic ctx-simplify",id:"tactic-ctx-simplify",level:2},{value:"Short Description:",id:"short-description-2",level:3},{value:"Example",id:"example-2",level:3},{value:"Notes",id:"notes-2",level:3},{value:"Parameters",id:"parameters-2",level:3},{value:"Tactic degree-shift",id:"tactic-degree-shift",level:2},{value:"Short Description",id:"short-description-3",level:3},{value:"Long Description",id:"long-description-1",level:3},{value:"Example",id:"example-3",level:3},{value:"Notes",id:"notes-3",level:3},{value:"Parameters",id:"parameters-3",level:3},{value:"Tactic demodulator",id:"tactic-demodulator",level:2},{value:"Short Description:",id:"short-description-4",level:3},{value:"Long Description",id:"long-description-2",level:3},{value:"Example",id:"example-4",level:3},{value:"Notes",id:"notes-4",level:3},{value:"Tactic der",id:"tactic-der",level:2},{value:"Short Description:",id:"short-description-5",level:3},{value:"Long Description",id:"long-description-3",level:3},{value:"Example",id:"example-5",level:3},{value:"Notes",id:"notes-5",level:3},{value:"Tactic diff-neq",id:"tactic-diff-neq",level:2},{value:"Short Description",id:"short-description-6",level:3},{value:"Long Description",id:"long-description-4",level:3},{value:"Example",id:"example-6",level:3},{value:"Notes",id:"notes-6",level:3},{value:"Parameters",id:"parameters-4",level:3},{value:"Tactic distribute-forall",id:"tactic-distribute-forall",level:2},{value:"Short Description:",id:"short-description-7",level:3},{value:"Example",id:"example-7",level:3},{value:"Notes",id:"notes-7",level:3},{value:"Tactic elim-term-ite",id:"tactic-elim-term-ite",level:2},{value:"Short Description:",id:"short-description-8",level:3},{value:"Example",id:"example-8",level:3},{value:"Notes",id:"notes-8",level:3},{value:"Parameters",id:"parameters-5",level:3},{value:"Tactic elim-uncnstr",id:"tactic-elim-uncnstr",level:2},{value:"Short Description",id:"short-description-9",level:3},{value:"Long Description",id:"long-description-5",level:3},{value:"Boolean Connectives",id:"boolean-connectives",level:4},{value:"Arithmetic",id:"arithmetic",level:4},{value:"Bit-vectors",id:"bit-vectors",level:4},{value:"Arrays",id:"arrays",level:4},{value:"Algebraic Datatypes",id:"algebraic-datatypes",level:4},{value:"Example",id:"example-9",level:3},{value:"Notes",id:"notes-9",level:3},{value:"Parameters",id:"parameters-6",level:3},{value:"Tactic eq2bv",id:"tactic-eq2bv",level:2},{value:"Short Description",id:"short-description-10",level:3},{value:"Example",id:"example-10",level:3},{value:"Notes",id:"notes-10",level:3},{value:"Tactic factor",id:"tactic-factor",level:2},{value:"Short Description",id:"short-description-11",level:3},{value:"Example",id:"example-11",level:3},{value:"Parameters",id:"parameters-7",level:3},{value:"Tactic fix-dl-var",id:"tactic-fix-dl-var",level:2},{value:"Short Description",id:"short-description-12",level:3},{value:"Example",id:"example-12",level:3},{value:"Parameters",id:"parameters-8",level:3},{value:"Tactic fm",id:"tactic-fm",level:2},{value:"Short Description",id:"short-description-13",level:3},{value:"Example",id:"example-13",level:3},{value:"Parameters",id:"parameters-9",level:3},{value:"Tactic injectivity",id:"tactic-injectivity",level:2},{value:"Short Description:",id:"short-description-14",level:3},{value:"Example",id:"example-14",level:3},{value:"Notes",id:"notes-11",level:3},{value:"Parameters",id:"parameters-10",level:3},{value:"Tactic nnf",id:"tactic-nnf",level:2},{value:"Short Description:",id:"short-description-15",level:3},{value:"Long Description",id:"long-description-6",level:3},{value:"Example",id:"example-15",level:3},{value:"Notes",id:"notes-12",level:3},{value:"Parameters",id:"parameters-11",level:3},{value:"Tactic propagate-values",id:"tactic-propagate-values",level:2},{value:"Short Description:",id:"short-description-16",level:3},{value:"Long Description",id:"long-description-7",level:3},{value:"Example",id:"example-16",level:3},{value:"Notes",id:"notes-13",level:3},{value:"Parameters",id:"parameters-12",level:3},{value:"Tactic reduce-args",id:"tactic-reduce-args",level:2},{value:"Short Description:",id:"short-description-17",level:3},{value:"Long Description",id:"long-description-8",level:3},{value:"Example",id:"example-17",level:3},{value:"Notes",id:"notes-14",level:3},{value:"Tactic simplify",id:"tactic-simplify",level:2},{value:"Short Description:",id:"short-description-18",level:3},{value:"Long Description",id:"long-description-9",level:3},{value:"Example",id:"example-18",level:3},{value:"Notes",id:"notes-15",level:3},{value:"Parameters",id:"parameters-13",level:3},{value:"Tactic solve-eqs",id:"tactic-solve-eqs",level:2},{value:"Short Description",id:"short-description-19",level:3},{value:"Long Description",id:"long-description-10",level:3},{value:"Example",id:"example-19",level:3},{value:"Notes",id:"notes-16",level:3},{value:"Parameters",id:"parameters-14",level:3}],N={toc:d};function k(t){let{components:a,...e}=t;return(0,r.kt)("wrapper",(0,n.Z)({},N,e,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"tactic-blast-term-ite"},"Tactic blast-term-ite"),(0,r.kt)("h3",{id:"short-description"},"Short Description:"),(0,r.kt)("p",null,"Blast term if-then-else by hoisting them up.\nThis is expensive but useful in some cases, such as\nfor enforcing constraints being in difference logic.\nUse ",(0,r.kt)("inlineCode",{parentName:"p"},"elim-term-ite")," elsewhere when possible."),(0,r.kt)("h3",{id:"example"},"Example"),(0,r.kt)(s(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-fun f (Int) Int)\n(declare-fun p (Int) Bool)\n(declare-const c1 Bool)\n(declare-const c2 Bool)\n(declare-const c3 Bool)\n(declare-const e1 Int) \n(declare-const e2 Int) \n(declare-const e3 Int)\n(declare-const e4 Int)\n(assert (p (f (if c1 (if c2 e1 (if c3 e2 e3)) e4))))\n(apply blast-term-ite) ",result:{output:"(goals\n(goal\n  (let ((a!1 (ite c2 (p (f e1)) (ite c3 (p (f e2)) (p (f e3))))))\n    (ite c1 a!1 (p (f e4))))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"093a0c83323584a1debd439b30530ed15f8cb92c"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.11.0",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h3",{id:"notes"},"Notes"),(0,r.kt)("h3",{id:"parameters"},"Parameters"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_inflation"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"(default: infinity) multiplicative factor of initial term size."),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum amount of memory in megabytes."),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_steps"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum number of steps."),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")))),(0,r.kt)("h2",{id:"tactic-card2bv"},"Tactic card2bv"),(0,r.kt)("h3",{id:"short-description-1"},"Short Description"),(0,r.kt)("p",null,"Tactic for converting Pseudo-Boolean constraints to bit-vectors."),(0,r.kt)("h3",{id:"long-description"},"Long Description"),(0,r.kt)("p",null,"The tactic implements a set of standard methods for converting cardinality and Pseudo-Boolean constraints into bit-vector or propositional formulas\n(using basic logical connectives, conjunction, disjunction, negation). The conversions from cardinality constraints are controlled\nseparately from the conversions from Pseudo-Boolean constraints using different parameters."),(0,r.kt)("h3",{id:"example-1"},"Example"),(0,r.kt)(s(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const a1 Bool)\n(declare-const a2 Bool)\n(declare-const a3 Bool)\n(declare-const a4 Bool)\n(declare-const a5 Bool)\n(declare-const a6 Bool)\n(push)\n(assert ((_ at-most 1) a1 a2 a3 a4 a5 a6))\n(assert ((_ at-most 2) a1 a2 a3 a4 a5 a6))\n(apply (with card2bv :cardinality.encoding unate))\n(apply (with card2bv :cardinality.encoding circuit))\n(apply (with card2bv :cardinality.encoding ordered))\n(apply (with card2bv :cardinality.encoding grouped))\n(apply (with card2bv :cardinality.encoding bimander))\n(pop)\n(assert ((_ pbge 5 2 3 4 4 3 5) a1 a2 a3 a4 a5 a6))\n(apply (with card2bv :pb.solver totalizer))\n(apply (with card2bv :pb.solver sorting))\n(apply (with card2bv :pb.solver binary_merge))\n(apply (with card2bv :pb.solver bv))\n(apply (with card2bv :pb.solver solver))",result:{output:"(goals\n(goal\n  at-most-1!0\n  (let ((a!1 (and a5 (or a4 (or a3 (or a2 a1))))))\n  (let ((a!2 (or a!1\n                 (and a4 (or a3 (or a2 a1)))\n                 (and a3 (or a2 a1))\n                 (and a2 a1))))\n    (not (and a6 a!2))))\n  (let ((a!1 (and a5 (or (and a2 a1) (and a4 (or a1 a2 a3)) (and a3 (or a1 a2))))))\n    (not a!1))\n  (let ((a!1 (and a4 (or (and a2 a1) (and a3 (or a1 a2))))))\n    (not a!1))\n  (not (and a3 a2 a1))\n  (or (not at-most-1!0) (not a1) (not a2))\n  (or (not at-most-1!0) (not a1) (not a3))\n  (or (not at-most-1!0) (not a1) (not a4))\n  (or (not at-most-1!0) (not a2) (not a3))\n  (or (not at-most-1!0) (not a2) (not a4))\n  (or (not at-most-1!0) (not a3) (not a4))\n  (or (not at-most-1!0) (not a5) (not a6))\n  (or (not at-most-1!0) (not (or a1 a2 a3 a4)) (not (or a5 a6)))\n  :precision precise :depth 1)\n)\n(goals\n(goal\n  at-most-1!1\n  (let ((a!1 (and a1 (or (and a2 (not a3)) (and a3 (not a2))) a2 a3)))\n    (not a!1))\n  (let ((a!1 (and a4 (or (and a5 (not a6)) (and a6 (not a5))) a5 a6)))\n    (not a!1))\n  (let ((a!1 (not (or (and a2 (not a3)) (and a3 (not a2)))))\n        (a!2 (and (or (and a2 (not a3)) (and a3 (not a2))) (not a1)))\n        (a!3 (not (or (and a5 (not a6)) (and a6 (not a5)))))\n        (a!4 (and (or (and a5 (not a6)) (and a6 (not a5))) (not a4)))\n        (a!5 (and a1 (or (and a2 (not a3)) (and a3 (not a2))) (not (and a2 a3))))\n        (a!6 (and a1 (or (and a2 (not a3)) (and a3 (not a2))))))\n  (let ((a!7 (and (or (and a1 a!1) a!2)\n                  (or (and a4 a!3) a!4)\n                  (or a!5 (and a2 a3 (not a!6))))))\n    (not a!7)))\n  (let ((a!1 (not (or (and a2 (not a3)) (and a3 (not a2)))))\n        (a!2 (and (or (and a2 (not a3)) (and a3 (not a2))) (not a1)))\n        (a!3 (not (or (and a5 (not a6)) (and a6 (not a5)))))\n        (a!4 (and (or (and a5 (not a6)) (and a6 (not a5))) (not a4)))\n        (a!5 (and a4 (or (and a5 (not a6)) (and a6 (not a5))) (not (and a5 a6))))\n        (a!6 (and a4 (or (and a5 (not a6)) (and a6 (not a5))))))\n  (let ((a!7 (and (or (and a1 a!1) a!2)\n                  (or (and a4 a!3) a!4)\n                  (or a!5 (and a5 a6 (not a!6))))))\n    (not a!7)))\n  (let ((a!1 (and a1 (or (and a2 (not a3)) (and a3 (not a2))) (not (and a2 a3))))\n        (a!2 (and a1 (or (and a2 (not a3)) (and a3 (not a2)))))\n        (a!3 (and a4 (or (and a5 (not a6)) (and a6 (not a5))) (not (and a5 a6))))\n        (a!4 (and a4 (or (and a5 (not a6)) (and a6 (not a5))))))\n  (let ((a!5 (and (or a!1 (and a2 a3 (not a!2))) (or a!3 (and a5 a6 (not a!4))))))\n    (not a!5)))\n  (let ((a!1 (not (or (and a2 (not a3)) (and a3 (not a2)))))\n        (a!2 (and (or (and a2 (not a3)) (and a3 (not a2))) (not a1)))\n        (a!3 (not (or (and a5 (not a6)) (and a6 (not a5)))))\n        (a!4 (and (or (and a5 (not a6)) (and a6 (not a5))) (not a4)))\n        (a!5 (and a1 (or (and a2 (not a3)) (and a3 (not a2))) (not (and a2 a3))))\n        (a!6 (and a1 (or (and a2 (not a3)) (and a3 (not a2)))))\n        (a!8 (and a4 (or (and a5 (not a6)) (and a6 (not a5))) (not (and a5 a6))))\n        (a!9 (and a4 (or (and a5 (not a6)) (and a6 (not a5))))))\n  (let ((a!7 (not (or a!5 (and a2 a3 (not a!6)))))\n        (a!10 (not (or a!8 (and a5 a6 (not a!9)))))\n        (a!11 (not (and (or (and a1 a!1) a!2) (or (and a4 a!3) a!4))))\n        (a!14 (and (or (and a1 a!1) a!2)\n                   (or (and a4 a!3) a!4)\n                   (or a!5 (and a2 a3 (not a!6)))\n                   (or a!8 (and a5 a6 (not a!9)))))\n        (a!16 (and (or (and a1 a!1) a!2) (not (or (and a4 a!3) a!4))))\n        (a!17 (and (or (and a4 a!3) a!4) (not (or (and a1 a!1) a!2)))))\n  (let ((a!12 (and (or a!5 (and a2 a3 (not a!6))) a!11 a!10))\n        (a!13 (and (or a!8 (and a5 a6 (not a!9))) a!11 a!7)))\n  (let ((a!15 (or (and (or (and a1 a!1) a!2) (or (and a4 a!3) a!4) a!7 a!10)\n                  a!12\n                  a!13\n                  a!14)))\n    (not (and a!15 (or a!16 a!17)))))))\n  (or (not at-most-1!1) (not a1) (not a2))\n  (or (not at-most-1!1) (not a1) (not a3))\n  (or (not at-most-1!1) (not a1) (not a4))\n  (or (not at-most-1!1) (not a2) (not a3))\n  (or (not at-most-1!1) (not a2) (not a4))\n  (or (not at-most-1!1) (not a3) (not a4))\n  (or (not at-most-1!1) (not a5) (not a6))\n  (or (not at-most-1!1) (not (or a1 a2 a3 a4)) (not (or a5 a6)))\n  :precision precise :depth 1)\n)\n(goals\n(goal\n  ordered!2\n  (not dsort!10)\n  (or (not y!3) y!4)\n  (or (not y!4) y!5)\n  (or (not y!5) y!6)\n  (or (not y!6) y!7)\n  (or (not a1) y!3)\n  (or (not ordered!2) (not y!3) (not a2))\n  (or (not a2) y!4)\n  (or (not ordered!2) (not y!4) (not a3))\n  (or (not a3) y!5)\n  (or (not ordered!2) (not y!5) (not a4))\n  (or (not a4) y!6)\n  (or (not ordered!2) (not y!6) (not a5))\n  (or (not a5) y!7)\n  (or (not ordered!2) (not y!7) (not a6))\n  (or (not y!4) a2 y!3)\n  (or (not y!5) a3 y!4)\n  (or (not y!6) a4 y!5)\n  (or (not y!7) a5 y!6)\n  (or (not y!3) a1)\n  (or dsort!8 (not a1))\n  (or dsort!8 (not a2))\n  (or dsort!8 (not a3))\n  (or dsort!8 (not a4))\n  (or dsort!8 (not a5))\n  (or dsort!8 (not a6))\n  (or dsort!9 (not a1) (not a2))\n  (or dsort!9 (not a1) (not a3))\n  (or dsort!9 (not a1) (not a4))\n  (or dsort!9 (not a1) (not a5))\n  (or dsort!9 (not a1) (not a6))\n  (or dsort!9 (not a2) (not a3))\n  (or dsort!9 (not a2) (not a4))\n  (or dsort!9 (not a2) (not a5))\n  (or dsort!9 (not a2) (not a6))\n  (or dsort!9 (not a3) (not a4))\n  (or dsort!9 (not a3) (not a5))\n  (or dsort!9 (not a3) (not a6))\n  (or dsort!9 (not a4) (not a5))\n  (or dsort!9 (not a4) (not a6))\n  (or dsort!9 (not a5) (not a6))\n  (or dsort!10 (not a1) (not a2) (not a3))\n  (or dsort!10 (not a1) (not a2) (not a4))\n  (or dsort!10 (not a1) (not a2) (not a5))\n  (or dsort!10 (not a1) (not a2) (not a6))\n  (or dsort!10 (not a1) (not a3) (not a4))\n  (or dsort!10 (not a1) (not a3) (not a5))\n  (or dsort!10 (not a1) (not a3) (not a6))\n  (or dsort!10 (not a1) (not a4) (not a5))\n  (or dsort!10 (not a1) (not a4) (not a6))\n  (or dsort!10 (not a1) (not a5) (not a6))\n  (or dsort!10 (not a2) (not a3) (not a4))\n  (or dsort!10 (not a2) (not a3) (not a5))\n  (or dsort!10 (not a2) (not a3) (not a6))\n  (or dsort!10 (not a2) (not a4) (not a5))\n  (or dsort!10 (not a2) (not a4) (not a6))\n  (or dsort!10 (not a2) (not a5) (not a6))\n  (or dsort!10 (not a3) (not a4) (not a5))\n  (or dsort!10 (not a3) (not a4) (not a6))\n  (or dsort!10 (not a3) (not a5) (not a6))\n  (or dsort!10 (not a4) (not a5) (not a6))\n  :precision precise :depth 1)\n)\n(goals\n(goal\n  at-most-1!11\n  (not dsort!14)\n  (or (not at-most-1!11) (not a1) (not a2))\n  (or (not at-most-1!11) (not a1) (not a3))\n  (or (not at-most-1!11) (not a1) (not a4))\n  (or (not at-most-1!11) (not a2) (not a3))\n  (or (not at-most-1!11) (not a2) (not a4))\n  (or (not at-most-1!11) (not a3) (not a4))\n  (or (not at-most-1!11) (not a5) (not a6))\n  (or (not at-most-1!11) (not (or a1 a2 a3 a4)) (not (or a5 a6)))\n  (or dsort!12 (not a1))\n  (or dsort!12 (not a2))\n  (or dsort!12 (not a3))\n  (or dsort!12 (not a4))\n  (or dsort!12 (not a5))\n  (or dsort!12 (not a6))\n  (or dsort!13 (not a1) (not a2))\n  (or dsort!13 (not a1) (not a3))\n  (or dsort!13 (not a1) (not a4))\n  (or dsort!13 (not a1) (not a5))\n  (or dsort!13 (not a1) (not a6))\n  (or dsort!13 (not a2) (not a3))\n  (or dsort!13 (not a2) (not a4))\n  (or dsort!13 (not a2) (not a5))\n  (or dsort!13 (not a2) (not a6))\n  (or dsort!13 (not a3) (not a4))\n  (or dsort!13 (not a3) (not a5))\n  (or dsort!13 (not a3) (not a6))\n  (or dsort!13 (not a4) (not a5))\n  (or dsort!13 (not a4) (not a6))\n  (or dsort!13 (not a5) (not a6))\n  (or dsort!14 (not a1) (not a2) (not a3))\n  (or dsort!14 (not a1) (not a2) (not a4))\n  (or dsort!14 (not a1) (not a2) (not a5))\n  (or dsort!14 (not a1) (not a2) (not a6))\n  (or dsort!14 (not a1) (not a3) (not a4))\n  (or dsort!14 (not a1) (not a3) (not a5))\n  (or dsort!14 (not a1) (not a3) (not a6))\n  (or dsort!14 (not a1) (not a4) (not a5))\n  (or dsort!14 (not a1) (not a4) (not a6))\n  (or dsort!14 (not a1) (not a5) (not a6))\n  (or dsort!14 (not a2) (not a3) (not a4))\n  (or dsort!14 (not a2) (not a3) (not a5))\n  (or dsort!14 (not a2) (not a3) (not a6))\n  (or dsort!14 (not a2) (not a4) (not a5))\n  (or dsort!14 (not a2) (not a4) (not a6))\n  (or dsort!14 (not a2) (not a5) (not a6))\n  (or dsort!14 (not a3) (not a4) (not a5))\n  (or dsort!14 (not a3) (not a4) (not a6))\n  (or dsort!14 (not a3) (not a5) (not a6))\n  (or dsort!14 (not a4) (not a5) (not a6))\n  :precision precise :depth 1)\n)\n(goals\n(goal\n  bimander!15\n  (not dsort!20)\n  (or (not bimander!15) (not a1) (not a2))\n  (or (not bimander!15) (not a3) (not a4))\n  (or (not bimander!15) (not a5) (not a6))\n  (or (not bimander!15) (not (or a1 a2)) (not bit!16))\n  (or (not bimander!15) (not (or a1 a2)) (not bit!17))\n  (or (not bimander!15) (not (or a3 a4)) bit!16)\n  (or (not bimander!15) (not (or a3 a4)) (not bit!17))\n  (or (not bimander!15) (not (or a5 a6)) (not bit!16))\n  (or (not bimander!15) (not (or a5 a6)) bit!17)\n  (or dsort!18 (not a1))\n  (or dsort!18 (not a2))\n  (or dsort!18 (not a3))\n  (or dsort!18 (not a4))\n  (or dsort!18 (not a5))\n  (or dsort!18 (not a6))\n  (or dsort!19 (not a1) (not a2))\n  (or dsort!19 (not a1) (not a3))\n  (or dsort!19 (not a1) (not a4))\n  (or dsort!19 (not a1) (not a5))\n  (or dsort!19 (not a1) (not a6))\n  (or dsort!19 (not a2) (not a3))\n  (or dsort!19 (not a2) (not a4))\n  (or dsort!19 (not a2) (not a5))\n  (or dsort!19 (not a2) (not a6))\n  (or dsort!19 (not a3) (not a4))\n  (or dsort!19 (not a3) (not a5))\n  (or dsort!19 (not a3) (not a6))\n  (or dsort!19 (not a4) (not a5))\n  (or dsort!19 (not a4) (not a6))\n  (or dsort!19 (not a5) (not a6))\n  (or dsort!20 (not a1) (not a2) (not a3))\n  (or dsort!20 (not a1) (not a2) (not a4))\n  (or dsort!20 (not a1) (not a2) (not a5))\n  (or dsort!20 (not a1) (not a2) (not a6))\n  (or dsort!20 (not a1) (not a3) (not a4))\n  (or dsort!20 (not a1) (not a3) (not a5))\n  (or dsort!20 (not a1) (not a3) (not a6))\n  (or dsort!20 (not a1) (not a4) (not a5))\n  (or dsort!20 (not a1) (not a4) (not a6))\n  (or dsort!20 (not a1) (not a5) (not a6))\n  (or dsort!20 (not a2) (not a3) (not a4))\n  (or dsort!20 (not a2) (not a3) (not a5))\n  (or dsort!20 (not a2) (not a3) (not a6))\n  (or dsort!20 (not a2) (not a4) (not a5))\n  (or dsort!20 (not a2) (not a4) (not a6))\n  (or dsort!20 (not a2) (not a5) (not a6))\n  (or dsort!20 (not a3) (not a4) (not a5))\n  (or dsort!20 (not a3) (not a4) (not a6))\n  (or dsort!20 (not a3) (not a5) (not a6))\n  (or dsort!20 (not a4) (not a5) (not a6))\n  :precision precise :depth 1)\n)\n(goals\n(goal\n  (or a6\n      (and a1 a5)\n      (and a2 a5)\n      (and (or a4 a3) a5)\n      (and a3 a4)\n      (and a1 (or a4 a3))\n      (and a2 (or a4 a3))\n      (and a1 a2))\n  :precision precise :depth 1)\n)\n(goals\n(goal\n  (let ((a!1 (or (and dsort!21 (not dsort!22))\n                 (and dsort!23 (not dsort!24))\n                 (and (or a2 a5) (not (and a2 a5))))))\n  (let ((a!2 (and (or (and dsort!25 (not dsort!27)) dsort!28) a!1)))\n    (or a6 dsort!27 (and dsort!26 (not dsort!27)) a!2)))\n  (or (not a2) a2 a5)\n  (or (not a5) a2 a5)\n  (or (not a2) (not a5) (and a2 a5))\n  (or dsort!21 (not (and a2 a5)))\n  (or dsort!21 (not a1))\n  (or dsort!21 (not a2))\n  (or dsort!21 (not a5))\n  (or dsort!22 (not (and a2 a5)) (not a1))\n  (or dsort!22 (not (and a2 a5)) (not a2))\n  (or dsort!22 (not (and a2 a5)) (not a5))\n  (or dsort!22 (not a1) (not a2))\n  (or dsort!22 (not a1) (not a5))\n  (or dsort!22 (not a2) (not a5))\n  (or dsort!23 (not (and a2 a5)) (not a1) (not a2))\n  (or dsort!23 (not (and a2 a5)) (not a1) (not a5))\n  (or dsort!23 (not (and a2 a5)) (not a2) (not a5))\n  (or dsort!23 (not a1) (not a2) (not a5))\n  (or dsort!24 (not (and a2 a5)) (not a1) (not a2) (not a5))\n  (or dsort!25 (not dsort!22))\n  (or dsort!25 (not dsort!24))\n  (or dsort!25 (not a3))\n  (or dsort!25 (not a4))\n  (or dsort!26 (not dsort!22) (not dsort!24))\n  (or dsort!26 (not dsort!22) (not a3))\n  (or dsort!26 (not dsort!22) (not a4))\n  (or dsort!26 (not dsort!24) (not a3))\n  (or dsort!26 (not dsort!24) (not a4))\n  (or dsort!26 (not a3) (not a4))\n  (or dsort!27 (not dsort!22) (not dsort!24) (not a3))\n  (or dsort!27 (not dsort!22) (not dsort!24) (not a4))\n  (or dsort!27 (not dsort!22) (not a3) (not a4))\n  (or dsort!27 (not dsort!24) (not a3) (not a4))\n  (or dsort!28 (not dsort!22) (not dsort!24) (not a3) (not a4))\n  :precision precise :depth 1)\n)\n(goals\n(goal\n  (or a6 dsmerge!42)\n  (or dsort!29 (not a2))\n  (or dsort!29 (not a5))\n  (or dsort!29 false)\n  (or dsort!30 (not a2) (not a5))\n  (or dsort!30 (not a2) false)\n  (or dsort!30 (not a5) false)\n  (or dsort!31 (not a2) (not a5) false)\n  (or (not dsort!30) a2 a5)\n  (or (not dsort!31) a2)\n  (or (not dsort!31) a5)\n  (or dsort!32 (not a1))\n  (or dsort!32 (not a2))\n  (or dsort!32 (not a5))\n  (or dsort!32 false)\n  (or dsort!33 (not a1) (not a2))\n  (or dsort!33 (not a1) (not a5))\n  (or dsort!33 (not a1) false)\n  (or dsort!33 (not a2) (not a5))\n  (or dsort!33 (not a2) false)\n  (or dsort!33 (not a5) false)\n  (or dsort!34 (not a1) (not a2) (not a5))\n  (or dsort!34 (not a1) (not a2) false)\n  (or dsort!34 (not a1) (not a5) false)\n  (or dsort!34 (not a2) (not a5) false)\n  (or dsort!35 (not a1) (not a2) (not a5) false)\n  (or (not dsort!33) a1 a2 a5)\n  (or (not dsort!34) a1 a2)\n  (or (not dsort!34) a1 a5)\n  (or (not dsort!34) a2 a5)\n  (or (not dsort!35) a1)\n  (or (not dsort!35) a2)\n  (or (not dsort!35) a5)\n  (or (not dsort!32) dsmerge!36)\n  (or (not dsort!33) dsmerge!37)\n  (or (not dsort!34) dsmerge!38)\n  (or (not dsort!35) dsmerge!39)\n  (or (not dsort!30) dsmerge!36)\n  (or (not dsort!32) (not dsort!30) dsmerge!37)\n  (or (not dsort!33) (not dsort!30) dsmerge!38)\n  (or (not dsort!34) (not dsort!30) dsmerge!39)\n  (or (not dsort!35) (not dsort!30) dsmerge!40)\n  (or (not dsmerge!36) dsort!32 dsort!30)\n  (or (not dsmerge!37) dsort!32)\n  (or (not dsmerge!37) dsort!33 dsort!30)\n  (or (not dsmerge!38) dsort!33)\n  (or (not dsmerge!38) dsort!34 dsort!30)\n  (or (not dsmerge!39) dsort!34)\n  (or (not dsmerge!39) dsort!35 dsort!30)\n  (or (not dsmerge!40) dsort!30)\n  (or (not dsmerge!40) dsort!35)\n  (or (not (and a3 a4)) a3)\n  (or (not (and a3 a4)) a4)\n  (or (not (or a3 a4)) a3 a4)\n  (or (not (or a3 a4)) dsmerge!41)\n  (or (not (and a3 a4)) dsmerge!42)\n  (or (not dsmerge!37) dsmerge!41)\n  (or (not dsmerge!39) dsmerge!42)\n  (or (not (or a3 a4)) (not dsmerge!37) dsmerge!42)\n  (or (not (or a3 a4)) (not dsmerge!39) dsmerge!43)\n  (or (not (and a3 a4)) (not dsmerge!37) dsmerge!43)\n  (or (not (and a3 a4)) (not dsmerge!39) dsmerge!44)\n  (or (not dsmerge!41) a3 a4 dsmerge!37)\n  (or (not dsmerge!42) a3 a4 dsmerge!39)\n  (or (not dsmerge!42) (and a3 a4) dsmerge!37)\n  (or (not dsmerge!43) dsmerge!37)\n  (or (not dsmerge!43) a3 a4)\n  (or (not dsmerge!43) (and a3 a4) dsmerge!39)\n  (or (not dsmerge!44) dsmerge!39)\n  (or (not dsmerge!44) (and a3 a4))\n  :precision precise :depth 1)\n)\n(goals\n(goal\n  (let ((a!1 (bvadd ((_ zero_extend 1) (ite a1 #x0 #x2))\n                    ((_ zero_extend 1) (ite a2 #x0 #x3))))\n        (a!2 (bvadd ((_ zero_extend 1) (ite a3 #x0 #x4))\n                    ((_ zero_extend 1) (ite a4 #x0 #x4)))))\n  (let ((a!3 ((_ extract 4 4)\n               (bvadd ((_ zero_extend 1) ((_ extract 3 0) a!1))\n                      ((_ zero_extend 1) ((_ extract 3 0) a!2)))))\n        (a!4 ((_ extract 3 0)\n               (bvadd ((_ zero_extend 1) ((_ extract 3 0) a!1))\n                      ((_ zero_extend 1) ((_ extract 3 0) a!2))))))\n  (let ((a!5 ((_ extract 4 4)\n               (bvadd ((_ zero_extend 1) a!4)\n                      ((_ zero_extend 1) (ite a5 #x0 #x3)))))\n        (a!6 ((_ extract 3 0)\n               (bvadd ((_ zero_extend 1) a!4)\n                      ((_ zero_extend 1) (ite a5 #x0 #x3))))))\n    (or a6\n        (and (= ((_ extract 4 4) a!1) #b0)\n             (bvule ((_ extract 3 0) a!1) #xb)\n             (= ((_ extract 4 4) a!2) #b0)\n             (bvule ((_ extract 3 0) a!2) #xb)\n             (= a!3 #b0)\n             (bvule a!4 #xb)\n             (= a!5 #b0)\n             (bvule a!6 #xb))))))\n  :precision precise :depth 1)\n)\n(goals\n(goal\n  (or a6 ((_ pbge 5 2 3 4 4 3) a1 a2 a3 a4 a5))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"078d4f0ac105216161af86fd68afb163686390d1"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.11.0",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h3",{id:"notes-1"},"Notes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"supports cores"),(0,r.kt)("li",{parentName:"ul"},"does not support proofs")),(0,r.kt)("h3",{id:"parameters-1"},"Parameters"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cardinality.encoding"),(0,r.kt)("td",{parentName:"tr",align:null},"symbol"),(0,r.kt)("td",{parentName:"tr",align:null},"encoding used for cardinality constraints: grouped, bimander, ordered, unate, circuit"),(0,r.kt)("td",{parentName:"tr",align:null},"none")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"keep_cardinality_constraints"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"retain cardinality constraints for solver"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pb.solver"),(0,r.kt)("td",{parentName:"tr",align:null},"symbol"),(0,r.kt)("td",{parentName:"tr",align:null},"encoding used for Pseudo-Boolean constraints: totalizer, sorting, binary_merge, bv, solver. PB constraints are retained if set to 'solver'"),(0,r.kt)("td",{parentName:"tr",align:null},"solver")))),(0,r.kt)("h2",{id:"tactic-ctx-simplify"},"Tactic ctx-simplify"),(0,r.kt)("h3",{id:"short-description-2"},"Short Description:"),(0,r.kt)("p",null,"The tactic performs simplifies sub-formulas using context built up by walking assertions and sub-formulas."),(0,r.kt)("h3",{id:"example-2"},"Example"),(0,r.kt)(s(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"  (declare-const p Bool)\n  (declare-const q Bool)\n  (declare-const r Bool)\n  (declare-fun f (Bool) Bool)\n  (assert p)\n  (assert (or (f p) (and r (or (not r) q))))\n  (apply ctx-simplify)",result:{output:"(goals\n(goal\n  p\n  (or (f true) (and r q))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"d111cdda9974a0bbdf0802befd124e02dcfd5852"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.11.0",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h3",{id:"notes-2"},"Notes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"supports proof terms with limited features")),(0,r.kt)("h3",{id:"parameters-2"},"Parameters"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_depth"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"maximum term depth."),(0,r.kt)("td",{parentName:"tr",align:null},"1024")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum amount of memory in megabytes."),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_steps"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum number of steps."),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"propagate_eq"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"enable equality propagation from bounds."),(0,r.kt)("td",{parentName:"tr",align:null},"false")))),(0,r.kt)("h2",{id:"tactic-degree-shift"},"Tactic degree-shift"),(0,r.kt)("h3",{id:"short-description-3"},"Short Description"),(0,r.kt)("p",null,"The procedure reduces the degrees of variables."),(0,r.kt)("h3",{id:"long-description-1"},"Long Description"),(0,r.kt)("p",null,"Basic idea: if goal ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"G")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"G")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6833em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"G")))))," contains a real variable ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"x")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"x")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"))))),", ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"x")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"x")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"x")))))," occurs with degrees\n",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"d"),(0,r.kt)("mn",{parentName:"msub"},"1")),(0,r.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,r.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"."),(0,r.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"."),(0,r.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"."),(0,r.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"d"),(0,r.kt)("mi",{parentName:"msub"},"k"))),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"d_1, ..., d_k")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"d"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"1")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))),(0,r.kt)("span",{parentName:"span",className:"mpunct"},","),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},"..."),(0,r.kt)("span",{parentName:"span",className:"mpunct"},","),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"d"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3361em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight",style:{marginRight:"0.03148em"}},"k")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"}))))))))))," in ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"G")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"G")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6833em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"G"))))),", and ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mo",{parentName:"mrow"},"="),(0,r.kt)("mi",{parentName:"mrow"},"gcd"),(0,r.kt)("mo",{parentName:"mrow"},"\u2061"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"d"),(0,r.kt)("mn",{parentName:"msub"},"1")),(0,r.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,r.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"."),(0,r.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"."),(0,r.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"."),(0,r.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"d"),(0,r.kt)("mi",{parentName:"msub"},"k")),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,r.kt)("mo",{parentName:"mrow"},">"),(0,r.kt)("mn",{parentName:"mrow"},"1")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n = \\gcd(d_1, ..., d_k) > 1")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},"="),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mop"},(0,r.kt)("span",{parentName:"span",style:{marginRight:"0.01389em"}},"g"),"cd"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"d"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"1")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))),(0,r.kt)("span",{parentName:"span",className:"mpunct"},","),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},"..."),(0,r.kt)("span",{parentName:"span",className:"mpunct"},","),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"d"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3361em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight",style:{marginRight:"0.03148em"}},"k")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},">"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},"1"))))),".\nThen, replace ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("msup",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msup"},"x"),(0,r.kt)("mi",{parentName:"msup"},"n"))),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"x^n")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6644em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.6644em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"n"))))))))))))," with a new fresh variable ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"y")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"y")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"y"))))),"."),(0,r.kt)("h3",{id:"example-3"},"Example"),(0,r.kt)(s(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Real)\n(declare-const y Real)\n(assert (> (+ (* x x x 4) (* x x 3) 0)))\n(assert (= (* x x) (* y y)))\n(apply degree-shift)",result:{output:"(goals\n(goal\n  (= k!1 k!0)\n  (>= k!0 0.0)\n  (>= k!1 0.0)\n  :precision precise :depth 2)\n)\n",error:"",status:"z3-ran",hash:"a5a9f77f5cbf643966e0fc07af3c40b36bf02c22"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.11.0",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h3",{id:"notes-3"},"Notes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"supports proofs and cores")),(0,r.kt)("h3",{id:"parameters-3"},"Parameters"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"algebraic_number_evaluator"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"simplify/evaluate expressions containing (algebraic) irrational numbers."),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"arith_ineq_lhs"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"rewrite inequalities so that right-hand-side is a constant."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"arith_lhs"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"all monomials are moved to the left-hand-side, and the right-hand-side is just a constant."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bit2bool"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"try to convert bit-vector terms of size 1 into Boolean terms"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"blast_distinct"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"expand a distinct predicate into a quadratic number of disequalities"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"blast_distinct_threshold"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted"),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"blast_eq_value"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"blast (some) Bit-vector equalities into bits"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"blast_select_store"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"eagerly replace all (select (store ..) ..) term by an if-then-else term"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_extract_prop"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"attempt to partially propagate extraction inwards"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_ineq_consistency_test_max"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"max size of conjunctions on which to perform consistency test based on inequalities on bitvectors."),(0,r.kt)("td",{parentName:"tr",align:null},"0")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_ite2id"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"rewrite ite that can be simplified to identity"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_le2extract"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"disassemble bvule to extract"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_le_extra"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"additional bu_(u/s)le simplifications"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_not_simpl"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"apply simplifications for bvnot"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_sort_ac"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"sort the arguments of all AC operators"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cache_all"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"cache all intermediate results."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"elim_and"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"conjunctions are rewritten using negation and disjunctions"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"elim_ite"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"eliminate ite in favor of and/or"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"elim_rem"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"replace (rem x y) with (ite (",">","= y 0) (mod x y) (- (mod x y)))."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"elim_sign_ext"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"expand sign-ext operator using concat and extract"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"elim_to_real"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"eliminate to_real from arithmetic predicates that contain only integers."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"eq2ineq"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"expand equalities into two inequalities"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_nested_stores"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"replace nested stores by a lambda expression"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_power"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"expand (^ t k) into (* t ... t) if  1 ","<"," k ","<","= max_degree."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_select_ite"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"expand select over ite expressions"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_select_store"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"conservatively replace a (select (store ...) ...) term by an if-then-else term"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_store_eq"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"reduce (store ...) = (store ...) with a common base into selects"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_tan"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"replace (tan x) with (/ (sin x) (cos x))."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"flat"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"flat_and_or"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"create nary applications for and,or"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"gcd_rounding"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"use gcd rounding on integer arithmetic atoms."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hi_div0"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"use the 'hardware interpretation' for division by zero (for bit-vector terms)"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hoist_ite"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"hoist shared summands under ite expressions"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hoist_mul"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"hoist multiplication over summation to minimize number of multiplications"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ignore_patterns_on_ground_qbody"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"ignores patterns on quantifiers that don't mention their bound variables."),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ite_extra_rules"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"extra ite simplifications, these additional simplifications may reduce size locally but increase globally"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"local_ctx"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"perform local (i.e., cheap) context simplifications"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"local_ctx_limit"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"limit for applying local context simplifier"),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_degree"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"max degree of algebraic numbers (and power operators) processed by simplifier."),(0,r.kt)("td",{parentName:"tr",align:null},"64")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"maximum amount of memory in megabytes"),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_steps"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"maximum number of steps"),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"mul2concat"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"replace multiplication by a power of two into a concatenation"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"mul_to_power"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"collpase (* t ... t) into (^ t k), it is ignored if expand_power is true."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pull_cheap_ite"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"pull if-then-else terms when cheap."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"push_ite_arith"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"push if-then-else over arithmetic terms."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"push_ite_bv"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"push if-then-else over bit-vector terms."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"push_to_real"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"distribute to_real over * and +."),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rewrite_patterns"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"rewrite patterns."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"som"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"put polynomials in sum-of-monomials form"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"som_blowup"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form"),(0,r.kt)("td",{parentName:"tr",align:null},"10")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sort_store"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"sort nested stores when the indices are known to be different"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sort_sums"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"sort the arguments of + application."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"split_concat_eq"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"split equalities of the form (= (concat t1 t2) t3)"),(0,r.kt)("td",{parentName:"tr",align:null},"false")))),(0,r.kt)("h2",{id:"tactic-demodulator"},"Tactic demodulator"),(0,r.kt)("h3",{id:"short-description-4"},"Short Description:"),(0,r.kt)("p",null,"Extracts equalities from quantifiers and applies them for simplification"),(0,r.kt)("h3",{id:"long-description-2"},"Long Description"),(0,r.kt)("p",null,"In first-order theorem proving (FOTP), a demodulator is a universally quantified formula of the form:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Forall X1, ..., Xn.  L[X1, ..., Xn] = R[X1, ..., Xn]"),"\nWhere ",(0,r.kt)("inlineCode",{parentName:"p"},"L[X1, ..., Xn]")," contains all variables in ",(0,r.kt)("inlineCode",{parentName:"p"},"R[X1, ..., Xn]"),", and\n",(0,r.kt)("inlineCode",{parentName:"p"},"L[X1, ..., Xn]"),' is "bigger" than ',(0,r.kt)("inlineCode",{parentName:"p"},"R[X1, ...,Xn]"),"."),(0,r.kt)("p",null,"The idea is to replace something big ",(0,r.kt)("inlineCode",{parentName:"p"},"L[X1, ..., Xn]")," with something smaller ",(0,r.kt)("inlineCode",{parentName:"p"},"R[X1, ..., Xn]"),"."),(0,r.kt)("p",null,"After selecting the demodulators, we traverse the rest of the formula looking for instances of ",(0,r.kt)("inlineCode",{parentName:"p"},"L[X1, ..., Xn]"),".\nWhenever we find an instance, we replace it with the associated instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"R[X1, ..., Xn]"),"."),(0,r.kt)("p",null,"For example, suppose we have"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Forall x, y.  f(x+y, y) = y\nand\nf(g(b) + h(c), h(c)) <= 0\n")),(0,r.kt)("p",null,"The term ",(0,r.kt)("inlineCode",{parentName:"p"},"f(g(b) + h(c), h(c))")," is an instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"f(x+y, y)")," if we replace ",(0,r.kt)("inlineCode",{parentName:"p"},"x <- g(b)")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y <- h(c)"),".\nSo, we can replace it with ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," which is bound to ",(0,r.kt)("inlineCode",{parentName:"p"},"h(c)")," in this example. So, the result of the transformation is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Forall x, y.  f(x+y, y) = y\nand\nh(c) <= 0\n")),(0,r.kt)("h3",{id:"example-4"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"  (declare-sort S 0)\n  (declare-sort S1 0)\n  (declare-sort S2 0)\n  (declare-fun f () S)\n  (declare-fun f1 () S)\n  (declare-fun f2 (S1 S) S)\n  (declare-fun f3 (S2 S) S1)\n  (declare-fun f4 () S)\n  (declare-fun f5 () S2)\n  (assert (not (= f1 (f2 (f3 f5 f4) f))))\n  (assert (forall ((q S) (v S)) (or (= q v) (= f1 (f2 (f3 f5 q) v)) (= (f2 (f3 f5 v) q) f1))))\n  (assert (forall ((q S) (x S)) (not (= (f2 (f3 f5 q) x) f1))))\n  (apply demodulator)\n")),(0,r.kt)("p",null,"It generates"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"  (goals\n  (goal\n    (forall ((q S) (v S)) (= q v))\n    (forall ((q S) (x S)) (not (= (f2 (f3 f5 q) x) f1)))\n    :precision precise :depth 1)\n  )\n")),(0,r.kt)("h3",{id:"notes-4"},"Notes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"supports unsat cores"),(0,r.kt)("li",{parentName:"ul"},"does not support fine-grained proofs")),(0,r.kt)("h2",{id:"tactic-der"},"Tactic der"),(0,r.kt)("h3",{id:"short-description-5"},"Short Description:"),(0,r.kt)("p",null,"The tactic performs ",(0,r.kt)("em",{parentName:"p"},"destructive equality resolution"),"."),(0,r.kt)("h3",{id:"long-description-3"},"Long Description"),(0,r.kt)("p",null,"Destructive equality resolution replaces bound variables that are\n",(0,r.kt)("em",{parentName:"p"},"solved")," by their solutions in formulas. In short, the destructive\nequality resolution rule takes the form:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"   (forall (X Y) (or X /= s C[X])) --\x3e (forall (Y) C[Y])\n")),(0,r.kt)("h3",{id:"example-5"},"Example"),(0,r.kt)(s(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"  (declare-fun f (Int) Int)\n  (declare-fun p (Int Int) Bool)\n  (assert (forall ((x Int) (y Int)) (or (not (= x (f y))) (p x y))))\n  (apply der)",result:{output:"(goals\n(goal\n  (forall ((y Int)) (p (f y) y))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"b3742a5f7d61c0159ecc10c3e52bb4ea099fd8fd"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.11.0",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h3",{id:"notes-5"},"Notes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"supports unsat cores, proof terms")),(0,r.kt)("h2",{id:"tactic-diff-neq"},"Tactic diff-neq"),(0,r.kt)("h3",{id:"short-description-6"},"Short Description"),(0,r.kt)("p",null,"A specialized solver for integer problems using only constant bounds and differences to constants."),(0,r.kt)("h3",{id:"long-description-4"},"Long Description"),(0,r.kt)("p",null,"Solver for integer problems that contains literals of the form"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"       k <= x\n       x <= k\n       x - y != k\n")),(0,r.kt)("h3",{id:"example-6"},"Example"),(0,r.kt)(s(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Int)\n(declare-const y Int)\n(assert (<= 0 x))\n(assert (<= x 1))\n(assert (<= 0 y))\n(assert (<= y 1))\n(assert (not (= (+ x (* -1 y)) -1)))\n(assert (not (= (+ x (* -1 y)) 1)))\n(assert (not (= (+ x (* -1 y)) 0)))\n(apply diff-neq)",result:{output:"(goals\n(goal\n  false\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"85a4d5b1c742b8c68f25bf4982a556aecaa8a57c"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.11.0",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h3",{id:"notes-6"},"Notes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The tactic works only when the lower bounds are 0 and disequalities use multiplication with -1. Use normalize-bounds to ensure all lower bounds are 0.")),(0,r.kt)("h3",{id:"parameters-4"},"Parameters"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"diff_neq_max_k"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"maximum variable upper bound for diff neq solver."),(0,r.kt)("td",{parentName:"tr",align:null},"1024")))),(0,r.kt)("h2",{id:"tactic-distribute-forall"},"Tactic distribute-forall"),(0,r.kt)("h3",{id:"short-description-7"},"Short Description:"),(0,r.kt)("p",null,"Distribute ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2200")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\forall")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},"\u2200")))))," over conjunctions (and distribute ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2203")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\exists")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},"\u2203")))))," over disjunctions)"),(0,r.kt)("h3",{id:"example-7"},"Example"),(0,r.kt)(s(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"  (declare-const x Int)\n  (declare-fun p (Int) Bool)\n  (declare-fun q (Int) Bool)\n  (assert (forall ((x Int)) (and (p x) (q x))))\n  (apply distribute-forall)",result:{output:"(goals\n(goal\n  (forall ((x!1 Int)) (p x!1))\n  (forall ((x!1 Int)) (q x!1))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"d429d606b892a9eb719a70267d9c7c6200e5a6ed"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.11.0",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h3",{id:"notes-7"},"Notes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"supports unsat cores, proof terms")),(0,r.kt)("h2",{id:"tactic-elim-term-ite"},"Tactic elim-term-ite"),(0,r.kt)("h3",{id:"short-description-8"},"Short Description:"),(0,r.kt)("p",null,"Eliminate term if-then-else by adding\nnew fresh auxiliary variables."),(0,r.kt)("h3",{id:"example-8"},"Example"),(0,r.kt)(s(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-fun f (Int) Int)\n(declare-fun p (Int) Bool)\n(declare-const c1 Bool)\n(declare-const c2 Bool)\n(declare-const c3 Bool)\n(declare-const e1 Int) \n(declare-const e2 Int) \n(declare-const e3 Int)\n(declare-const e4 Int)\n(assert (p (f (if c1 (if c2 e1 (if c3 e2 e3)) e4))))\n(apply elim-term-ite) ",result:{output:"(goals\n(goal\n  (p (f k!2))\n  (or (not c3) (= k!0 e2))\n  (or c3 (= k!0 e3))\n  (or (not c2) (= k!1 e1))\n  (or c2 (= k!1 k!0))\n  (or (not c1) (= k!2 k!1))\n  (or c1 (= k!2 e4))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"468a61deeb793d175b7c57f6b354992fd00e8778"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.11.0",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h3",{id:"notes-8"},"Notes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"supports proof terms and unsat cores")),(0,r.kt)("h3",{id:"parameters-5"},"Parameters"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_args"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"(default: 128) maximum number of arguments (per application) that will be considered by the greedy (quadratic) heuristic."),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum amount of memory in megabytes."),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_steps"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum number of steps."),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")))),(0,r.kt)("h2",{id:"tactic-elim-uncnstr"},"Tactic elim-uncnstr"),(0,r.kt)("h3",{id:"short-description-9"},"Short Description"),(0,r.kt)("p",null,"Eliminate Unconstrained uninterpreted constants"),(0,r.kt)("h3",{id:"long-description-5"},"Long Description"),(0,r.kt)("p",null,"The tactic eliminates uninterpreted constants that occur only once in a goal and such that the immediate context\nwhere they occur can be replaced by a fresh constant. We call these occurrences invertible.\nIt relies on a series of theory specific invertibility transformations.\nIn the following assume ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"x'")," occur in a unique subterm and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," is a fresh uninterpreted constant."),(0,r.kt)("h4",{id:"boolean-connectives"},"Boolean Connectives"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Original Context"),(0,r.kt)("th",{parentName:"tr",align:null},"New Term"),(0,r.kt)("th",{parentName:"tr",align:null},"Updated solution"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(if c x x')")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"y")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x = x' = y"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(if x x' e)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"y")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x = true, x' = y"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(if x t x')")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"y")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x = false, x' = y"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(not x)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"y")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x = (not y)"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(and x x')")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"y")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x = y, x' = true"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(or  x x')")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"y")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x = y, x' = false"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(= x t)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"y")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x = (if y t (diff t))"))))),(0,r.kt)("p",null,"where diff is a diagnonalization function available in domains of size ",(0,r.kt)("inlineCode",{parentName:"p"},">")," 1."),(0,r.kt)("h4",{id:"arithmetic"},"Arithmetic"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Original Context"),(0,r.kt)("th",{parentName:"tr",align:null},"New Term"),(0,r.kt)("th",{parentName:"tr",align:null},"Updated solution"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(+ x t)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"y")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x = y - t"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(* x x')")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"y")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x = y, x' = 1"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(* -1 x)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"y")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x = -y"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(<= x t)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"y")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x = (if y t (+ t 1))"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(<= t x)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"y")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x = (if y t (- t 1))"))))),(0,r.kt)("h4",{id:"bit-vectors"},"Bit-vectors"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Original Context"),(0,r.kt)("th",{parentName:"tr",align:null},"New Term"),(0,r.kt)("th",{parentName:"tr",align:null},"Updated solution"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(bvadd x t)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"y")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x = y - t"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(bvmul x x')")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"y")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x = y, x' = 1"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(bvmul odd x)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"y")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x = inv(odd)*y"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"((extract sz-1 0) x)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"y")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x = y"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"((extract hi lo) x)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"y")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x = (concat y1 y y2)"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(udiv x x')")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"y")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x = y, x' = 1"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(concat x x')")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"y")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x = (extract hi1 lo1 y)"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(bvule x t)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(or y (= t MAX))")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x = (if y t (bvadd t 1))"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(bvule t x)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(or y (= t MIN))")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x = (if y t (bvsub t 1))"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(bvnot x)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"y")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x = (bvnot y)"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(bvand x x')")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"y")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x = y, x' = MAX"))))),(0,r.kt)("p",null,"In addition there are conversions for shift and bit-wise or and signed comparison."),(0,r.kt)("h4",{id:"arrays"},"Arrays"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Original Context"),(0,r.kt)("th",{parentName:"tr",align:null},"New Term"),(0,r.kt)("th",{parentName:"tr",align:null},"Updated solution"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(select x t)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"y")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x = (const y)"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(store x x1 x2)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"y")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x2 = (select x x1), x = y, x1 = arb"))))),(0,r.kt)("h4",{id:"algebraic-datatypes"},"Algebraic Datatypes"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Original Context"),(0,r.kt)("th",{parentName:"tr",align:null},"New Term"),(0,r.kt)("th",{parentName:"tr",align:null},"Updated solution"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(head x)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"y")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x = (cons y arb)"))))),(0,r.kt)("h3",{id:"example-9"},"Example"),(0,r.kt)(s(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Int)\n(declare-const y Int)\n(declare-fun p (Int) Bool)    \n(assert (>= (+ y (+ x y)) y))\n(assert (p y))\n(apply elim-uncnstr)\n(assert (p (+ x y)))\n(apply elim-uncnstr)",result:{output:"(goals\n(goal\n  k!2\n  (p y)\n  :precision precise :depth 1)\n)\n(goals\n(goal\n  (>= (+ y k!3) y)\n  (p y)\n  (p k!3)\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"da308012d49419493d7a21bc91da035f425d2f72"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.11.0",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h3",{id:"notes-9"},"Notes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"supports unsat cores"),(0,r.kt)("li",{parentName:"ul"},"does not support fine-grained proofs")),(0,r.kt)("h3",{id:"parameters-6"},"Parameters"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum amount of memory in megabytes."),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_steps"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum number of steps."),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")))),(0,r.kt)("h2",{id:"tactic-eq2bv"},"Tactic eq2bv"),(0,r.kt)("h3",{id:"short-description-10"},"Short Description"),(0,r.kt)("p",null,"Extract integer variables that are used as finite domain indicators.\nThe integer variables can only occur in equalities."),(0,r.kt)("h3",{id:"example-10"},"Example"),(0,r.kt)(s(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Int)\n(declare-const y Int)\n(assert (or (= x 5) (> y 3)))\n(assert (or (= x 4) (= y 2)))\n(apply eq2bv)",result:{output:"(goals\n(goal\n  (or (= z!0 #b101) (> y 3))\n  (or (= z!0 #b100) (= y 2))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"85d9589d0892e32704357ca93ef865e052deee5b"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.11.0",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h3",{id:"notes-10"},"Notes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"does not support proofs")),(0,r.kt)("h2",{id:"tactic-factor"},"Tactic factor"),(0,r.kt)("h3",{id:"short-description-11"},"Short Description"),(0,r.kt)("p",null,"Factor polynomials in equalities and inequalities."),(0,r.kt)("h3",{id:"example-11"},"Example"),(0,r.kt)(s(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Real)\n(declare-const y Real)\n(assert (> (* x x) (* x y)))\n(apply factor)",result:{output:"(goals\n(goal\n  (> (* x (+ (* (- 1.0) y) x)) 0.0)\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"f01efc6ecf67cb47c42c1c5b375db12aeea97e3f"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.11.0",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h3",{id:"parameters-7"},"Parameters"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_prime"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"(default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step."),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_search_size"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"(default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space."),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"num_primes"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"(default: 1) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching."),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"split_factors"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"apply simplifications such as (= (* p1 p2) 0) --",">"," (or (= p1 0) (= p2 0))."),(0,r.kt)("td",{parentName:"tr",align:null},"true")))),(0,r.kt)("h2",{id:"tactic-fix-dl-var"},"Tactic fix-dl-var"),(0,r.kt)("h3",{id:"short-description-12"},"Short Description"),(0,r.kt)("p",null,"Fix a difference logic variable to ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),".\nIf the problem is in the difference logic fragment, that is, all arithmetic terms\nare of the form ",(0,r.kt)("inlineCode",{parentName:"p"},"(x + k)"),", and the arithmetic atoms are of the\nform ",(0,r.kt)("inlineCode",{parentName:"p"},"x - y <= k")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"x - y = k"),". Then, we can set one variable to ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),"."),(0,r.kt)("p",null,"This is useful because, many bounds can be exposed after this operation is performed."),(0,r.kt)("h3",{id:"example-12"},"Example"),(0,r.kt)(s(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Real)\n(declare-const y Real)\n(declare-const z Real)\n(assert (<= (+ x (* -1.0 y)) 3.0))\n(assert (<= (+ x (* -1.0 z)) 5.0))\n(apply fix-dl-var)",result:{output:"(goals\n(goal\n  (>= y (- 3.0))\n  (>= z (- 5.0))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"92c9a94468dfb4ccfecf90e1d9af2fe2fad28109"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.11.0",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h3",{id:"parameters-8"},"Parameters"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"algebraic_number_evaluator"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"simplify/evaluate expressions containing (algebraic) irrational numbers."),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"arith_ineq_lhs"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"rewrite inequalities so that right-hand-side is a constant."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"arith_lhs"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"all monomials are moved to the left-hand-side, and the right-hand-side is just a constant."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bit2bool"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"try to convert bit-vector terms of size 1 into Boolean terms"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"blast_distinct"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"expand a distinct predicate into a quadratic number of disequalities"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"blast_distinct_threshold"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted"),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"blast_eq_value"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"blast (some) Bit-vector equalities into bits"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"blast_select_store"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"eagerly replace all (select (store ..) ..) term by an if-then-else term"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_extract_prop"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"attempt to partially propagate extraction inwards"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_ineq_consistency_test_max"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"max size of conjunctions on which to perform consistency test based on inequalities on bitvectors."),(0,r.kt)("td",{parentName:"tr",align:null},"0")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_ite2id"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"rewrite ite that can be simplified to identity"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_le2extract"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"disassemble bvule to extract"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_le_extra"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"additional bu_(u/s)le simplifications"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_not_simpl"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"apply simplifications for bvnot"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_sort_ac"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"sort the arguments of all AC operators"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cache_all"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"cache all intermediate results."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"elim_and"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"conjunctions are rewritten using negation and disjunctions"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"elim_ite"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"eliminate ite in favor of and/or"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"elim_rem"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"replace (rem x y) with (ite (",">","= y 0) (mod x y) (- (mod x y)))."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"elim_sign_ext"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"expand sign-ext operator using concat and extract"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"elim_to_real"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"eliminate to_real from arithmetic predicates that contain only integers."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"eq2ineq"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"expand equalities into two inequalities"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_nested_stores"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"replace nested stores by a lambda expression"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_power"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"expand (^ t k) into (* t ... t) if  1 ","<"," k ","<","= max_degree."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_select_ite"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"expand select over ite expressions"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_select_store"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"conservatively replace a (select (store ...) ...) term by an if-then-else term"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_store_eq"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"reduce (store ...) = (store ...) with a common base into selects"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_tan"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"replace (tan x) with (/ (sin x) (cos x))."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"flat"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"flat_and_or"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"create nary applications for and,or"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"gcd_rounding"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"use gcd rounding on integer arithmetic atoms."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hi_div0"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"use the 'hardware interpretation' for division by zero (for bit-vector terms)"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hoist_ite"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"hoist shared summands under ite expressions"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hoist_mul"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"hoist multiplication over summation to minimize number of multiplications"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ignore_patterns_on_ground_qbody"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"ignores patterns on quantifiers that don't mention their bound variables."),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ite_extra_rules"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"extra ite simplifications, these additional simplifications may reduce size locally but increase globally"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"local_ctx"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"perform local (i.e., cheap) context simplifications"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"local_ctx_limit"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"limit for applying local context simplifier"),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_degree"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"max degree of algebraic numbers (and power operators) processed by simplifier."),(0,r.kt)("td",{parentName:"tr",align:null},"64")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"maximum amount of memory in megabytes"),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_steps"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"maximum number of steps"),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"mul2concat"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"replace multiplication by a power of two into a concatenation"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"mul_to_power"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"collpase (* t ... t) into (^ t k), it is ignored if expand_power is true."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pull_cheap_ite"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"pull if-then-else terms when cheap."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"push_ite_arith"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"push if-then-else over arithmetic terms."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"push_ite_bv"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"push if-then-else over bit-vector terms."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"push_to_real"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"distribute to_real over * and +."),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rewrite_patterns"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"rewrite patterns."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"som"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"put polynomials in sum-of-monomials form"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"som_blowup"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form"),(0,r.kt)("td",{parentName:"tr",align:null},"10")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sort_store"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"sort nested stores when the indices are known to be different"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sort_sums"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"sort the arguments of + application."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"split_concat_eq"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"split equalities of the form (= (concat t1 t2) t3)"),(0,r.kt)("td",{parentName:"tr",align:null},"false")))),(0,r.kt)("h2",{id:"tactic-fm"},"Tactic fm"),(0,r.kt)("h3",{id:"short-description-13"},"Short Description"),(0,r.kt)("p",null,"Use Fourier-Motzkin to eliminate variables.\nThis strategy can handle conditional bounds\n(i.e., clauses with at most one constraint)."),(0,r.kt)("p",null,"The strategy mk_occf can be used to put the\nformula in OCC form."),(0,r.kt)("h3",{id:"example-13"},"Example"),(0,r.kt)(s(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Real)\n(declare-const y Real)\n(declare-const z Real)\n(declare-const u Real)\n(declare-const v Real)\n(declare-const w Real)\n(declare-fun P (Real) Bool)\n(assert (<= x (+ y (* 2.0 z))))\n(assert (>= x (- y z)))\n(assert (>= x (- y 3 (* 3 z))))\n(assert (>= x 5))\n(assert (<= x u))\n(assert (>= x v))\n(assert (P u))\n(assert (P v))\n(apply fm)",result:{output:"(goals\n(goal\n  (P u)\n  (P v)\n  (<= (* (- 1.0) u) (- 5.0))\n  (<= (+ v (* (- 1.0) u)) 0.0)\n  :precision precise :depth 2)\n)\n",error:"",status:"z3-ran",hash:"8278852c4e0e62c2f464c5fb5c39279608c0d7e9"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.11.0",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h3",{id:"parameters-9"},"Parameters"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"algebraic_number_evaluator"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"simplify/evaluate expressions containing (algebraic) irrational numbers."),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"arith_ineq_lhs"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"rewrite inequalities so that right-hand-side is a constant."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"arith_lhs"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"all monomials are moved to the left-hand-side, and the right-hand-side is just a constant."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bit2bool"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"try to convert bit-vector terms of size 1 into Boolean terms"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"blast_distinct"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"expand a distinct predicate into a quadratic number of disequalities"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"blast_distinct_threshold"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted"),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"blast_eq_value"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"blast (some) Bit-vector equalities into bits"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"blast_select_store"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"eagerly replace all (select (store ..) ..) term by an if-then-else term"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_extract_prop"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"attempt to partially propagate extraction inwards"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_ineq_consistency_test_max"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"max size of conjunctions on which to perform consistency test based on inequalities on bitvectors."),(0,r.kt)("td",{parentName:"tr",align:null},"0")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_ite2id"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"rewrite ite that can be simplified to identity"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_le2extract"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"disassemble bvule to extract"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_le_extra"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"additional bu_(u/s)le simplifications"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_not_simpl"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"apply simplifications for bvnot"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_sort_ac"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"sort the arguments of all AC operators"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cache_all"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"cache all intermediate results."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"elim_and"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"conjunctions are rewritten using negation and disjunctions"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"elim_ite"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"eliminate ite in favor of and/or"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"elim_rem"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"replace (rem x y) with (ite (",">","= y 0) (mod x y) (- (mod x y)))."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"elim_sign_ext"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"expand sign-ext operator using concat and extract"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"elim_to_real"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"eliminate to_real from arithmetic predicates that contain only integers."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"eq2ineq"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"expand equalities into two inequalities"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_nested_stores"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"replace nested stores by a lambda expression"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_power"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"expand (^ t k) into (* t ... t) if  1 ","<"," k ","<","= max_degree."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_select_ite"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"expand select over ite expressions"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_select_store"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"conservatively replace a (select (store ...) ...) term by an if-then-else term"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_store_eq"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"reduce (store ...) = (store ...) with a common base into selects"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_tan"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"replace (tan x) with (/ (sin x) (cos x))."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"flat"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"flat_and_or"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"create nary applications for and,or"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"fm_cutoff1"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"first cutoff for FM based on maximum number of lower/upper occurrences."),(0,r.kt)("td",{parentName:"tr",align:null},"8")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"fm_cutoff2"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"second cutoff for FM based on num_lower * num_upper occurrences."),(0,r.kt)("td",{parentName:"tr",align:null},"256")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"fm_extra"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"max. increase on the number of inequalities for each FM variable elimination step."),(0,r.kt)("td",{parentName:"tr",align:null},"0")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"fm_limit"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"maximum number of constraints, monomials, clauses visited during FM."),(0,r.kt)("td",{parentName:"tr",align:null},"5000000")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"fm_occ"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"consider inequalities occurring in clauses for FM."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"fm_real_only"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"consider only real variables for fourier-motzkin elimination."),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"gcd_rounding"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"use gcd rounding on integer arithmetic atoms."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hi_div0"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"use the 'hardware interpretation' for division by zero (for bit-vector terms)"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hoist_ite"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"hoist shared summands under ite expressions"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hoist_mul"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"hoist multiplication over summation to minimize number of multiplications"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ignore_patterns_on_ground_qbody"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"ignores patterns on quantifiers that don't mention their bound variables."),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ite_extra_rules"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"extra ite simplifications, these additional simplifications may reduce size locally but increase globally"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"local_ctx"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"perform local (i.e., cheap) context simplifications"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"local_ctx_limit"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"limit for applying local context simplifier"),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_degree"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"max degree of algebraic numbers (and power operators) processed by simplifier."),(0,r.kt)("td",{parentName:"tr",align:null},"64")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"maximum amount of memory in megabytes"),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_steps"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"maximum number of steps"),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"mul2concat"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"replace multiplication by a power of two into a concatenation"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"mul_to_power"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"collpase (* t ... t) into (^ t k), it is ignored if expand_power is true."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"produce_models"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"model generation."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pull_cheap_ite"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"pull if-then-else terms when cheap."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"push_ite_arith"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"push if-then-else over arithmetic terms."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"push_ite_bv"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"push if-then-else over bit-vector terms."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"push_to_real"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"distribute to_real over * and +."),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rewrite_patterns"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"rewrite patterns."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"som"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"put polynomials in sum-of-monomials form"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"som_blowup"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form"),(0,r.kt)("td",{parentName:"tr",align:null},"10")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sort_store"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"sort nested stores when the indices are known to be different"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sort_sums"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"sort the arguments of + application."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"split_concat_eq"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"split equalities of the form (= (concat t1 t2) t3)"),(0,r.kt)("td",{parentName:"tr",align:null},"false")))),(0,r.kt)("h2",{id:"tactic-injectivity"},"Tactic injectivity"),(0,r.kt)("h3",{id:"short-description-14"},"Short Description:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Discover axioms of the form ",(0,r.kt)("inlineCode",{parentName:"p"},"forall x. (= (g (f x)) x"),"\nMark ",(0,r.kt)("inlineCode",{parentName:"p"},"f")," as injective")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Rewrite (sub)terms of the form ",(0,r.kt)("inlineCode",{parentName:"p"},"(= (f x) (f y))")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"(= x y)")," whenever ",(0,r.kt)("inlineCode",{parentName:"p"},"f")," is injective."))),(0,r.kt)("h3",{id:"example-14"},"Example"),(0,r.kt)(s(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"  (declare-fun f (Int) Int)\n  (declare-fun g (Int) Int)\n  (declare-const x Int)\n  (declare-const y Int)\n  (assert (forall ((x Int)) (= (g (f x)) x)))\n  (assert (not (= (f x) (f (f y)))))\n  (apply injectivity)",result:{output:"(goals\n(goal\n  (forall ((x!1 Int)) (= (g (f x!1)) x!1))\n  (not (= x (f y)))\n  :precision precise :depth 0)\n)\n",error:"",status:"z3-ran",hash:"872c89ddfba3a1641551c6cf8779dd0592f1b8dc"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.11.0",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h3",{id:"notes-11"},"Notes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"does not support cores nor proofs")),(0,r.kt)("h3",{id:"parameters-10"},"Parameters"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum amount of memory in megabytes."),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"produce_models"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"model generation."),(0,r.kt)("td",{parentName:"tr",align:null},"false")))),(0,r.kt)("h2",{id:"tactic-nnf"},"Tactic nnf"),(0,r.kt)("h3",{id:"short-description-15"},"Short Description:"),(0,r.kt)("p",null,"The tactic converts formulas to negation normal form (NNF)"),(0,r.kt)("h3",{id:"long-description-6"},"Long Description"),(0,r.kt)("p",null,"In NNF, negations only appear in front of atomic formulas. "),(0,r.kt)("p",null,"Standard rules for conversion into negation normal form are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"(not (and p q))")," is converted to ",(0,r.kt)("inlineCode",{parentName:"li"},"(or (not p) (not q))")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"(not (or p q))")," is converted to ",(0,r.kt)("inlineCode",{parentName:"li"},"(and (not p) (not q))")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"(not (not p))")," is converted to ",(0,r.kt)("inlineCode",{parentName:"li"},"p")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"(not (exists x. p))")," is converted to ",(0,r.kt)("inlineCode",{parentName:"li"},"(forall x. (not p))")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"(not (forall x. p))")," is converted to ",(0,r.kt)("inlineCode",{parentName:"li"},"(exists x. (not p))"))),(0,r.kt)("p",null,"Once all negations are pushed inside, the resulting formula is in NNF."),(0,r.kt)("h3",{id:"example-15"},"Example"),(0,r.kt)(s(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"  (declare-const x Int)\n  (assert (not (or (> x 0) (< x 0))))\n  (apply nnf)",result:{output:"(goals\n(goal\n  (not (> x 0))\n  (not (< x 0))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"8f60953ba76220b9661dec9f7bc6915240a05c51"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.11.0",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h3",{id:"notes-12"},"Notes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"supports unsat cores, proof terms")),(0,r.kt)("h3",{id:"parameters-11"},"Parameters"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ignore_labels"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"remove/ignore labels in the input formula, this option is ignored if proofs are enabled"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"maximum amount of memory in megabytes"),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"mode"),(0,r.kt)("td",{parentName:"tr",align:null},"symbol"),(0,r.kt)("td",{parentName:"tr",align:null},"NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full"),(0,r.kt)("td",{parentName:"tr",align:null},"skolem")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sk_hack"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"hack for VCC"),(0,r.kt)("td",{parentName:"tr",align:null},"false")))),(0,r.kt)("h2",{id:"tactic-propagate-values"},"Tactic propagate-values"),(0,r.kt)("h3",{id:"short-description-16"},"Short Description:"),(0,r.kt)("p",null,"Tactic for propagating equalities ",(0,r.kt)("inlineCode",{parentName:"p"},"(= t v)")," where ",(0,r.kt)("inlineCode",{parentName:"p"},"v")," is a value"),(0,r.kt)("h3",{id:"long-description-7"},"Long Description"),(0,r.kt)("p",null,"In a context where terms are equated to constants it is invariably beneficial to\nreplace terms, that can be compound, with the constants and then simplify the resulting formulas.\nThe propagate-values tactic accomplishes the task of replacing such terms."),(0,r.kt)("h3",{id:"example-16"},"Example"),(0,r.kt)(s(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Int)\n(declare-const y Int)\n(declare-fun f (Int) Int)\n(assert (= 1 (f (+ x y))))\n(assert (= 2 x))\n(assert (> (f (+ 2 y)) y))\n(apply propagate-values)",result:{output:"(goals\n(goal\n  (= 1 (f (+ 2 y)))\n  (= 2 x)\n  (not (<= 1 y))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"a5f5914280908c04bd6beea1009f56b9f9a9c8df"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.11.0",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h3",{id:"notes-13"},"Notes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"supports unsat cores")),(0,r.kt)("h3",{id:"parameters-12"},"Parameters"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"algebraic_number_evaluator"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"simplify/evaluate expressions containing (algebraic) irrational numbers."),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"arith_ineq_lhs"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"rewrite inequalities so that right-hand-side is a constant."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"arith_lhs"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"all monomials are moved to the left-hand-side, and the right-hand-side is just a constant."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bit2bool"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"try to convert bit-vector terms of size 1 into Boolean terms"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"blast_distinct"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"expand a distinct predicate into a quadratic number of disequalities"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"blast_distinct_threshold"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted"),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"blast_eq_value"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"blast (some) Bit-vector equalities into bits"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"blast_select_store"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"eagerly replace all (select (store ..) ..) term by an if-then-else term"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_extract_prop"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"attempt to partially propagate extraction inwards"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_ineq_consistency_test_max"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"max size of conjunctions on which to perform consistency test based on inequalities on bitvectors."),(0,r.kt)("td",{parentName:"tr",align:null},"0")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_ite2id"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"rewrite ite that can be simplified to identity"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_le2extract"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"disassemble bvule to extract"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_le_extra"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"additional bu_(u/s)le simplifications"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_not_simpl"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"apply simplifications for bvnot"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_sort_ac"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"sort the arguments of all AC operators"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cache_all"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"cache all intermediate results."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"elim_and"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"conjunctions are rewritten using negation and disjunctions"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"elim_ite"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"eliminate ite in favor of and/or"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"elim_rem"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"replace (rem x y) with (ite (",">","= y 0) (mod x y) (- (mod x y)))."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"elim_sign_ext"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"expand sign-ext operator using concat and extract"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"elim_to_real"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"eliminate to_real from arithmetic predicates that contain only integers."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"eq2ineq"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"expand equalities into two inequalities"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_nested_stores"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"replace nested stores by a lambda expression"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_power"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"expand (^ t k) into (* t ... t) if  1 ","<"," k ","<","= max_degree."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_select_ite"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"expand select over ite expressions"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_select_store"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"conservatively replace a (select (store ...) ...) term by an if-then-else term"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_store_eq"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"reduce (store ...) = (store ...) with a common base into selects"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_tan"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"replace (tan x) with (/ (sin x) (cos x))."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"flat"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"flat_and_or"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"create nary applications for and,or"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"gcd_rounding"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"use gcd rounding on integer arithmetic atoms."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hi_div0"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"use the 'hardware interpretation' for division by zero (for bit-vector terms)"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hoist_ite"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"hoist shared summands under ite expressions"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hoist_mul"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"hoist multiplication over summation to minimize number of multiplications"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ignore_patterns_on_ground_qbody"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"ignores patterns on quantifiers that don't mention their bound variables."),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ite_extra_rules"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"extra ite simplifications, these additional simplifications may reduce size locally but increase globally"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"local_ctx"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"perform local (i.e., cheap) context simplifications"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"local_ctx_limit"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"limit for applying local context simplifier"),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_degree"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"max degree of algebraic numbers (and power operators) processed by simplifier."),(0,r.kt)("td",{parentName:"tr",align:null},"64")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"maximum amount of memory in megabytes"),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_rounds"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"maximum number of rounds."),(0,r.kt)("td",{parentName:"tr",align:null},"4")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_steps"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"maximum number of steps"),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"mul2concat"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"replace multiplication by a power of two into a concatenation"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"mul_to_power"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"collpase (* t ... t) into (^ t k), it is ignored if expand_power is true."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pull_cheap_ite"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"pull if-then-else terms when cheap."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"push_ite_arith"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"push if-then-else over arithmetic terms."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"push_ite_bv"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"push if-then-else over bit-vector terms."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"push_to_real"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"distribute to_real over * and +."),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rewrite_patterns"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"rewrite patterns."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"som"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"put polynomials in sum-of-monomials form"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"som_blowup"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form"),(0,r.kt)("td",{parentName:"tr",align:null},"10")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sort_store"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"sort nested stores when the indices are known to be different"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sort_sums"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"sort the arguments of + application."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"split_concat_eq"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"split equalities of the form (= (concat t1 t2) t3)"),(0,r.kt)("td",{parentName:"tr",align:null},"false")))),(0,r.kt)("h2",{id:"tactic-reduce-args"},"Tactic reduce-args"),(0,r.kt)("h3",{id:"short-description-17"},"Short Description:"),(0,r.kt)("p",null,"Reduce the number of arguments of function applications, when for all occurrences of a function f the i-th is a value."),(0,r.kt)("h3",{id:"long-description-8"},"Long Description"),(0,r.kt)("p",null,"Example, suppose we have a function ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"f")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"f")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"f")))))," with 2 arguments.\nThere are 1000 applications of this function, but the first argument is always ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"a")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"a")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"a"))))),", ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"b")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"b")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"b")))))," or ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"c")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"c")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"c"))))),".\nThus, we replace the ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"f"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"t"),(0,r.kt)("mn",{parentName:"msub"},"1")),(0,r.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"t"),(0,r.kt)("mn",{parentName:"msub"},"2")),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"f(t_1, t_2)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"f"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"1")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))),(0,r.kt)("span",{parentName:"span",className:"mpunct"},","),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"2")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))),(0,r.kt)("span",{parentName:"span",className:"mclose"},")")))))," with "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("span",{parentName:"li",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"f"),(0,r.kt)("mi",{parentName:"msub"},"a")),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"t"),(0,r.kt)("mn",{parentName:"msub"},"2")),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"f_a(t_2)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"f"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.1514em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"-0.1076em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"a")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"2")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"))))),"   if   ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"t"),(0,r.kt)("mn",{parentName:"msub"},"1")),(0,r.kt)("mo",{parentName:"mrow"},"="),(0,r.kt)("mi",{parentName:"mrow"},"a")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"t_1 = a")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.7651em",verticalAlign:"-0.15em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"1")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},"="),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"a")))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("span",{parentName:"li",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"f"),(0,r.kt)("mi",{parentName:"msub"},"b")),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"t"),(0,r.kt)("mn",{parentName:"msub"},"2")),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"f_b(t_2)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"f"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3361em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"-0.1076em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"b")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"2")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"))))),"   if   ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"t"),(0,r.kt)("mn",{parentName:"msub"},"2")),(0,r.kt)("mo",{parentName:"mrow"},"="),(0,r.kt)("mi",{parentName:"mrow"},"b")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"t_2 = b")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.7651em",verticalAlign:"-0.15em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"2")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},"="),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"b")))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("span",{parentName:"li",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"f"),(0,r.kt)("mi",{parentName:"msub"},"c")),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"t"),(0,r.kt)("mn",{parentName:"msub"},"2")),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"f_c(t_2)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"f"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.1514em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"-0.1076em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"c")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"2")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"))))),"   if   ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"t"),(0,r.kt)("mn",{parentName:"msub"},"2")),(0,r.kt)("mo",{parentName:"mrow"},"="),(0,r.kt)("mi",{parentName:"mrow"},"c")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"t_2 = c")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.7651em",verticalAlign:"-0.15em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"2")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},"="),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"c"))))))),(0,r.kt)("p",null,"Since ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"f"),(0,r.kt)("mi",{parentName:"msub"},"a"))),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"f_a")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"f"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.1514em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"-0.1076em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"a")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))))))),", ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"f"),(0,r.kt)("mi",{parentName:"msub"},"b"))),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"f_b")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"f"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3361em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"-0.1076em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"b")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))))))),", ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"f"),(0,r.kt)("mi",{parentName:"msub"},"c"))),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"f_c")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"f"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.1514em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"-0.1076em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"c")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"}))))))))))," are new symbols, satisfiability is preserved."),(0,r.kt)("p",null,"This transformation is very similar in spirit to the Ackermman's reduction. "),(0,r.kt)("p",null,"This transformation should work in the following way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"   1- Create a mapping decl2arg_map from declarations to tuples of booleans, an entry [f -> (true, false, true)]\n       means that f is a declaration with 3 arguments where the first and third arguments are always values.\n   2- Traverse the formula and populate the mapping. \n        For each function application f(t1, ..., tn) do\n          a) Create a boolean tuple (is_value(t1), ..., is_value(tn)) and do\n             the logical-and with the tuple that is already in the mapping. If there is no such tuple\n             in the mapping, we just add a new entry.\n\n   If all entries are false-tuples, then there is nothing to be done. The transformation is not applicable.\n\n   Now, we create a mapping decl2new_decl from (decl, val_1, ..., val_n) to decls. Note that, n may be different for each entry,\n   but it is the same for the same declaration.\n   For example, suppose we have [f -> (true, false, true)] in decl2arg_map, \n  and applications f(1, a, 2), f(1, b, 2), f(1, b, 3), f(2, b, 3), f(2, c, 3) in the formula.\n   Then, decl2arg_map would contain\n        (f, 1, 2) -> f_1_2\n        (f, 1, 3) -> f_1_3\n        (f, 2, 3) -> f_2_3\n   where f_1_2, f_1_3 and f_2_3 are new function symbols.\n   Using the new map, we can replace the occurrences of f.\n")),(0,r.kt)("h3",{id:"example-17"},"Example"),(0,r.kt)(s(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-fun f (Int Int) Bool)\n(declare-const x Int)\n(assert (f 1 2))\n(assert (f 1 3))\n(assert (f 2 4))\n(assert (f 2 5))\n(assert (f 1 6))\n(assert (f 1 7))\n(assert (f 1 x))\n(apply reduce-args)",result:{output:"(goals\n(goal\n  (f!0 2)\n  (f!0 3)\n  (f!1 4)\n  (f!1 5)\n  (f!0 6)\n  (f!0 7)\n  (f!0 x)\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"b56f1256934e7815495f251826a4dbdda6889881"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.11.0",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h3",{id:"notes-14"},"Notes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"supports unsat cores"),(0,r.kt)("li",{parentName:"ul"},"does not support proof terms")),(0,r.kt)("h2",{id:"tactic-simplify"},"Tactic simplify"),(0,r.kt)("h3",{id:"short-description-18"},"Short Description:"),(0,r.kt)("p",null,"The tactic performs algebraic simplifcations on formulas"),(0,r.kt)("h3",{id:"long-description-9"},"Long Description"),(0,r.kt)("p",null,"The simplify tactic invokes z3's main rewriting engine.\nThe rewriting engine contains support for theory specific simplifications.\nThe set of simplifications invoked is open ended. Useful algebraic simplifications\nare added to the rewrite engine as they are discovered to be useful."),(0,r.kt)("p",null,"Note that the simplifier does not ensure that equivalent formulas are simplified to the same form.\nIn other words it does not guarantee canonicity. This contrasts with BDD packages where BDDs constructed\nfrom two equivalent formulas are guaranteed to be equal."),(0,r.kt)("h3",{id:"example-18"},"Example"),(0,r.kt)(s(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"  (declare-const x Int)\n  (declare-const y Int)\n  (assert (> x (+ x y)))\n  (apply simplify)",result:{output:"(goals\n(goal\n  (not (<= 0 y))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"f5510ddd1aa3661e9a7ede81d143d66e01adcdb4"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.11.0",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h3",{id:"notes-15"},"Notes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"supports unsat cores, proof terms")),(0,r.kt)("h3",{id:"parameters-13"},"Parameters"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"algebraic_number_evaluator"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"simplify/evaluate expressions containing (algebraic) irrational numbers."),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"arith_ineq_lhs"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"rewrite inequalities so that right-hand-side is a constant."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"arith_lhs"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"all monomials are moved to the left-hand-side, and the right-hand-side is just a constant."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bit2bool"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"try to convert bit-vector terms of size 1 into Boolean terms"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"blast_distinct"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"expand a distinct predicate into a quadratic number of disequalities"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"blast_distinct_threshold"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted"),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"blast_eq_value"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"blast (some) Bit-vector equalities into bits"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"blast_select_store"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"eagerly replace all (select (store ..) ..) term by an if-then-else term"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_extract_prop"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"attempt to partially propagate extraction inwards"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_ineq_consistency_test_max"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"max size of conjunctions on which to perform consistency test based on inequalities on bitvectors."),(0,r.kt)("td",{parentName:"tr",align:null},"0")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_ite2id"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"rewrite ite that can be simplified to identity"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_le2extract"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"disassemble bvule to extract"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_le_extra"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"additional bu_(u/s)le simplifications"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_not_simpl"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"apply simplifications for bvnot"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bv_sort_ac"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"sort the arguments of all AC operators"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cache_all"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"cache all intermediate results."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"elim_and"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"conjunctions are rewritten using negation and disjunctions"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"elim_ite"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"eliminate ite in favor of and/or"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"elim_rem"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"replace (rem x y) with (ite (",">","= y 0) (mod x y) (- (mod x y)))."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"elim_sign_ext"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"expand sign-ext operator using concat and extract"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"elim_to_real"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"eliminate to_real from arithmetic predicates that contain only integers."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"eq2ineq"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"expand equalities into two inequalities"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_nested_stores"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"replace nested stores by a lambda expression"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_power"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"expand (^ t k) into (* t ... t) if  1 ","<"," k ","<","= max_degree."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_select_ite"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"expand select over ite expressions"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_select_store"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"conservatively replace a (select (store ...) ...) term by an if-then-else term"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_store_eq"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"reduce (store ...) = (store ...) with a common base into selects"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"expand_tan"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"replace (tan x) with (/ (sin x) (cos x))."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"flat"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"flat_and_or"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"create nary applications for and,or"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"gcd_rounding"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"use gcd rounding on integer arithmetic atoms."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hi_div0"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"use the 'hardware interpretation' for division by zero (for bit-vector terms)"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hoist_ite"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"hoist shared summands under ite expressions"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hoist_mul"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"hoist multiplication over summation to minimize number of multiplications"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ignore_patterns_on_ground_qbody"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"ignores patterns on quantifiers that don't mention their bound variables."),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ite_extra_rules"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"extra ite simplifications, these additional simplifications may reduce size locally but increase globally"),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"local_ctx"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"perform local (i.e., cheap) context simplifications"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"local_ctx_limit"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"limit for applying local context simplifier"),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_degree"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"max degree of algebraic numbers (and power operators) processed by simplifier."),(0,r.kt)("td",{parentName:"tr",align:null},"64")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"maximum amount of memory in megabytes"),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_steps"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"maximum number of steps"),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"mul2concat"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"replace multiplication by a power of two into a concatenation"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"mul_to_power"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"collpase (* t ... t) into (^ t k), it is ignored if expand_power is true."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pull_cheap_ite"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"pull if-then-else terms when cheap."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"push_ite_arith"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"push if-then-else over arithmetic terms."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"push_ite_bv"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"push if-then-else over bit-vector terms."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"push_to_real"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"distribute to_real over * and +."),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rewrite_patterns"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"rewrite patterns."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"som"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"put polynomials in sum-of-monomials form"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"som_blowup"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form"),(0,r.kt)("td",{parentName:"tr",align:null},"10")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sort_store"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"sort nested stores when the indices are known to be different"),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sort_sums"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"sort the arguments of + application."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"split_concat_eq"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"split equalities of the form (= (concat t1 t2) t3)"),(0,r.kt)("td",{parentName:"tr",align:null},"false")))),(0,r.kt)("h2",{id:"tactic-solve-eqs"},"Tactic solve-eqs"),(0,r.kt)("h3",{id:"short-description-19"},"Short Description"),(0,r.kt)("p",null,"Solve for variables"),(0,r.kt)("h3",{id:"long-description-10"},"Long Description"),(0,r.kt)("p",null,"The tactic eliminates variables that can be brought into solved form.\nFor example, the assertion ",(0,r.kt)("inlineCode",{parentName:"p"},"x = f(y + z)")," can be solved for ",(0,r.kt)("inlineCode",{parentName:"p"},"x"),", replacing ",(0,r.kt)("inlineCode",{parentName:"p"},"x"),"\neverywhere by ",(0,r.kt)("inlineCode",{parentName:"p"},"f(x + y)"),". It depends on a set of theory specific equality solvers"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Basic equations"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"equations between uninterpreted constants and terms. "),(0,r.kt)("li",{parentName:"ul"},"equations written as ",(0,r.kt)("inlineCode",{parentName:"li"},"(if p (= x t) (= x s))")," are solved as ",(0,r.kt)("inlineCode",{parentName:"li"},"(= x (if p t s))"),"."),(0,r.kt)("li",{parentName:"ul"},"asserting ",(0,r.kt)("inlineCode",{parentName:"li"},"p")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"(not p)")," where ",(0,r.kt)("inlineCode",{parentName:"li"},"p")," is uninterpreted, causes ",(0,r.kt)("inlineCode",{parentName:"li"},"p")," to be replaced by ",(0,r.kt)("inlineCode",{parentName:"li"},"true")," (or ",(0,r.kt)("inlineCode",{parentName:"li"},"false"),")."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Arithmetic equations"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"It solves ",(0,r.kt)("inlineCode",{parentName:"li"},"x mod k = s")," to ",(0,r.kt)("inlineCode",{parentName:"li"},"x = k * m' + s"),", where m'` is a fresh constant. "),(0,r.kt)("li",{parentName:"ul"},"It finds variables with unit coefficients in integer linear equations."),(0,r.kt)("li",{parentName:"ul"},"It solves for ",(0,r.kt)("inlineCode",{parentName:"li"},"x * Y = Z")," under the side-condition ",(0,r.kt)("inlineCode",{parentName:"li"},"Y != 0")," as ",(0,r.kt)("inlineCode",{parentName:"li"},"x = Z/Y"),".")))),(0,r.kt)("p",null,"It also allows solving for uninterpreted constants that only appear in a single disjuction. For example,\n",(0,r.kt)("inlineCode",{parentName:"p"},"(or (= x (+ 5 y)) (= y (+ u z)))")," allows solving for ",(0,r.kt)("inlineCode",{parentName:"p"},"x"),". "),(0,r.kt)("h3",{id:"example-19"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"(declare-const x Int)\n(declare-const y Int)\n(declare-const z Int)\n(declare-const u Int)\n(assert (or (and (= x (+ 5 y)) (> u z)) (= y (+ u z))))\n(apply solve-eqs)\n")),(0,r.kt)("p",null,"It produces the goal"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"(goal\n  (or (not (<= u z)) (= y (+ u z)))\n  :precision precise :depth 1)\n")),(0,r.kt)("p",null,"where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," was solved as ",(0,r.kt)("inlineCode",{parentName:"p"},"(+ 5 y)"),"."),(0,r.kt)("h3",{id:"notes-16"},"Notes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"supports unsat cores"),(0,r.kt)("li",{parentName:"ul"},"does not support fine-grained proofs")),(0,r.kt)("h3",{id:"parameters-14"},"Parameters"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"context_solve"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"solve equalities under disjunctions."),(0,r.kt)("td",{parentName:"tr",align:null},"false")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ite_solver"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"use if-then-else solver."),(0,r.kt)("td",{parentName:"tr",align:null},"true")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"solve_eqs_max_occs"),(0,r.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,r.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum number of occurrences for considering a variable for gaussian eliminations."),(0,r.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"theory_solver"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"theory solvers."),(0,r.kt)("td",{parentName:"tr",align:null},"true")))))}k.isMDXComponent=!0}}]);