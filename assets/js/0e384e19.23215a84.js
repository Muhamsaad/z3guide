"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[671],{9881:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var a=t(7462),i=(t(7294),t(3905));t(7689);const r={sidebar_position:1},s="Tutorial Intro",o={unversionedId:"intro",id:"intro",title:"Tutorial Intro",description:"Guide",source:"@site/docs/intro.md",sourceDirName:".",slug:"/intro",permalink:"/rise4fun/docs/intro",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/intro.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",next:{title:"Tutorial - Basics",permalink:"/rise4fun/docs/category/tutorial---basics"}},l={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Basic Commands",id:"basic-commands",level:2},{value:"Using Scopes",id:"using-scopes",level:3},{value:"Configuration",id:"configuration",level:3},{value:"Additional commands",id:"additional-commands",level:3},{value:"Propositional Logic",id:"propositional-logic",level:2},{value:"Satisfiability and Validity",id:"satisfiability-and-validity",level:3},{value:"Uninterpreted functions and constants",id:"uninterpreted-functions-and-constants",level:2},{value:"Arithmetic",id:"arithmetic",level:2},{value:"Nonlinear arithmetic",id:"nonlinear-arithmetic",level:3},{value:"Division",id:"division",level:3},{value:"Bitvectors",id:"bitvectors",level:2},{value:"Basic Bitvector Arithmetic",id:"basic-bitvector-arithmetic",level:3},{value:"Bitwise Operations",id:"bitwise-operations",level:3},{value:"Predicates over Bitvectors",id:"predicates-over-bitvectors",level:3},{value:"Arrays",id:"arrays",level:2},{value:"Select and Store",id:"select-and-store",level:3},{value:"Constant Arrays",id:"constant-arrays",level:3},{value:"Array models",id:"array-models",level:3},{value:"Mapping Functions on Arrays",id:"mapping-functions-on-arrays",level:3},{value:"Bags as Arrays",id:"bags-as-arrays",level:3},{value:"Datatypes",id:"datatypes",level:2},{value:"Records",id:"records",level:3},{value:"Scalars (enumeration types)",id:"scalars-enumeration-types",level:3},{value:"Recursive datatypes",id:"recursive-datatypes",level:3},{value:"Mutually recursive datatypes",id:"mutually-recursive-datatypes",level:3},{value:"Z3 will not prove inductive facts",id:"z3-will-not-prove-inductive-facts",level:3},{value:"Quantifiers",id:"quantifiers",level:2},{value:"Modeling with Quantifiers",id:"modeling-with-quantifiers",level:3},{value:"Patterns",id:"patterns",level:3},{value:"Multi-patterns",id:"multi-patterns",level:3},{value:"No patterns",id:"no-patterns",level:3},{value:"Model-based Quantifier Instantiation",id:"model-based-quantifier-instantiation",level:3},{value:"Effectively Propositional",id:"effectively-propositional",level:4},{value:"Stratified Sorts Fragment",id:"stratified-sorts-fragment",level:4},{value:"Array Property Fragment",id:"array-property-fragment",level:4},{value:"List Fragment",id:"list-fragment",level:4},{value:"Essentially (Almost) Uninterpreted Fragment",id:"essentially-almost-uninterpreted-fragment",level:4},{value:"Quantified Bit-Vector Formulas",id:"quantified-bit-vector-formulas",level:4},{value:"Conditional (and Pseudo) Macros",id:"conditional-and-pseudo-macros",level:4},{value:"My formula is not in any of the fragments above",id:"my-formula-is-not-in-any-of-the-fragments-above",level:4},{value:"Conclusion",id:"conclusion",level:2}],c={toc:d};function u(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"tutorial-intro"},"Tutorial Intro"),(0,i.kt)("p",null,"Guide"),(0,i.kt)("h1",{id:"getting-started-with-z3-a-guide"},"Getting Started with Z3 A Guide"),(0,i.kt)("p",null,"Be sure to follow along with the examples by clicking the edit link in the corner. See what the tool says, try your own formulas, and experiment!"),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"Z3 is a state-of-the art theorem prover from Microsoft Research. It can be used to check the satisfiability of logical formulas over one or more theories. Z3 offers a compelling match for software analysis and verification tools, since several common software constructs map directly into supported theories."),(0,i.kt)("p",null,"The main objective of the tutorial is to introduce the reader on how to use Z3 effectively for logical modeling and solving. The tutorial provides some general background on logical modeling, but we have to defer a full introduction to first-order logic and decision procedures to text-books."),(0,i.kt)("p",null,"Z3 is a low level tool. It is best used as a component in the context of other tools that require solving logical formulas. Consequently, Z3 exposes a number of API facilities to make it convenient for tools to map into Z3, but there are no stand-alone editors or user-centric facilities for interacting with Z3. The language syntax used in the front ends favor simplicity in contrast to linguistic convenience."),(0,i.kt)("h2",{id:"basic-commands"},"Basic Commands"),(0,i.kt)("p",null,"The Z3 input format is an extension of the one defined by the ",(0,i.kt)("a",{parentName:"p",href:"httpwww.smtlib.org"},"SMT-LIB 2.0 standard"),". A Z3 script is a sequence of commands. The help command displays a list of all available commands. The command echo displays a message. Internally, Z3 maintains a stack of user provided formulas and declarations. We say these are the assertions provided by the user. The command declare-const declares a constant of a given type (aka sort). The command declare-fun declares a function. In the following example, we declared a function that receives an integer and a boolean, and returns an integer."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(echo starting Z3...)\n(declare-const a Int)\n(declare-fun f (Int Bool) Int)\n")),(0,i.kt)("p",null,"The command assert adds a formula into the Z3 internal stack. We say the set of formulas in the Z3 stack is satisfiable if there is an interpretation (for the user declared constants and functions) that makes all asserted formulas true."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(declare-const a Int)\n(declare-fun f (Int Bool) Int)\n(assert ( a 10))\n(assert ( (f a true) 100))\n(check-sat)\n")),(0,i.kt)("p",null,"The first asserted formula states that the constant a must be greater than 10. The second one states that the function f applied to a and true must return a value less than 100. The command check-sat determines whether the current formulas on the Z3 stack are satisfiable or not. If the formulas are satisfiable, Z3 returns sat. If they are not satisfiable (i.e., they are unsatisfiable), Z3 returns unsat. Z3 may also return unknown when it can't determine whether a formula is satisfiable or not."),(0,i.kt)("p",null,"When the command check-sat returns sat, the command get-model can be used to retrieve an interpretation that makes all formulas on the Z3 internal stack true."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(declare-const a Int)\n(declare-fun f (Int Bool) Int)\n(assert ( a 10))\n(assert ( (f a true) 100))\n(check-sat)\n(get-model)\n")),(0,i.kt)("p",null,"The interpretation is provided using definitions. For example, the definition"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"}," define-fun a () Int ","[val]",")")),(0,i.kt)("p",null,"states that the value of a in the model is ","[val]",". The definition"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"(define-fun f ((x!1 Int) (x!2 Bool)) Int\n...\n)")),(0,i.kt)("p",null,"is very similar to a function definition used in programming languages. In this example, x1 and x2 are the arguments of the function interpretation created by Z3. For this simple example, the definition of f is based on ite's (aka if-then-elses or conditional expressions). For example, the expression"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"(ite (and (= x!1 11) (= x!2 false)) 21 0)")),(0,i.kt)("p",null,"evaluates (returns) 21 when x!1 is equal to 11, and x!2 is equal to false. Otherwise, it returns 0."),(0,i.kt)("h3",{id:"using-scopes"},"Using Scopes"),(0,i.kt)("p",null,"In some applications, we want to explore several similar problems that share several definitions and assertions. We can use the commands push and pop for doing that. Z3 maintains a global stack of declarations and assertions. The command push creates a new scope by saving the current stack size. The command pop removes any assertion or declaration performed between it and the matching push. The check-sat and get-assertions commands always operate on the content of the global stack."),(0,i.kt)("p",null,"In the following example, the command (assert p) signs an error because the pop command removed the declaration for p. If the last pop command is removed, then the error is corrected."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(declare-const x Int)\n(declare-const y Int)\n(declare-const z Int)\n(push)\n(assert (= (+ x y) 10))\n(assert (= (+ x ( 2 y)) 20))\n(check-sat)\n(pop) ; remove the two assertions\n(push) \n(assert (= (+ ( 3 x) y) 10))\n(assert (= (+ ( 2 x) ( 2 y)) 21))\n(check-sat)\n(declare-const p Bool)\n(pop)\n(assert p) ; error, since declaration of p was removed from the stack\n")),(0,i.kt)("p",null,"The push and pop commands can optionally receive a numeral argument as specifed by the SMT 2 language."),(0,i.kt)("h3",{id:"configuration"},"Configuration"),(0,i.kt)("p",null,"The command set-option is used to configure Z3. Z3 has several options to control its behavior. Some of these options (e.g., produce-proofs) can only be set before any declaration or assertion. We use the reset command to erase all assertions and declarations. After the reset command, all configuration options can be set."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(set-option print-success true) \n(set-option produce-unsat-cores true) ; enable generation of unsat cores\n(set-option produce-models true) ; enable model generation\n(set-option produce-proofs true) ; enable proof generation\n(declare-const x Int)\n(set-option produce-proofs false) ; error, cannot change this option after a declaration or assertion\n(echo before reset)\n(reset)\n(set-option produce-proofs false) ; ok\n")),(0,i.kt)("p",null,"The option print-success true is particularly useful when Z3 is being controlled by another application using pipes. In this mode, commands, that otherwise would not print any output, will print success."),(0,i.kt)("h3",{id:"additional-commands"},"Additional commands"),(0,i.kt)("p",null,"The command (display t) just applies the Z3 pretty printer to the given expression. The command (simplify t) displays a possibly simpler expression equivalent to t. This command accepts many different options, (help simplify) will display all available options."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(declare-const a (Array Int Int))\n(declare-const x Int)\n(declare-const y Int)\n(display (+ x 2 x 1))\n(simplify (+ x 2 x 1))\n(simplify ( (+ x y) (+ x y)))\n(simplify ( (+ x y) (+ x y)) som true) ; put all expressions in sum-of-monomials form.\n(simplify (= x (+ y 2)) arith-lhs true)\n(simplify (= (store (store a 1 2) 4 3)\n             (store (store a 4 3) 1 2)))\n(simplify (= (store (store a 1 2) 4 3)\n             (store (store a 4 3) 1 2))\n          sort-store true)\n(help simplify)\n")),(0,i.kt)("p",null,"The define-sort command defines a new sort symbol that is an abbreviation for a sort expression. The new sort symbol can be parameterized, in which case the names of the parameters are specified in the command and the sort expression uses the sort parameters. The form of the command is this"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"(define-sort ","[symbol]"," (","[symbol]","+) ","[sort]",")")),(0,i.kt)("p",null,"The following example defines several abbreviations for sort expressions."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(define-sort Set (T) (Array T Bool))\n(define-sort IList () (List Int))\n(define-sort List-Set (T) (Array (List T) Bool))\n(define-sort I () Int)\n\n(declare-const s1 (Set I))\n(declare-const s2 (List-Set Int))\n(declare-const a I)\n(declare-const l IList)\n\n(assert (= (select s1 a) true))\n(assert (= (select s2 l) false))\n(check-sat)\n(get-model)\n")),(0,i.kt)("h2",{id:"propositional-logic"},"Propositional Logic"),(0,i.kt)("p",null,"The pre-defined sort Bool is the sort (type) of all Boolean propositional expressions. Z3 supports the usual Boolean operators and, or, xor, not, = (implication), ite (if-then-else). Bi-implications are represented using equatity =. The following example shows how to prove that if p implies q and q implies r, then p implies r. We accomplish that by showing that the negation is unsatisfiable. The command define-fun is used to define a macro (aka alias). In this example, conjecture is an alias for the conjecture we want to prove."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(declare-const p Bool)\n(declare-const q Bool)\n(declare-const r Bool)\n(define-fun conjecture () Bool\n    (= (and (= p q) (= q r))\n        (= p r)))\n(assert (not conjecture))\n(check-sat)\n")),(0,i.kt)("h3",{id:"satisfiability-and-validity"},"Satisfiability and Validity"),(0,i.kt)("p",null,"A formula F is valid if F always evaluates to true for any assignment of appropriate values to its uninterpreted function and constant symbols. A formula F is satisfiable if there is some assignment of appropriate values to its uninterpreted function and constant symbols under which F evaluates to true. Validity is about finding a proof of a statement; satisfiability is about finding a solution to a set of constraints. Consider a formula F with some uninterpreted constants, say a and b. We can ask whether F is valid, that is whether it is always true for any combination of values for a and b. If F is always true, then not F is always false, and then not F will not have any satisfying assignment; that is, not F is unsatisfiable. That is, F is valid precisely when not F is not satisfiable (is unsatisfiable). Alternately, F is satisfiable if and only if not F is not valid (is invalid). Z3 finds satisfying assignments (or report that there are none). To determine whether a formula F is valid, we ask Z3 whether not F is satisfiable. Thus, to check the deMorgan's law is valid (i.e., to prove it), we show its negation to be unsatisfiable."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(declare-const a Bool)\n(declare-const b Bool)\n(define-fun demorgan () Bool\n    (= (and a b) (not (or (not a) (not b)))))\n(assert (not demorgan))\n(check-sat)\n")),(0,i.kt)("h2",{id:"uninterpreted-functions-and-constants"},"Uninterpreted functions and constants"),(0,i.kt)("p",null,"The basic building blocks of SMT formulas are constants and functions. Constants are just functions that take no arguments. So everything is really just a function."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(declare-fun f (Int) Int)\n(declare-fun a () Int) ; a is a constant\n(declare-const b Int) ; syntax sugar for (declare-fun b () Int)\n(assert ( a 20))\n(assert ( b a))\n(assert (= (f 10) 1))\n(check-sat)\n(get-model)\n")),(0,i.kt)("p",null,"Unlike programming languages, where functions have side-effects, can throw exceptions, or never return, functions in classical first-order logic have no side-effects and are total. That is, they are defined on all input values. This includes functions, such as division."),(0,i.kt)("p",null,"Function and constant symbols in pure first-order logic are ",(0,i.kt)("em",{parentName:"p"},"uninterpreted")," or ",(0,i.kt)("em",{parentName:"p"},"free"),", which means that no a priori interpretation is attached. This is in contrast to functions belonging to the signature of theories, such as arithmetic where the function + has a fixed standard interpretation (it adds two numbers). Uninterpreted functions and constants are maximally flexible; they allow any interpretation that is consistent with the constraints over the function or constant."),(0,i.kt)("p",null,"To illustrate uninterpreted functions and constants let us introduce an (uninterpreted) sort A, and the constants x, y ranging over A. Finally let f be an uninterpreted function that takes one argument of sort A and results in a value of sort A. The example illustrates how one can force an interpretation where f applied twice to x results in x again, but f applied once to x is different form x."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(declare-sort A)\n(declare-const x A)\n(declare-const y A)\n(declare-fun f (A) A)\n(assert (= (f (f x)) x))\n(assert (= (f x) y))\n(assert (not (= x y)))\n(check-sat)\n(get-model)\n")),(0,i.kt)("p",null,"The resulting model introduces abstract values for the elements in A, because the sort A is uninterpreted. The interpretation for f in the model toggles between the two values for x and y, which are different."),(0,i.kt)("h2",{id:"arithmetic"},"Arithmetic"),(0,i.kt)("p",null,"Z3 has builtin support for integer and real constants. This two types should not be confused with machine integers (32-bit or 64-bit) and floating point numbers. These two types (sorts) represent the mathematical integers and reals. The command declare-const is used to declare integer and real constants."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(declare-const a Int)\n(declare-const b Int)\n(declare-const c Int)\n(declare-const d Real)\n(declare-const e Real)\n")),(0,i.kt)("p",null,"After constants are declared, the user can assert.smt formulas containing these constants. The formulas contain arithmetic operators such as +, -, , and so on. The command check-sat will instruct Z3 to try to find an interpretation for the declared constants that makes all formulas true. The interpretation is basically assigning a number to each constant. If such interpretation exists, we say it is a model for the asserted formulas. The command get-model displays the model built by Z3."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(declare-const a Int)\n(declare-const b Int)\n(declare-const c Int)\n(declare-const d Real)\n(declare-const e Real)\n(assert ( a (+ b 2)))\n(assert (= a (+ ( 2 c) 10)))\n(assert (= (+ c b) 1000))\n(assert (= d e))\n(check-sat)\n(get-model)\n")),(0,i.kt)("p",null,"Real constants should contain a decimal point. Unlike most programming languages, Z3 will not convert automatically integers into reals and vice-versa. The function to-real can be used to convert an integer expression into a real one."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(declare-const a Int)\n(declare-const b Int)\n(declare-const c Int)\n(declare-const d Real)\n(declare-const e Real)\n(assert ( e (+ (to_real (+ a b)) 2.0)))\n(assert (= d (+ (to_real c) 0.5)))\n(assert ( a b))\n(check-sat)\n(get-model)\n")),(0,i.kt)("h3",{id:"nonlinear-arithmetic"},"Nonlinear arithmetic"),(0,i.kt)("p",null,"We say a formula is nonlinear if it contains expressions of the form ( t s) where t and s are not numbers. Nonlinear real arithmetic is very expensive, and Z3 is not complete for this kind of formula. The command check-sat may return unknown or loop. Nonlinear integer arithmetic is undecidable there is no procedure that is correct and terminates (for every input) with a sat or unsat answer. Yes, it is impossible to build such procedure. Note that, this does not prevent Z3 from returning an answer for many nonlinear problems. The real limit is that there will always be a nonlinear integer arithmetic formula that it will fail produce an answer."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(declare-const a Int)\n(assert ( ( a a) 3))\n(check-sat)\n(get-model)\n\n(echo Z3 does not always find solutions to non-linear problems)\n(declare-const b Real)\n(declare-const c Real)\n(assert (= (+ ( b b b) ( b c)) 3.0))\n(check-sat)\n\n(echo yet it can show unsatisfiabiltiy for some nontrivial nonlinear problems...)\n(declare-const x Real)\n(declare-const y Real)\n(declare-const z Real)\n(assert (= ( x x) (+ x 2.0)))\n(assert (= ( x y) x))\n(assert (= ( (- y 1.0) z) 1.0))\n(check-sat)\n\n(reset)\n(echo When presented only non-linear constraints over reals, Z3 uses a specialized complete solver)\n(declare-const b Real)\n(declare-const c Real)\n(assert (= (+ ( b b b) ( b c)) 3.0))\n(check-sat)\n(get-model)\n")),(0,i.kt)("h3",{id:"division"},"Division"),(0,i.kt)("p",null,"Z3 also has support for division, integer division, modulo and remainder operators. Internally, they are all mapped to multiplication."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(declare-const a Int)\n(declare-const r1 Int)\n(declare-const r2 Int)\n(declare-const r3 Int)\n(declare-const r4 Int)\n(declare-const r5 Int)\n(declare-const r6 Int)\n(assert (= a 10))\n(assert (= r1 (div a 4))) ; integer division\n(assert (= r2 (mod a 4))) ; mod\n(assert (= r3 (rem a 4))) ; remainder\n(assert (= r4 (div a (- 4)))) ; integer division\n(assert (= r5 (mod a (- 4)))) ; mod\n(assert (= r6 (rem a (- 4)))) ; remainder\n(declare-const b Real)\n(declare-const c Real)\n(assert (= b ( c 3.0)))\n(assert (= c 20.0))\n(check-sat)\n(get-model)\n")),(0,i.kt)("p",null,"In Z3, division by zero is allowed, but the result is not specified. Division is not a partial function. Actually, in Z3 all functions are total, although the result may be underspecified in some cases like division by zero."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(declare-const a Real)\n; The following formula is satisfiable since division by zero is not specified.\n(assert (= ( a 0.0) 10.0)) \n(check-sat)\n(get-model)\n\n; Although division by zero is not specified, division is still a function.\n; So, ( a 0.0) cannot evaluated to 10.0 and 2.0.\n(assert (= ( a 0.0) 2.0)) \n(check-sat)\n")),(0,i.kt)("p",null,"If you are not happy with this behavior, you may use ite (if-then-else) operator to guard every division, and assign whatever intepretation you like to the division by zero. This example uses define-fun constructor to create a new operator mydiv. This is essentially a macro, and Z3 will expand its definition for every application of mydiv."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"; defining my own division operator where x0.0 == 0.0 for every x.\n(define-fun mydiv ((x Real) (y Real)) Real\n  (if (not (= y 0.0))\n      ( x y)\n      0.0))\n(declare-const a Real)\n(declare-const b Real)\n(assert (= (mydiv a b) 1.0))\n(assert (= b 0.0))\n(check-sat)\n")),(0,i.kt)("h2",{id:"bitvectors"},"Bitvectors"),(0,i.kt)("p",null,"Modern CPUs and main-stream programming languages use arithmetic over fixed-size bit-vectors. The theory of bit-vectors allows modeling the precise semantics of unsigned and of signed two-complements arithmetic. There are a large number of supported functions and relations over bit-vectors. They are summarized on Z3's documentation link here! of the binary APIs and they are summarized on the SMT-LIB link here!  web-site. We will not try to give a comprehensive overview here, but touch on some of the main features."),(0,i.kt)("p",null,"In contrast to programming languages, such as C, C++, C#, Java, there is no distinction between signed and unsigned bit-vectors as numbers. Instead, the theory of bit-vectors provides special signed versions of arithmetical operations where it makes a difference whether the bit-vector is treated as signed or unsigned."),(0,i.kt)("p",null,"Z3 supports Bitvectors of arbitrary size. (",(0,i.kt)("em",{parentName:"p"}," BitVec n) is the sort of bitvectors whose length is n. Bitvector literals may be defined using binary, decimal and hexadecimal notation. In the binary and hexadecimal cases, the bitvector size is inferred from the number of characters. For example, the bitvector literal #b010 in binary format is a bitvector of size 3, and the bitvector literal #x0a0 in hexadecimal format is a bitvector of size 12. The size must be specified for bitvector literals in decimal format. For example, (")," bv10 32) is a bitvector of size 32 that representes the numeral 10. By default, Z3 display bitvectors in hexadecimal format if the bitvector size is a multiple of 4, and in binary otherwise. The command (set-option pp.bv-literals false) can be used to force Z3 to display bitvector literals in decimal format."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(display #b0100)\n(display (_ bv20 8))\n(display (_ bv20 7))\n(display #x0a) \n(set-option pp.bv-literals false)\n(display #b0100)\n(display (_ bv20 8))\n(display (_ bv20 7))\n(display #x0a) \n")),(0,i.kt)("h3",{id:"basic-bitvector-arithmetic"},"Basic Bitvector Arithmetic"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(simplify (bvadd #x07 #x03)) ; addition\n(simplify (bvsub #x07 #x03)) ; subtraction\n(simplify (bvneg #x07)) ; unary minus\n(simplify (bvmul #x07 #x03)) ; multiplication\n(simplify (bvurem #x07 #x03)) ; unsigned remainder\n(simplify (bvsrem #x07 #x03)) ; signed remainder\n(simplify (bvsmod #x07 #x03)) ; signed modulo\n(simplify (bvshl #x07 #x03)) ; shift left\n(simplify (bvlshr #xf0 #x03)) ; unsigned (logical) shift right\n(simplify (bvashr #xf0 #x03)) ; signed (arithmetical) shift right\n")),(0,i.kt)("h3",{id:"bitwise-operations"},"Bitwise Operations"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(simplify (bvor #x6 #x3))   ; bitwise or\n(simplify (bvand #x6 #x3))  ; bitwise and\n(simplify (bvnot #x6)) ; bitwise not\n(simplify (bvnand #x6 #x3)) ; bitwise nand\n(simplify (bvnor #x6 #x3)) ; bitwise nor\n(simplify (bvxnor #x6 #x3)) ; bitwise xnor\n")),(0,i.kt)("p",null,"We can prove a bitwise version of deMorgan's law"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(declare-const x (_ BitVec 64))\n(declare-const y (_ BitVec 64))\n(assert (not (= (bvand (bvnot x) (bvnot y)) (bvnot (bvor x y)))))\n(check-sat)\n")),(0,i.kt)("p",null,"Let us illustrate a simple property of bit-wise arithmetic. There is a fast way to check that fixed size numbers are powers of two. It turns out that a bit-vector x is a power of two or zero if and only if x & (x - 1) is zero, where & represents the bitwise and. We check this for four bits below."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(define-fun is-power-of-two ((x (_ BitVec 4))) Bool \n  (= #x0 (bvand x (bvsub x #x1))))\n(declare-const a (_ BitVec 4))\n(assert \n (not (= (is-power-of-two a) \n         (or (= a #x0) \n             (= a #x1) \n             (= a #x2) \n             (= a #x4) \n             (= a #x8)))))\n(check-sat)\n")),(0,i.kt)("h3",{id:"predicates-over-bitvectors"},"Predicates over Bitvectors"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(simplify (bvule #x0a #xf0))  ; unsigned less or equal\n(simplify (bvult #x0a #xf0))  ; unsigned less than\n(simplify (bvuge #x0a #xf0))  ; unsigned greater or equal\n(simplify (bvugt #x0a #xf0))  ; unsigned greater than\n(simplify (bvsle #x0a #xf0))  ; signed less or equal\n(simplify (bvslt #x0a #xf0))  ; signed less than\n(simplify (bvsge #x0a #xf0))  ; signed greater or equal\n(simplify (bvsgt #x0a #xf0))  ; signed greater than\n")),(0,i.kt)("p",null,"Signed comparison, such as bvsle, takes the sign bit of bitvectors into account for comparison, while unsigned comparison treats the bitvector as unsigned (treats the bitvector as a natural number)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(declare-const a (_ BitVec 4))\n(declare-const b (_ BitVec 4))\n(assert (not (= (bvule a b) (bvsle a b))))\n(check-sat)\n(get-model)\n")),(0,i.kt)("h2",{id:"arrays"},"Arrays"),(0,i.kt)("p",null,"As part of formulating a programme of a mathematical theory of computation McCarthy proposed a ",(0,i.kt)("em",{parentName:"p"},"basic")," theory of arrays as characterized by the select-store axioms. The expression (select a i) returns the value stored at position i of the array a; and (store a i v) returns a new array identical to a, but on position i it contains the value v."),(0,i.kt)("p",null,"Z3 contains a decision procedure for the basic theory of arrays. By default, Z3 assumes that arrays are extensional over select. In other words, Z3 also enforces that if two arrays agree on all reads, then the arrays are equal."),(0,i.kt)("p",null,"It also contains various extensions for operations on arrays that remain decidable and amenable to efficient saturation procedures (here efficient means, with an NP-complete satisfiability complexity). We describe these extensions in the following using a collection of examples. Additional background on these extensions is available in the paper ",(0,i.kt)("a",{parentName:"p",href:"httpresearch.microsoft.comen-usumpeopleleonardofmcad09.pdf"},"Generalized and Efficient Array Decision Procedures"),"."),(0,i.kt)("h3",{id:"select-and-store"},"Select and Store"),(0,i.kt)("p",null,"Let us first check a basic property of arrays. Suppose a1 is an array of integers, then the constraint (and (= (select a1 x) x) (= (store a1 x y) a1)) is satisfiable for an array that contains an index x that maps to x, and when x = y (because the first equality forced the range of x to be x). We can check this constraint."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(declare-const x Int)\n(declare-const y Int)\n(declare-const z Int)\n(declare-const a1 (Array Int Int))\n(declare-const a2 (Array Int Int))\n(declare-const a3 (Array Int Int))\n(assert (= (select a1 x) x))\n(assert (= (store a1 x y) a1))\n(check-sat)\n(get-model)\n")),(0,i.kt)("p",null,"On the other hand, the constraints become unsatisfiable when asserting (not (= x y))."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(declare-const x Int)\n(declare-const y Int)\n(declare-const z Int)\n(declare-const a1 (Array Int Int))\n(declare-const a2 (Array Int Int))\n(declare-const a3 (Array Int Int))\n(assert (= (select a1 x) x))\n(assert (= (store a1 x y) a1))\n(assert (not (= x y)))\n(check-sat)\n")),(0,i.kt)("h3",{id:"constant-arrays"},"Constant Arrays"),(0,i.kt)("p",null,"The array that maps all indices to some fixed value can be specified in Z3 using the const construct. It takes one value from the range type of the array and creates an array. Z3 cannot infer what kind of array must be returned by the const construct by just inspecting the argument type. Thus, a qualified identifier (as const (Array T1 T2)) must be used. The following example defines a constant array containing only ones."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(declare-const all1 (Array Int Int))\n(declare-const a Int)\n(declare-const i Int)\n(assert (= all1 ((as const (Array Int Int)) 1)))\n(assert (= a (select all1 i)))\n(check-sat)\n(get-model)\n(assert (not (= a 1)))\n(check-sat)\n")),(0,i.kt)("h3",{id:"array-models"},"Array models"),(0,i.kt)("p",null,"Models provide interpretations of the uninterpreted (aka free) constants and functions that appear in the satisfiable formula. An interpretation for arrays is very similar to the interpretation of a function. Z3 uses the construct (",(0,i.kt)("em",{parentName:"p"}," as-array f) to give the interpretation for arrays. If the array a is equal to (")," as-array f), then for every index i, (select a i) is equal to (f i). In the previous example, Z3 creates the auxiliary function k!0 to assign an interpretation to the array constant all1."),(0,i.kt)("h3",{id:"mapping-functions-on-arrays"},"Mapping Functions on Arrays"),(0,i.kt)("p",null,"In the following, we will simulate basic Boolean algebra (set theory) using the array theory extensions in Z3. Z3 provides a parametrized map function on arrays. It allows applying arbitrary functions to the range of arrays. The following example illustrates how to use the map function."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(define-sort Set (T) (Array T Bool))\n(declare-const a (Set Int))\n(declare-const b (Set Int))\n(declare-const c (Set Int))\n(declare-const x Int)\n(push)\n(assert (not (= ((_ map and) a b) ((_ map not) ((_ map or) ((_ map not) b) ((_ map not) a))))))\n(check-sat)\n(pop)\n(push) \n(assert (and (select ((_ map and) a b) x) (not (select a x))))\n(check-sat)\n(pop)\n(push) \n(assert (and (select ((_ map or) a b) x) (not (select a x))))\n(check-sat)\n(get-model)\n(assert (and (not (select b x))))\n(check-sat)\n")),(0,i.kt)("h3",{id:"bags-as-arrays"},"Bags as Arrays"),(0,i.kt)("p",null,"We can use the parametrized map function to encode finite sets and finite bags. Finite bags can be modeled similarly to sets. A bag is here an array that maps elements to their multiplicity. Main bag operations include union, obtained by adding multiplicity, intersection, by taking the minimum multiplicity, and a dual join operation that takes the maximum multiplicity. In the following example, we define the bag-union using map. Notice that we need to specify the full signature of + since it is an overloaded operator."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(define-sort A () (Array Int Int Int))\n(define-fun bag-union ((x A) (y A)) A\n  ((_ map (+ (Int Int) Int)) x y))\n(declare-const s1 A)\n(declare-const s2 A)\n(declare-const s3 A)\n(assert (= s3 (bag-union s1 s2)))\n(assert (= (select s1 0 0) 5))\n(assert (= (select s2 0 0) 3))\n(assert (= (select s2 1 2) 4))\n(check-sat)\n(get-model)\n")),(0,i.kt)("h2",{id:"datatypes"},"Datatypes"),(0,i.kt)("p",null,"Algebraic datatypes, known from programming languages such as ML, offer a convenient way for specifying common data structures. Records and tuples are special cases of algebraic datatypes, and so are scalars (enumeration types). But algebraic datatypes are more general. They can be used to specify finite lists, trees and other recursive structures."),(0,i.kt)("h3",{id:"records"},"Records"),(0,i.kt)("p",null,"A record is specified as a datatype with a single constructor and as many arguments as record elements. The number of arguments to a record are always the same. The type system does not allow to extend records and there is no record subtyping."),(0,i.kt)("p",null,"The following example illustrates that two records are equal only if all the arguments are equal. It introduces the parametric type Pair, with constructor mk-pair and two arguments that can be accessed using the selector functions first and second."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(declare-datatypes (T1 T2) ((Pair (mk-pair (first T1) (second T2)))))\n(declare-const p1 (Pair Int Int))\n(declare-const p2 (Pair Int Int))\n(assert (= p1 p2))\n(assert ( (second p1) 20))\n(check-sat)\n(get-model)\n(assert (not (= (first p1) (first p2))))\n(check-sat)\n")),(0,i.kt)("h3",{id:"scalars-enumeration-types"},"Scalars (enumeration types)"),(0,i.kt)("p",null,"A scalar sort is a finite domain sort. The elements of the finite domain are enumerated as distinct constants. For example, the sort S is a scalar type with three values A, B and C. It is possible for three constants of sort S to be distinct, but not for four constants."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(declare-datatypes () ((S A B C)))\n(declare-const x S)\n(declare-const y S)\n(declare-const z S)\n(declare-const u S)\n(assert (distinct x y z))\n(check-sat)\n(assert (distinct x y z u))\n(check-sat)\n")),(0,i.kt)("h3",{id:"recursive-datatypes"},"Recursive datatypes"),(0,i.kt)("p",null,"A recursive datatype declaration includes itself directly (or indirectly) as a component. A standard example of a recursive data-type is the one of lists. A parametric list can be specified in Z3 as"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(declare-datatypes (T) ((Lst nil (cons (hd T) (tl Lst)))))\n(declare-const l1 (Lst Int))\n(declare-const l2 (Lst Bool))\n")),(0,i.kt)("p",null,"The List recursive datatype is builtin in Z3. The empty list is nil, and the constructor insert is used to build new lists. The accessors head and tail are defined as usual."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(declare-const l1 (List Int))\n(declare-const l2 (List Int))\n(declare-const l3 (List Int))\n(declare-const x Int)\n(assert (not (= l1 nil)))\n(assert (not (= l2 nil)))\n(assert (= (head l1) (head l2)))\n(assert (not (= l1 l2)))\n(assert (= l3 (insert x l2)))\n(assert ( x 100))\n(check-sat)\n(get-model)\n(assert (= (tail l1) (tail l2)))\n(check-sat)\n")),(0,i.kt)("p",null,"In the example above, we also assert that l1 and l2 are not nil. This is because the interpretation of head and tail is underspecified on nil. So then head and tail would not be able to distinguish nil from (insert (head nil) (tail nil))."),(0,i.kt)("h3",{id:"mutually-recursive-datatypes"},"Mutually recursive datatypes"),(0,i.kt)("p",null,"You can also specify mutually recursive datatypes for Z3. We list one example below."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"; declare a mutually recursive parametric datatype\n(declare-datatypes (T) ((Tree leaf (node (value T) (children TreeList)))\n                        (TreeList nil (cons (car Tree) (cdr TreeList)))))\n(declare-const t1 (Tree Int))\n(declare-const t2 (Tree Bool))\n; we must use the 'as' construct to distinguish the leaf (Tree Int) from leaf (Tree Bool)\n(assert (not (= t1 (as leaf (Tree Int)))))\n(assert ( (value t1) 20))\n(assert (not (is-leaf t2)))\n(assert (not (value t2)))\n(check-sat)\n(get-model)\n")),(0,i.kt)("p",null,"In the example above, we have a tree of Booleans and a tree of integers. The leaf constant must return a tree of a specific sort. To specify the result sort, we use the qualified identifier (as leaf (Tree Int)). Note that, we do not need to use a qualified identifer for value, since Z3 can infer the intended declaration using the sort of the argument."),(0,i.kt)("h3",{id:"z3-will-not-prove-inductive-facts"},"Z3 will not prove inductive facts"),(0,i.kt)("p",null,"The ground decision procedures for recursive datatypes don't lift to establishing inductive facts. Z3 does not contain methods for producing proofs by induction. This may change in the future. In particular, consider the following example where the function p is true on all natural numbers, which can be proved by induction over Nat. Z3 enters a matching loop as it attempts instantiating the universally quantified implication."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(set-option timeout 2000)\n(declare-datatypes () ((Nat zero (succ (pred Nat)))))\n(declare-fun p (Nat) Bool)\n(assert (p zero))\n(assert (forall ((x Nat)) (implies (p (pred x)) (p x))))\n(assert (not (forall ((x Nat)) (p x))))\n(check-sat)\n(get-info all-statistics)\n")),(0,i.kt)("h2",{id:"quantifiers"},"Quantifiers"),(0,i.kt)("p",null,"Z3 is a ",(0,i.kt)("em",{parentName:"p"},"decision procedure")," for the combination of the previous quantifier-free theories. That is, it can answer whether a quantifier-free formula, modulo the theories referenced by the formula, is satisfiable or whether it is unsatisfiable. Z3 also accepts and can work with formulas that use quantifiers. It is no longer a decision procedure for such formulas in general (and for good reasons, as there can be no decision procedure for first-order logic)."),(0,i.kt)("p",null,"Nevertheless, Z3 is often able to handle formulas involving quantifiers. It uses several approaches to handle quantifiers. The most prolific approach is using ",(0,i.kt)("em",{parentName:"p"},"pattern-based")," quantifier instantiation. This approach allows instantiating quantified formulas with ground terms that appear in the current search context based on ",(0,i.kt)("em",{parentName:"p"},"pattern annotations")," on quantifiers. Another approach is based on ",(0,i.kt)("em",{parentName:"p"},"saturation theorem proving")," using a superposition calculus which is a modern method for applying resolution style rules with equalities. The pattern-based instantiation method is quite effective, even though it is inherently incomplete. The saturation based approach is complete for pure first-order formulas, but does not scale as nicely and is harder to predict."),(0,i.kt)("p",null,"Z3 also contains a model-based quantifier instantiation component that uses a model construction to find good terms to instantiate quantifiers with; and Z3 also handles many decidable fragments."),(0,i.kt)("h3",{id:"modeling-with-quantifiers"},"Modeling with Quantifiers"),(0,i.kt)("p",null,"Suppose we want to model an object oriented type system with single inheritance. We would need a predicate for sub-typing. Sub-typing should be a partial order, and respect single inheritance. For some built-in type constructors, such as for array-of, sub-typing should be monotone."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(declare-sort Type)\n(declare-fun subtype (Type Type) Bool)\n(declare-fun array-of (Type) Type)\n(assert (forall ((x Type)) (subtype x x)))\n(assert (forall ((x Type) (y Type) (z Type))\n          (= (and (subtype x y) (subtype y z)) \n              (subtype x z)))) \n(assert (forall ((x Type) (y Type))\n          (= (and (subtype x y) (subtype y x)) \n              (= x y))))\n(assert (forall ((x Type) (y Type) (z Type))\n          (= (and (subtype x y) (subtype x z)) \n              (or (subtype y z) (subtype z y))))) \n(assert (forall ((x Type) (y Type))\n          (= (subtype x y) \n              (subtype (array-of x) (array-of y)))))\n(declare-const root-type Type)\n(assert (forall ((x Type)) (subtype x root-type)))\n(check-sat)\n")),(0,i.kt)("h3",{id:"patterns"},"Patterns"),(0,i.kt)("p",null,"The Stanford Pascal verifier and the subsequent Simplify theorem prover pioneered the use of pattern-based quantifier instantiation. The basic idea behind pattern-based quantifier instantiation is in a sense straight-forward Annotate a quantified formula using a ",(0,i.kt)("em",{parentName:"p"},"pattern")," that contains all the bound variables. So a pattern is an expression (that does not contain binding operations, such as quantifiers) that contains variables bound by a quantifier. Then instantiate the quantifier whenever a term that matches the pattern is created during search. This is a conceptually easy starting point, but there are several subtleties that are important."),(0,i.kt)("p",null,"In the following example, the first two options make sure that Model-based quantifier instantiation and saturation engines are disabled. We also annotate the quantified formula with the pattern (f (g x)). Since there is no ground instance of this pattern, the quantifier is not instantiated, and Z3 fails to show that the formula is unsatisfiable."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(set-option smt.auto-config false) ; disable automatic self configuration\n(set-option smt.mbqi false) ; disable model-based quantifier instantiation\n(declare-fun f (Int) Int)\n(declare-fun g (Int) Int)\n(declare-const a Int)\n(declare-const b Int)\n(declare-const c Int)\n(assert (forall ((x Int))\n                (! (= (f (g x)) x)\n                   pattern ((f (g x))))))\n(assert (= (g a) c))\n(assert (= (g b) c))\n(assert (not (= a b)))\n(check-sat)\n")),(0,i.kt)("p",null,"When the more permissive pattern (g x) is used. Z3 proves the formula to be unsatisfiable. More restrive patterns minimize the number of instantiations (and potentially improve performance), but they may also make Z3 less complete."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(set-option smt.auto-config false) ; disable automatic self configuration\n(set-option smt.mbqi false) ; disable model-based quantifier instantiation\n(declare-fun f (Int) Int)\n(declare-fun g (Int) Int)\n(declare-const a Int)\n(declare-const b Int)\n(declare-const c Int)\n(assert (forall ((x Int))\n                (! (= (f (g x)) x)\n                   pattern ((g x)))))\n(assert (= (g a) c))\n(assert (= (g b) c))\n(assert (not (= a b)))\n(check-sat)\n")),(0,i.kt)("p",null,"Some patterns may also create long instantiation chains. Consider the following assertion."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"(assert (forall (x Type) (y Type)\n(! (= (subtype x y) (subtype (array-of x) (array-of y)))\npattern ((subtype x y))\n))")),(0,i.kt)("p",null,"The axiom gets instantiated whenever there is some ground term of the form (subtype s t). The instantiation causes a fresh ground term (subtype (array-of s) (array-of t)), which enables a new instantiation. This undesirable situation is called a matching loop. Z3 uses many heuristics to break matching loops."),(0,i.kt)("p",null,"Before elaborating on the subtleties, we should address an important first question. What defines the terms that are created during search In the context of most SMT solvers, and of the Simplify theorem prover, terms exist as part of the input formula, they are of course also created by instantiating quantifiers, but terms are also implicitly created when equalities are asserted. The last point means that terms are considered up to congruence and pattern matching takes place modulo ground equalities. We call the matching problem E-matching. For example, if we have the following equalities"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(set-option smt.auto-config false) ; disable automatic self configuration\n(set-option smt.mbqi false) ; disable model-based quantifier instantiation\n(declare-fun f (Int) Int)\n(declare-fun g (Int) Int)\n(declare-const a Int)\n(declare-const b Int)\n(declare-const c Int)\n(assert (forall ((x Int))\n                (! (= (f (g x)) x)\n                   pattern ((f (g x))))))\n(assert (= a (g b)))\n(assert (= b c))\n(assert (not (= (f a) c)))\n(check-sat)\n")),(0,i.kt)("p",null,"The terms (f a) and (f (g b)) are equal modulo the equalities. The pattern (f (g x)) can be matched and x bound to b (and the equality (= (f (g b)) b) is deduced."),(0,i.kt)("p",null,"While E-matching is an NP-complete problem, the main sources of overhead in larger verification problems comes from matching thousands of patterns in the context of an evolving set of terms and equalities. Z3 integrates an efficient E-matching engine using term indexing techniques."),(0,i.kt)("h3",{id:"multi-patterns"},"Multi-patterns"),(0,i.kt)("p",null,"In some cases, there is no pattern that contains all bound variables and does not contain interpreted symbols. In these cases, we use multi-patterns. In the following example, the quantified formula states that f is injective. This quantified formula is annotated with the multi-pattern (f x) (f y)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(declare-sort A)\n(declare-sort B)\n(declare-fun f (A) B)\n(assert (forall ((x A) (y A))\n                (! (= (= (f x) (f y)) (= x y))\n                   pattern ((f x) (f y))\n                   )))\n(declare-const a1 A)\n(declare-const a2 A)\n(declare-const b B)\n(assert (not (= a1 a2)))\n(assert (= (f a1) b))\n(assert (= (f a2) b))\n(check-sat)\n")),(0,i.kt)("p",null,"The quantified formula is instantiated for every pair of occurrences of f. A simple trick allows formulating injectivity of f in such a way that only a linear number of instantiations is required. The trick is to realize that f is injective if and only if it has a partial inverse."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(declare-sort A)\n(declare-sort B)\n(declare-fun f (A) B)\n(declare-fun f-inv (B) A)\n(assert (forall ((x A))\n                (! (= (f-inv (f x)) x)\n                   pattern ((f x))\n                   )))\n(declare-const a1 A)\n(declare-const a2 A)\n(declare-const b B)\n(assert (not (= a1 a2)))\n(assert (= (f a1) b))\n(assert (= (f a2) b))\n(check-sat)\n")),(0,i.kt)("h3",{id:"no-patterns"},"No patterns"),(0,i.kt)("p",null,"The annotation no-pattern can be used to instrument Z3 not to use a certain sub-expression as a pattern. The pattern inference engine may otherwise choose arbitrary sub-expressions as patterns to direct quantifier instantiation."),(0,i.kt)("h3",{id:"model-based-quantifier-instantiation"},"Model-based Quantifier Instantiation"),(0,i.kt)("p",null,"The model-based quantifier instantiation (MBQI) is essentially a counter-example based refinement loop, where candidate models are built and checked. When the model checking step fails, it creates new quantifier instantiations. The models are returned as simple functional programs. In the following example, the model provides an interpretation for function f and constants a and b. One can easily check that the returned model does indeed satisfy the quantifier."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(set-option smt.mbqi true)\n(declare-fun f (Int Int) Int)\n(declare-const a Int)\n(declare-const b Int)\n\n(assert (forall ((x Int)) (= (f x x) (+ x a))))\n\n(assert ( (f a b) a))\n(assert ( a 0))\n(check-sat)\n(get-model)\n\n(echo evaluating (f (+ a 10) 20)...)\n(eval (f (+ a 10) 20))\n")),(0,i.kt)("p",null,"The command eval evaluates an expression in the last model produced by Z3. It is essentially executing the function program produced by Z3."),(0,i.kt)("p",null,"MBQI is a decision procedure for several useful fragments. It may find models even for formulas that are not in any of these fragments. We describe some of these fragments."),(0,i.kt)("h4",{id:"effectively-propositional"},"Effectively Propositional"),(0,i.kt)("p",null,"The effectively propositional class of formulas (aka The Bernays-Schonfinkel class) is a decidable fragment of first-order logic formulas. It corresponds to formulas which, when written in prenex normal form contain only constants, universal quantifiers, and functions that return boolean values (aka predicates)."),(0,i.kt)("p",null,"Problems arising from program verification often involve establishing facts of quantifier-free formulas, but the facts themselves use relations and functions that are conveniently axiomatized using a background theory that uses quantified formulas. One set of examples of this situation comprise of formulas involving partial-orders. The following example axiomatizes a subtype partial order relation that has the tree property. That is, if x and y are subtypes of z, then x is a subtype of y or y is a subtype of x. The option (set-option model.compact true) instructs Z3 to eliminate trivial redundancies from the generated model. In this example, Z3 also creates a finite interpretation for the uninterpreted sort T."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(set-option smt.mbqi true)\n(set-option model.compact true)\n\n;; T is an uninterpreted sort\n(declare-sort T) \n\n(declare-fun subtype (T T) Bool)\n\n;; subtype is reflexive\n(assert (forall ((x T)) (subtype x x)))\n\n;; subtype is antisymmetric\n(assert (forall ((x T) (y T)) (= (and (subtype x y)\n                                       (subtype y x))\n                                       (= x y))))\n;; subtype is transitive\n(assert (forall ((x T) (y T) (z T)) (= (and (subtype x y)\n                                             (subtype y z))\n                                             (subtype x z))))\n;; subtype has the tree-property\n(assert (forall ((x T) (y T) (z T)) (= (and (subtype x z)\n                                             (subtype y z))\n                                        (or (subtype x y)\n                                            (subtype y x)))))\n\n;; now we define a simple example using the axiomatization above.\n(declare-const obj-type T)\n(declare-const int-type T)\n(declare-const real-type T)\n(declare-const complex-type T)\n(declare-const string-type T)\n\n;; we have an additional axiom every type is a subtype of obj-type\n(assert (forall ((x T)) (subtype x obj-type)))\n\n(assert (subtype int-type real-type))\n(assert (subtype real-type complex-type))\n(assert (not (subtype string-type real-type)))\n(declare-const root-type T)\n(assert (subtype obj-type root-type))\n(check-sat)\n(get-model)\n\n(echo Is int-type a subtype of complex-type)\n(eval (subtype int-type complex-type))\n(echo Is int-type = obj-type)\n(eval (= int-type obj-type))\n(echo Is int-type a subtype of root-type)\n(eval (subtype int-type root-type))\n(echo Is root-type = obj-type)\n(eval (= root-type obj-type))\n")),(0,i.kt)("p",null,"Note that it uses two auxiliary functions (subtype!25 and k!24) that were not part of your formula. They are auxiliary definitions created by Z3 during the model construction procedure. We can also ask questions by using the eval command. For example,"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"(eval (subtype int-type complex-type))")),(0,i.kt)("p",null,"executes (evaluates) the given expression using the produced functional program (model)."),(0,i.kt)("p",null,"Constraints over sets (Boolean Algebras) can be encoded into this fragment by treating sets as unary predicates and lifting equalities between sets as formula equivalence."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(set-option smt.mbqi true)\n(set-option model.compact true)\n\n;; A, B, C and D are sets of Int\n(declare-fun A (Int) Bool)\n(declare-fun B (Int) Bool)\n(declare-fun C (Int) Bool)\n(declare-fun D (Int) Bool)\n\n;; A union B is a subset of C\n(assert (forall ((x Int)) (= (or (A x) (B x)) (C x))))\n\n;; B minus A is not empty\n;; That is, there exists an integer e that is B but not in A\n(declare-const e Int)\n(assert (and (B e) (not (A e))))\n\n;; D is equal to C\n(assert (forall ((x Int)) (iff (D x) (C x))))\n\n;; 0, 1 and 2 are in B\n(assert (B 0))\n(assert (B 1))\n(assert (B 2))\n\n(check-sat)\n(get-model)\n(echo Is e an element of D)\n(eval (D e))\n\n(echo Now proving that A is a strict subset of D)\n;; This is true if the negation is unsatisfiable\n(push)\n(assert (not (and \n              ;; A is a subset of D\n              (forall ((x Int)) (= (A x) (D x)))\n              ;; but, D has an element that is not in A.\n              (exists ((x Int)) (and (D x) (not (A x)))))))\n(check-sat)\n(pop)\n")),(0,i.kt)("h4",{id:"stratified-sorts-fragment"},"Stratified Sorts Fragment"),(0,i.kt)("p",null,"The statified sorts fragment is another decidable fragment of many sorted first-order logic formulas. It corresponds to formulas which, when written in prenex normal form, there is a function level from sorts to naturals, and for every function"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"declare-fun f (S_1 ... S_n) R)"),(0,i.kt)("p",{parentName:"blockquote"},"level(R)  level(S_i).")),(0,i.kt)("h4",{id:"array-property-fragment"},"Array Property Fragment"),(0,i.kt)("p",null,"The array property fragment can encode properties about unidimensional, and is strong enough to say an array is sorted. More information about this fragment can be found in the paper ",(0,i.kt)("a",{parentName:"p",href:"httpacademic.research.microsoft.comPaper1843442.aspx"},"What's Decidable About Arrays"),"."),(0,i.kt)("p",null,"(set-option smt.mbqi true)\n(set-option model.compact true)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},";; A0, A1, A2, A3, A4 are arrays from Integers to Integers.\n(declare-fun A0 (Int) Int) (declare-fun A1 (Int) Int)\n(declare-fun A2 (Int) Int) (declare-fun A3 (Int) Int)\n(declare-fun A4 (Int) Int) \n(declare-const n Int) (declare-const l Int)\n(declare-const k Int) (declare-const x Int)\n(declare-const y Int) (declare-const w Int)\n(declare-const z Int)\n\n;; A1 = A0[k - w]\n(assert (= (A1 k) w))\n(assert (forall ((x Int)) (or (= x k) (= (A1 x) (A0 x)))))\n\n;; A2 = A1[l - x] = A0[k - w][l - x]\n(assert (= (A2 l) x))\n(assert (forall ((x Int)) (or (= x l) (= (A2 x) (A1 x)))))\n\n;; A3 = A0[k - y]\n(assert (= (A3 k) y))\n(assert (forall ((x Int)) (or (= x k) (= (A3 x) (A0 x)))))\n\n;; A4 = A3[l - z] = A0[k - y][l - z] \n(assert (= (A3 l) z))\n(assert (forall ((x Int)) (or (= x l) (= (A4 x) (A3 x)))))\n\n(assert (and ( w x) ( x y) ( y z)))\n(assert (and ( 0 k) ( k l) ( l n)))\n(assert ( (- l k) 1))\n\n;; A2 is sorted in the interval [0,n-1]\n(assert (forall ((i Int) (j Int))\n                (= (and (= 0 i) (= i j) (= j (- n 1)))\n                    (= (A2 i) (A2 j)))))\n\n(check-sat)\n(get-model)\n\n;; A4 is sorted in the interval [0,n-1]\n(assert (forall ((i Int) (j Int))\n                (= (and (= 0 i) (= i j) (= j (- n 1)))\n                    (= (A4 i) (A4 j)))))\n\n(check-sat)\n")),(0,i.kt)("h4",{id:"list-fragment"},"List Fragment"),(0,i.kt)("p",null,"The list fragment can encode properties about data-structures such as lists. For each quantified axiom q in this fragment, there is an easy way to satisfy q. More information about this fragment can be found in the paper ",(0,i.kt)("a",{parentName:"p",href:"httpwww.cs.berkeley.edu~neculaPapersverifier-cav05.pdf"},"Data Structure Specifications via Local Equality Axioms"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(set-option smt.mbqi true)\n;; Ptr is the pointer sort.\n(declare-sort Ptr)\n;; (next p) represents p.next\n;; The pointer reached by following the field next of p.\n(declare-fun next  (Ptr) Ptr)\n(declare-fun prev  (Ptr) Ptr)\n(declare-fun state (Ptr) Int)\n(declare-fun prio  (Ptr) Int)\n(declare-const null Ptr)\n(declare-const RUN  Int)\n(declare-const SLP  Int)\n(assert (distinct RUN SLP))\n\n;; Asserting data-structure invariants in the current state.\n\n;; p != null && p.next != null = p.next.prev = p\n(assert (forall ((p Ptr))\n                (= (and (not (= p null))\n                         (not (= (next p) null)))\n                    (= (prev (next p)) p))))\n\n;; p != null && p.prev != null = p.prev.next = p\n(assert (forall ((p Ptr))\n                (= (and (not (= p null))\n                         (not (= (prev p) null)))\n                    (= (next (prev p)) p))))\n\n;;  p != null && p.prev != null = p.state = p.next.state\n(assert (forall ((p Ptr))\n                (= (and (not (= p null))\n                         (not (= (next p) null)))\n                    (= (state p) (state (next p))))))\n\n;;  p != null && p.prev != null && p.state = RUN = p.prio = p.next.prio\n(assert (forall ((p Ptr))\n                (= (and (not (= p null))\n                         (not (= (next p) null))\n                         (= (state p) RUN))\n                    (= (prio p) (prio (next p))))))\n\n;; Verifying Verification Conditions (VCs) for remove procdure\n(declare-const x Ptr)\n;; new-state, new-next, new-prev and new-prio represent the state \n;; of the system after executing the remove procedure.\n(declare-fun new-state (Ptr) Int)\n(declare-fun new-next  (Ptr) Ptr)\n(declare-fun new-prev  (Ptr) Ptr)\n(declare-fun new-prio  (Ptr) Int)\n;; pre-conditions\n(assert (not (= x null)))\n(assert (not (= (prev x) null)))\n(assert (= (state x) RUN))\n;; updates\n;; --- new-prev = prev\n(assert (forall ((p Ptr)) (= (new-prev p) (prev p))))\n;; --- new-prio = prio\n(assert (forall ((p Ptr)) (= (new-prio p) (prio p))))\n;; --- new-state = state[x - SLP]\n(assert (= (new-state x) SLP))\n(assert (forall ((p Ptr)) (or (= p x) (= (new-state p) (state p)))))\n;; ----\n;; --- new-next  = next[(prev x) - (next x); x - null]\n(assert (= (new-next x) null))\n(assert (= (new-next (prev x)) (next x)))\n(assert (forall ((p Ptr)) (or (= p x) (= p (prev x)) (= (new-next p) (next p)))))\n;; ---\n\n;; Proving the data-structure invariants in the new state.\n\n(push)\n(assert (not (forall ((p Ptr))\n                     (= (and (not (= p null))\n                              (not (= (new-next p) null)))\n                         (= (new-prev (new-next p)) p)))))\n(check-sat)\n(get-model)\n(pop)\n(echo Why it is not valid)\n(echo Trying again using a fresh constant bad-ptr as an witness for the failure...)\n(push)\n(declare-const bad-ptr Ptr)\n(assert (not (= (and (not (= bad-ptr null))\n                      (not (= (new-next bad-ptr) null)))\n                 (= (new-prev (new-next bad-ptr)) bad-ptr))))\n(check-sat)\n(get-model)\n(echo null is)\n(eval null)\n(echo bad-ptr is)\n(eval bad-ptr)\n(echo In the new state, bad-ptr.next is)\n(eval (new-next bad-ptr))\n(echo In the new state, bad-ptr.next.prev is)\n(eval (new-prev (new-next bad-ptr)))\n(pop)\n")),(0,i.kt)("h4",{id:"essentially-almost-uninterpreted-fragment"},"Essentially (Almost) Uninterpreted Fragment"),(0,i.kt)("p",null,"The essentiallyalmost uninterpreted fragment subsumes the previous fragments, and uses a more relaxed notion of stratification. More information about this fragment can be found in the paper ",(0,i.kt)("a",{parentName:"p",href:"httpresearch.microsoft.comen-usumpeopleleonardoci.pdf"},"Complete instantiation for quantified formulas in Satisfiabiliby Modulo Theories.")," The model based quantifier instantiation approach used in Z3 is also described in this paper. Stratified data-structures (such as arrays of pointers) can be encoded in this fragment."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(set-option smt.mbqi true)\n;; Ptr is the pointer sort.\n(declare-sort Ptr)\n;; (next p) represents p.next\n;; The pointer reached by following the field next of p.\n(declare-fun next  (Ptr) Ptr)\n(declare-fun prev  (Ptr) Ptr)\n(declare-fun state (Ptr) Int)\n(declare-fun prio  (Ptr) Int)\n(declare-const null Ptr)\n(declare-const RUN  Int)\n(declare-const SLP  Int)\n(assert (distinct RUN SLP))\n\n;; Asserting data-structure invariants in the current state.\n\n;; p != null && p.next != null = p.next.prev = p\n(assert (forall ((p Ptr))\n                (= (and (not (= p null))\n                         (not (= (next p) null)))\n                    (= (prev (next p)) p))))\n\n;; p != null && p.prev != null = p.prev.next = p\n(assert (forall ((p Ptr))\n                (= (and (not (= p null))\n                         (not (= (prev p) null)))\n                    (= (next (prev p)) p))))\n\n;;  p != null && p.prev != null = p.state = p.next.state\n(assert (forall ((p Ptr))\n                (= (and (not (= p null))\n                         (not (= (next p) null)))\n                    (= (state p) (state (next p))))))\n\n;;  p != null && p.prev != null && p.state = RUN = p.prio = p.next.prio\n(assert (forall ((p Ptr))\n                (= (and (not (= p null))\n                         (not (= (next p) null))\n                         (= (state p) RUN))\n                    (= (prio p) (prio (next p))))))\n\n;; Verifying Verification Conditions (VCs) for remove procdure\n(declare-const x Ptr)\n;; new-state, new-next, new-prev and new-prio represent the state \n;; of the system after executing the remove procedure.\n(declare-fun new-state (Ptr) Int)\n(declare-fun new-next  (Ptr) Ptr)\n(declare-fun new-prev  (Ptr) Ptr)\n(declare-fun new-prio  (Ptr) Int)\n;; pre-conditions\n(assert (not (= x null)))\n(assert (not (= (prev x) null)))\n(assert (= (state x) RUN))\n;; updates\n;; --- new-prev = prev\n(assert (forall ((p Ptr)) (= (new-prev p) (prev p))))\n;; --- new-prio = prio\n(assert (forall ((p Ptr)) (= (new-prio p) (prio p))))\n;; --- new-state = state[x - SLP]\n(assert (= (new-state x) SLP))\n(assert (forall ((p Ptr)) (or (= p x) (= (new-state p) (state p)))))\n;; ----\n;; --- new-next  = next[(prev x) - (next x); x - null]\n(assert (= (new-next x) null))\n(assert (= (new-next (prev x)) (next x)))\n(assert (forall ((p Ptr)) (or (= p x) (= p (prev x)) (= (new-next p) (next p)))))\n;; ---\n\n;; Proving the data-structure invariants in the new state.\n\n(push)\n(assert (not (forall ((p Ptr))\n                     (= (and (not (= p null))\n                              (not (= (new-next p) null)))\n                         (= (new-prev (new-next p)) p)))))\n(check-sat)\n(get-model)\n(pop)\n(echo Why it is not valid)\n(echo Trying again using a fresh constant bad-ptr as an witness for the failure...)\n(push)\n(declare-const bad-ptr Ptr)\n(assert (not (= (and (not (= bad-ptr null))\n                      (not (= (new-next bad-ptr) null)))\n                 (= (new-prev (new-next bad-ptr)) bad-ptr))))\n(check-sat)\n(get-model)\n(echo null is)\n(eval null)\n(echo bad-ptr is)\n(eval bad-ptr)\n(echo In the new state, bad-ptr.next is)\n(eval (new-next bad-ptr))\n(echo In the new state, bad-ptr.next.prev is)\n(eval (new-prev (new-next bad-ptr)))\n(pop)\n")),(0,i.kt)("p",null,"Shifts on streams (or arrays) can also be encoded."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(set-option smt.mbqi true)\n;; f an g are streams\n(declare-fun f (Int) Int)\n(declare-fun g (Int) Int)\n\n;; the segment [a, n + a] of stream f is equal\n;; to the segment [0, n] of stream g.\n(declare-const n Int)\n(declare-const a Int)\n(assert (forall ((x Int)) (= (and (= 0 x) (= x n))\n                              (= (f (+ x a)) (g x)))))\n\n;; adding some constraints to a\n(assert ( a 10))\n(assert (= (f a) 2))\n(assert (= (g 3) (- 10)))\n\n(check-sat)\n(get-model)\n")),(0,i.kt)("h4",{id:"quantified-bit-vector-formulas"},"Quantified Bit-Vector Formulas"),(0,i.kt)("p",null,"A quantified bit-Vector formula (QBVF) is a many sorted first-order logic formula where the sort of every variable is a bit-vector sort. The QBVF satisfiability problem, is the problem of deciding whether a QBVF is satisfiable modulo the theory of bit-vectors. This problem is decidable because every universal (existental) quantifier can be expanded into a conjunction (disjunction) of potentially exponential, but finite size. A distinguishing feature in QBVF is the support for uninterpreted function and predicate symbols. More information about this fragment can be found in the paper ",(0,i.kt)("a",{parentName:"p",href:"httpresearch.microsoft.comen-usumpeopleleonardofmcad10.pdf"},"Efficiently Solving Quantified Bit-Vector Formulas"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(set-option smt.mbqi true)\n(define-sort Char () (_ BitVec 8))\n\n(declare-fun f  (Char) Char)\n(declare-fun f1 (Char) Char)\n(declare-const a Char)\n\n(assert (bvugt a #x00))\n(assert (= (f1 (bvadd a #x01)) #x00))\n(assert (forall ((x Char)) (or (= x (bvadd a #x01)) (= (f1 x) (f x)))))\n\n(check-sat)\n(get-model)\n")),(0,i.kt)("h4",{id:"conditional-and-pseudo-macros"},"Conditional (and Pseudo) Macros"),(0,i.kt)("p",null,"Quantifiers defining macros are also automatically detected by the Model Finder. In the following example, the first three quantifiers are defining f by cases."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(set-option smt.mbqi true)\n(declare-fun f (Int) Int)\n(declare-fun p (Int) Bool)\n(declare-fun p2 (Int) Bool)\n(declare-const a Int)\n(declare-const b Int)\n(declare-const c Int)\n(assert (forall ((x Int)) \n                (= (not (p x)) (= (f x) (+ x 1)))))\n(assert (forall ((x Int)) \n                (= (and (p x) (not (p2 x))) (= (f x) x))))\n(assert (forall ((x Int)) \n                (= (p2 x) (= (f x) (- x 1)))))\n(assert (p b))\n(assert (p c))\n(assert (p2 a))\n(assert ( (f a) b))\n(check-sat)\n(get-model)\n")),(0,i.kt)("h4",{id:"my-formula-is-not-in-any-of-the-fragments-above"},"My formula is not in any of the fragments above"),(0,i.kt)("p",null,"Even if your formula is not in any of the fragments above. Z3 may still find a model for it. For example, The following simple example is not in the fragments described above."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(set-option smt.mbqi true)\n(declare-fun n () Int)\n(declare-fun a_1 () Int)\n(declare-fun f (Int) Int)\n(declare-fun g_1 (Int) Int)\n(assert ( n 0))\n(assert (forall ((i Int))\n        (= (and (= 0 i) (= i n))\n            (and (= (f 0) 0)\n                 (= (f 2) 2)\n                 (= 0 (f i))\n                 (= (f i) 2)\n                 (= (= (f i) 2) (= i n))\n                 (= (= (f i) 0)\n                     (or (= (f (+ i 1)) 1) (= (f (+ i 1)) 2)))\n                 (= (= (f i) 1)\n                     (or (= (f (+ i 1)) 1) (= (f (+ i 1)) 2)))\n                 (= (g_1 0) 0)\n                 (= (= (f i) 0) (= (g_1 (+ i 1)) 0))\n                 (= (= (f i) 1) (= (g_1 (+ i 1)) (+ (g_1 i) 1)))\n                 (= (= (f i) 2)\n                     (= (g_1 (+ i 1)) (g_1 i)))\n                 (= (= (f i) 1) ( (g_1 i) a_1))\n                 (= (= (f i) 2) \n                     (and (= (g_1 i) a_1) ( (g_1 i) 2)))))))\n(check-sat)\n(get-model)\n\n(echo Property does not hold for n  1)\n(assert ( n 1))\n(check-sat)\n")),(0,i.kt)("p",null,"The Z3 preprocessor has many options that may improve the performace of the model finder. In the following example, macro-finder will expand quantifiers representing macros at preprocessing time."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(set-option smt.mbqi true)\n(set-option smt.macro-finder true)\n\n(declare-sort Action)\n(declare-sort Role)\n(declare-sort Permission)\n(declare-sort Id)\n\n(declare-fun Client () Role)  \n(declare-fun FinAdmin () Role)\n(declare-fun FinClerk () Role)\n(declare-fun Manager () Role)\n(declare-fun POAdmin () Role)\n(declare-fun POClerk () Role)\n(declare-fun action2int (Action) Int)\n(declare-fun id1 () Id)\n(declare-fun id2 () Id)\n(declare-fun id2int (Id) Int)\n(declare-fun id3 () Id)\n(declare-fun id4 () Id)\n(declare-fun id5 () Id)\n(declare-fun id6 () Id)\n(declare-fun id7 () Id)\n(declare-fun p1 () Permission)\n(declare-fun p2 () Permission)\n(declare-fun p3 () Permission)\n(declare-fun p4 () Permission)\n(declare-fun p5 () Permission)\n(declare-fun p6 () Permission)\n(declare-fun permission2int (Permission) Int)\n(declare-fun role2int (Role) Int)\n(declare-fun role_level (Role) Int)\n(declare-fun t1_receive () Action)\n(declare-fun t2_invoke () Action)\n(declare-fun t3_split () Action)\n(declare-fun t4_join () Action)\n(declare-fun t5_invoke () Action)\n(declare-fun t6_invoke () Action)\n(declare-fun t7_invokeO () Action)\n(declare-fun t8_invokeI () Action)\n(declare-fun t9_invoke () Action)\n(declare-fun in_creator_ctrPay_0 () Int)\n(declare-fun in_creator_ctrPay_1 () Int)\n(declare-fun in_customer_crtPO_0 () Int)\n(declare-fun in_customer_crtPO_1 () Int)\n(declare-fun out_approverPOPayment_apprPay_0 () Int)\n(declare-fun out_approverPOPayment_apprPay_1 () Int)\n(declare-fun out_approverPO_apprPO_0 () Int)\n(declare-fun out_approverPO_apprPO_1 () Int)\n(declare-fun out_creator_ctrPay_0 () Int)\n(declare-fun out_creator_ctrPay_1 () Int)\n(declare-fun out_signerGRN_ctrsignGRN_0 () Int)\n(declare-fun out_signerGRN_ctrsignGRN_1 () Int)\n(declare-fun out_signerGRN_signGRN_0 () Int)\n(declare-fun out_signerGRN_signGRN_1 () Int)\n(declare-fun p10_final_0 () Int)\n(declare-fun p10_final_1 () Int)\n(declare-fun p11_final_0 () Int)\n(declare-fun p11_final_1 () Int)\n(declare-fun p1_final_0 () Int)\n(declare-fun p1_final_1 () Int)\n(declare-fun p2_final_0 () Int)\n(declare-fun p2_final_1 () Int)\n(declare-fun p3_running_0 () Int)\n(declare-fun p3_running_1 () Int)\n(declare-fun p4_final_0 () Int)\n(declare-fun p4_final_1 () Int)\n(declare-fun p5_final_0 () Int)\n(declare-fun p5_final_1 () Int)\n(declare-fun p6_initial_0 () Int)\n(declare-fun p6_initial_1 () Int)\n(declare-fun p7_final_0 () Int)\n(declare-fun p7_final_1 () Int)\n(declare-fun p8_initial_0 () Int)\n(declare-fun p8_initial_1 () Int)\n(declare-fun p9_initial_0 () Int)\n(declare-fun p9_initial_1 () Int)\n\n\n;PREDICATES\n\n(declare-fun has_permission (Id Action) Bool)\n(declare-fun permission (Permission Action) Bool)\n(declare-fun role (Role) Bool)\n(declare-fun role_le (Role Role) Bool)\n(declare-fun role_permission_assign (Role Permission) Bool)\n(declare-fun user (Id) Bool)\n(declare-fun user_role_assign (Id Role) Bool)\n(declare-fun can_exec_0 (Id Action) Bool)\n(declare-fun can_exec_1 (Id Action) Bool)\n(declare-fun executed_0 (Id Action) Bool) \n(declare-fun executed_1 (Id Action) Bool)\n(declare-fun initial_pm_0 () Bool)\n(declare-fun initial_wf_0 () Bool)\n(declare-fun t1_receive_0_1 (Id) Bool)\n(declare-fun t2_invoke_0_1 (Id) Bool)\n(declare-fun t3_split_0_1 (Id) Bool)\n(declare-fun t4_join_0_1 (Id) Bool)\n(declare-fun t5_invoke_0_1 (Id) Bool)\n(declare-fun t6_invoke_0_1 (Id) Bool)\n(declare-fun t7_invokeO_0_1 (Id) Bool)\n(declare-fun t8_invokeI_0_1 (Id) Bool)\n(declare-fun t9_invoke_0_1 (Id) Bool)\n\n(assert\n(forall ((U Action) (V Action)) (implies (= (action2int U) (action2int V)) (= U V))))\n \n\n;assumption 2\n(assert\n(forall ((U Action)) (and (= 1 (action2int U)) (= (action2int U) 9))))\n \n\n;assumption 3\n(assert\n(= (action2int t1_receive) 1))\n\n;assumption 4\n(assert\n(= (action2int t2_invoke) 2))\n\n;assumption 5\n(assert\n(= (action2int t3_split) 3))\n\n;assumption 6\n(assert\n(= (action2int t4_join) 4))\n\n;assumption 7\n(assert\n(= (action2int t5_invoke) 5))\n\n;assumption 8\n(assert\n(= (action2int t6_invoke) 6))\n\n;assumption 9\n(assert\n(= (action2int t7_invokeO) 7))\n\n;assumption 10\n(assert\n(= (action2int t8_invokeI) 8))\n\n;assumption 11\n(assert\n(= (action2int t9_invoke) 9))\n\n;assumption 12\n(assert\n(forall ((U Role) (V Role)) (implies (= (role2int U) (role2int V)) (= U V))))\n \n\n;assumption 13\n(assert\n(forall ((U Role)) (and (= 1 (role2int U)) (= (role2int U) 6))))\n \n\n;assumption 14\n(assert\n(= (role2int Manager) 1))\n\n;assumption 15\n(assert\n(= (role2int FinAdmin) 2))\n\n;assumption 16\n(assert\n(= (role2int FinClerk) 3))\n\n;assumption 17\n(assert\n(= (role2int POAdmin) 4))\n\n;assumption 18\n(assert\n(= (role2int POClerk) 5))\n\n;assumption 19\n(assert\n(= (role2int Client) 6))\n\n;assumption 20\n(assert\n(forall ((U Permission) (V Permission)) (implies (= (permission2int U) (permission2int V)) (= U V))))\n \n\n;assumption 21\n(assert\n(forall ((U Permission)) (and (= 1 (permission2int U)) (= (permission2int U) 6))))\n \n\n;assumption 22\n(assert\n(= (permission2int p1) 1))\n\n;assumption 23\n(assert\n(= (permission2int p2) 2))\n\n;assumption 24\n(assert\n(= (permission2int p3) 3))\n\n;assumption 25\n(assert\n(= (permission2int p4) 4))\n\n;assumption 26\n(assert\n(= (permission2int p5) 5))\n\n;assumption 27\n(assert\n(= (permission2int p6) 6))\n\n;assumption 28\n(assert\n(forall ((U Permission) (V Action)) (iff (permission U V) (or (and (= U p1) (= V t2_invoke)) (or (and (= U p2) (= V t5_invoke)) (or (and (= U p3) (= V t6_invoke)) (or (and (= U p4) (or (= V t7_invokeO) (= V t8_invokeI))) (or (and (= U p5) (= V t9_invoke)) (and (= U p6) (= V t1_receive))))))))))\n \n\n;assumption 29\n(assert\n(forall ((U Id) (V Role)) (iff (user_role_assign U V) (or (and (= U id7) (= V Manager)) (or (and (= U id1) (= V Manager)) (or (and (= U id2) (= V FinAdmin)) (or (and (= U id3) (= V FinClerk)) (or (and (= U id4) (= V POAdmin)) (or (and (= U id5) (= V POClerk)) (and (= U id6) (= V Client)))))))))))\n \n\n;assumption 30\n(assert\n(forall ((U Role) (V Permission)) (iff (role_permission_assign U V) (or (and (= U POClerk) (= V p3)) (or (and (= U FinClerk) (= V p4)) (or (and (= U POAdmin) (or (= V p1) (= V p3))) (or (and (= U FinAdmin) (or (= V p5) (= V p4))) (or (and (= U Client) (or (= V p6) (= V p2))) (and (= U Manager) (or (= V p1) (or (= V p3) (or (= V p4) (= V p5)))))))))))))\n \n\n;assumption 31\n(assert\n(forall ((U Id) (V Action)) (iff (has_permission U V) (or (and (user_role_assign U Manager) (and (role_permission_assign Manager p1) (permission p1 V))) (or (and (user_role_assign U Manager) (and (role_permission_assign Manager p2) (permission p2 V))) (or (and (user_role_assign U Manager) (and (role_permission_assign Manager p3) (permission p3 V))) (or (and (user_role_assign U Manager) (and (role_permission_assign Manager p4) (permission p4 V))) (or (and (user_role_assign U Manager) (and (role_permission_assign Manager p5) (permission p5 V))) (or (and (user_role_assign U Manager) (and (role_permission_assign Manager p6) (permission p6 V))) (or (and (user_role_assign U POClerk) (and (role_permission_assign POClerk p1) (permission p1 V))) (or (and (user_role_assign U POClerk) (and (role_permission_assign POClerk p2) (permission p2 V))) (or (and (user_role_assign U POClerk) (and (role_permission_assign POClerk p3) (permission p3 V))) (or (and (user_role_assign U POClerk) (and (role_permission_assign POClerk p4) (permission p4 V))) (or (and (user_role_assign U POClerk) (and (role_permission_assign POClerk p5) (permission p5 V))) (or (and (user_role_assign U POClerk) (and (role_permission_assign POClerk p6) (permission p6 V))) (or (and (user_role_assign U FinClerk) (and (role_permission_assign FinClerk p1) (permission p1 V))) (or (and (user_role_assign U FinClerk) (and (role_permission_assign FinClerk p2) (permission p2 V))) (or (and (user_role_assign U FinClerk) (and (role_permission_assign FinClerk p3) (permission p3 V))) (or (and (user_role_assign U FinClerk) (and (role_permission_assign FinClerk p4) (permission p4 V))) (or (and (user_role_assign U FinClerk) (and (role_permission_assign FinClerk p5) (permission p5 V))) (or (and (user_role_assign U FinClerk) (and (role_permission_assign FinClerk p6) (permission p6 V))) (or (and (user_role_assign U FinAdmin) (and (role_permission_assign FinAdmin p1) (permission p1 V))) (or (and (user_role_assign U FinAdmin) (and (role_permission_assign FinAdmin p2) (permission p2 V))) (or (and (user_role_assign U FinAdmin) (and (role_permission_assign FinAdmin p3) (permission p3 V))) (or (and (user_role_assign U FinAdmin) (and (role_permission_assign FinAdmin p4) (permission p4 V))) (or (and (user_role_assign U FinAdmin) (and (role_permission_assign FinAdmin p5) (permission p5 V))) (or (and (user_role_assign U FinAdmin) (and (role_permission_assign FinAdmin p6) (permission p6 V))) (or (and (user_role_assign U POAdmin) (and (role_permission_assign POAdmin p1) (permission p1 V))) (or (and (user_role_assign U POAdmin) (and (role_permission_assign POAdmin p2) (permission p2 V))) (or (and (user_role_assign U POAdmin) (and (role_permission_assign POAdmin p3) (permission p3 V))) (or (and (user_role_assign U POAdmin) (and (role_permission_assign POAdmin p4) (permission p4 V))) (or (and (user_role_assign U POAdmin) (and (role_permission_assign POAdmin p5) (permission p5 V))) (or (and (user_role_assign U POAdmin) (and (role_permission_assign POAdmin p6) (permission p6 V))) (or (and (user_role_assign U Client) (and (role_permission_assign Client p1) (permission p1 V))) (or (and (user_role_assign U Client) (and (role_permission_assign Client p2) (permission p2 V))) (or (and (user_role_assign U Client) (and (role_permission_assign Client p3) (permission p3 V))) (or (and (user_role_assign U Client) (and (role_permission_assign Client p4) (permission p4 V))) (or (and (user_role_assign U Client) (and (role_permission_assign Client p5) (permission p5 V))) (and (user_role_assign U Client) (and (role_permission_assign Client p6) (permission p6 V)))))))))))))))))))))))))))))))))))))))))\n \n\n;assumption 32\n(assert\n(forall ((U Role) (V Role)) (iff (role_le U V) ( (role_level U) (role_level V)))))\n \n\n;assumption 33\n(assert\n(= (role_level Manager) 3))\n\n;assumption 34\n(assert\n(= (role_level FinAdmin) 2))\n\n;assumption 35\n(assert\n(= (role_level FinClerk) 1))\n\n;assumption 36\n(assert\n(= (role_level POAdmin) 2))\n\n;assumption 37\n(assert\n(= (role_level POClerk) 1))\n\n;assumption 38\n(assert\n(= (role_level Client) 0))\n\n;assumption 39\n(assert\n(forall ((U Id) (V Id)) (implies (= (id2int U) (id2int V)) (= U V))))\n \n\n;assumption 40\n(assert\n(forall ((U Id)) (and (= 1 (id2int U)) (= (id2int U) 7))))\n \n\n;assumption 41\n(assert\n(= (id2int id1) 1))\n\n;assumption 42\n(assert\n(= (id2int id2) 2))\n\n;assumption 43\n(assert\n(= (id2int id3) 3))\n\n;assumption 44\n(assert\n(= (id2int id4) 4))\n\n;assumption 45\n(assert\n(= (id2int id5) 5))\n\n;assumption 46\n(assert\n(= (id2int id6) 6))\n\n;assumption 47\n(assert\n(= (id2int id7) 7))\n\n;assumption 48\n(assert\n(iff initial_wf_0 (and (= p1_final_0 0) (and (= p2_final_0 0) (and (= p3_running_0 0) (and (= p4_final_0 0) (and (= p5_final_0 0) (and (= p6_initial_0 0) (and (= p7_final_0 0) (and (= p8_initial_0 0) (and (= p9_initial_0 1) (and (= p10_final_0 0) (and (= p11_final_0 0) (and (= in_customer_crtPO_0 1) (and (= in_creator_ctrPay_0 1) (and (= out_approverPO_apprPO_0 0) (and (= out_approverPOPayment_apprPay_0 0) (and (= out_creator_ctrPay_0 0) (and (= out_signerGRN_ctrsignGRN_0 0) (= out_signerGRN_signGRN_0 0))))))))))))))))))))\n\n;assumption 49\n(assert\n(iff initial_pm_0 (forall ((U Id) (V Action)) (iff (executed_0 U V) false))\n ))\n\n;assumption 50\n(assert\n(forall ((U Id) (V Action)) (iff (can_exec_0 U V) (or (and (= V t5_invoke) (and (has_permission U t5_invoke) (or (and (not (= U id1)) (executed_0 id1 t2_invoke)) (or (and (not (= U id2)) (executed_0 id2 t2_invoke)) (or (and (not (= U id3)) (executed_0 id3 t2_invoke)) (or (and (not (= U id4)) (executed_0 id4 t2_invoke)) (or (and (not (= U id5)) (executed_0 id5 t2_invoke)) (or (and (not (= U id6)) (executed_0 id6 t2_invoke)) (and (not (= U id7)) (executed_0 id7 t2_invoke)))))))))) (or (and (= V t6_invoke) (and (and (has_permission U t6_invoke) (or (and (not (= U id1)) (executed_0 id1 t2_invoke)) (or (and (not (= U id2)) (executed_0 id2 t2_invoke)) (or (and (not (= U id3)) (executed_0 id3 t2_invoke)) (or (and (not (= U id4)) (executed_0 id4 t2_invoke)) (or (and (not (= U id5)) (executed_0 id5 t2_invoke)) (or (and (not (= U id6)) (executed_0 id6 t2_invoke)) (and (not (= U id7)) (executed_0 id7 t2_invoke))))))))) (and (has_permission U t6_invoke) (or (and (not (= U id1)) (executed_0 id1 t5_invoke)) (or (and (not (= U id2)) (executed_0 id2 t5_invoke)) (or (and (not (= U id3)) (executed_0 id3 t5_invoke)) (or (and (not (= U id4)) (executed_0 id4 t5_invoke)) (or (and (not (= U id5)) (executed_0 id5 t5_invoke)) (or (and (not (= U id6)) (executed_0 id6 t5_invoke)) (and (not (= U id7)) (executed_0 id7 t5_invoke))))))))))) (or (and (= V t9_invoke) (and (has_permission U t9_invoke) (exists ((W Role))  (and (user_role_assign U W) (and (or (and (user_role_assign id1 Manager) (and (role_le Manager W) (executed_0 id1 t7_invokeO))) (or (and (user_role_assign id2 Manager) (and (role_le Manager W) (executed_0 id2 t7_invokeO))) (or (and (user_role_assign id3 Manager) (and (role_le Manager W) (executed_0 id3 t7_invokeO))) (or (and (user_role_assign id4 Manager) (and (role_le Manager W) (executed_0 id4 t7_invokeO))) (or (and (user_role_assign id5 Manager) (and (role_le Manager W) (executed_0 id5 t7_invokeO))) (or (and (user_role_assign id6 Manager) (and (role_le Manager W) (executed_0 id6 t7_invokeO))) (or (and (user_role_assign id7 Manager) (and (role_le Manager W) (executed_0 id7 t7_invokeO))) (or (and (user_role_assign id1 POClerk) (and (role_le POClerk W) (executed_0 id1 t7_invokeO))) (or (and (user_role_assign id2 POClerk) (and (role_le POClerk W) (executed_0 id2 t7_invokeO))) (or (and (user_role_assign id3 POClerk) (and (role_le POClerk W) (executed_0 id3 t7_invokeO))) (or (and (user_role_assign id4 POClerk) (and (role_le POClerk W) (executed_0 id4 t7_invokeO))) (or (and (user_role_assign id5 POClerk) (and (role_le POClerk W) (executed_0 id5 t7_invokeO))) (or (and (user_role_assign id6 POClerk) (and (role_le POClerk W) (executed_0 id6 t7_invokeO))) (or (and (user_role_assign id7 POClerk) (and (role_le POClerk W) (executed_0 id7 t7_invokeO))) (or (and (user_role_assign id1 FinClerk) (and (role_le FinClerk W) (executed_0 id1 t7_invokeO))) (or (and (user_role_assign id2 FinClerk) (and (role_le FinClerk W) (executed_0 id2 t7_invokeO))) (or (and (user_role_assign id3 FinClerk) (and (role_le FinClerk W) (executed_0 id3 t7_invokeO))) (or (and (user_role_assign id4 FinClerk) (and (role_le FinClerk W) (executed_0 id4 t7_invokeO))) (or (and (user_role_assign id5 FinClerk) (and (role_le FinClerk W) (executed_0 id5 t7_invokeO))) (or (and (user_role_assign id6 FinClerk) (and (role_le FinClerk W) (executed_0 id6 t7_invokeO))) (or (and (user_role_assign id7 FinClerk) (and (role_le FinClerk W) (executed_0 id7 t7_invokeO))) (or (and (user_role_assign id1 FinAdmin) (and (role_le FinAdmin W) (executed_0 id1 t7_invokeO))) (or (and (user_role_assign id2 FinAdmin) (and (role_le FinAdmin W) (executed_0 id2 t7_invokeO))) (or (and (user_role_assign id3 FinAdmin) (and (role_le FinAdmin W) (executed_0 id3 t7_invokeO))) (or (and (user_role_assign id4 FinAdmin) (and (role_le FinAdmin W) (executed_0 id4 t7_invokeO))) (or (and (user_role_assign id5 FinAdmin) (and (role_le FinAdmin W) (executed_0 id5 t7_invokeO))) (or (and (user_role_assign id6 FinAdmin) (and (role_le FinAdmin W) (executed_0 id6 t7_invokeO))) (or (and (user_role_assign id7 FinAdmin) (and (role_le FinAdmin W) (executed_0 id7 t7_invokeO))) (or (and (user_role_assign id1 POAdmin) (and (role_le POAdmin W) (executed_0 id1 t7_invokeO))) (or (and (user_role_assign id2 POAdmin) (and (role_le POAdmin W) (executed_0 id2 t7_invokeO))) (or (and (user_role_assign id3 POAdmin) (and (role_le POAdmin W) (executed_0 id3 t7_invokeO))) (or (and (user_role_assign id4 POAdmin) (and (role_le POAdmin W) (executed_0 id4 t7_invokeO))) (or (and (user_role_assign id5 POAdmin) (and (role_le POAdmin W) (executed_0 id5 t7_invokeO))) (or (and (user_role_assign id6 POAdmin) (and (role_le POAdmin W) (executed_0 id6 t7_invokeO))) (or (and (user_role_assign id7 POAdmin) (and (role_le POAdmin W) (executed_0 id7 t7_invokeO))) (or (and (user_role_assign id1 Client) (and (role_le Client W) (executed_0 id1 t7_invokeO))) (or (and (user_role_assign id2 Client) (and (role_le Client W) (executed_0 id2 t7_invokeO))) (or (and (user_role_assign id3 Client) (and (role_le Client W) (executed_0 id3 t7_invokeO))) (or (and (user_role_assign id4 Client) (and (role_le Client W) (executed_0 id4 t7_invokeO))) (or (and (user_role_assign id5 Client) (and (role_le Client W) (executed_0 id5 t7_invokeO))) (or (and (user_role_assign id6 Client) (and (role_le Client W) (executed_0 id6 t7_invokeO))) (and (user_role_assign id7 Client) (and (role_le Client W) (executed_0 id7 t7_invokeO)))))))))))))))))))))))))))))))))))))))))))) (or (and (user_role_assign id1 Manager) (and (role_le Manager W) (executed_0 id1 t8_invokeI))) (or (and (user_role_assign id2 Manager) (and (role_le Manager W) (executed_0 id2 t8_invokeI))) (or (and (user_role_assign id3 Manager) (and (role_le Manager W) (executed_0 id3 t8_invokeI))) (or (and (user_role_assign id4 Manager) (and (role_le Manager W) (executed_0 id4 t8_invokeI))) (or (and (user_role_assign id5 Manager) (and (role_le Manager W) (executed_0 id5 t8_invokeI))) (or (and (user_role_assign id6 Manager) (and (role_le Manager W) (executed_0 id6 t8_invokeI))) (or (and (user_role_assign id7 Manager) (and (role_le Manager W) (executed_0 id7 t8_invokeI))) (or (and (user_role_assign id1 POClerk) (and (role_le POClerk W) (executed_0 id1 t8_invokeI))) (or (and (user_role_assign id2 POClerk) (and (role_le POClerk W) (executed_0 id2 t8_invokeI))) (or (and (user_role_assign id3 POClerk) (and (role_le POClerk W) (executed_0 id3 t8_invokeI))) (or (and (user_role_assign id4 POClerk) (and (role_le POClerk W) (executed_0 id4 t8_invokeI))) (or (and (user_role_assign id5 POClerk) (and (role_le POClerk W) (executed_0 id5 t8_invokeI))) (or (and (user_role_assign id6 POClerk) (and (role_le POClerk W) (executed_0 id6 t8_invokeI))) (or (and (user_role_assign id7 POClerk) (and (role_le POClerk W) (executed_0 id7 t8_invokeI))) (or (and (user_role_assign id1 FinClerk) (and (role_le FinClerk W) (executed_0 id1 t8_invokeI))) (or (and (user_role_assign id2 FinClerk) (and (role_le FinClerk W) (executed_0 id2 t8_invokeI))) (or (and (user_role_assign id3 FinClerk) (and (role_le FinClerk W) (executed_0 id3 t8_invokeI))) (or (and (user_role_assign id4 FinClerk) (and (role_le FinClerk W) (executed_0 id4 t8_invokeI))) (or (and (user_role_assign id5 FinClerk) (and (role_le FinClerk W) (executed_0 id5 t8_invokeI))) (or (and (user_role_assign id6 FinClerk) (and (role_le FinClerk W) (executed_0 id6 t8_invokeI))) (or (and (user_role_assign id7 FinClerk) (and (role_le FinClerk W) (executed_0 id7 t8_invokeI))) (or (and (user_role_assign id1 FinAdmin) (and (role_le FinAdmin W) (executed_0 id1 t8_invokeI))) (or (and (user_role_assign id2 FinAdmin) (and (role_le FinAdmin W) (executed_0 id2 t8_invokeI))) (or (and (user_role_assign id3 FinAdmin) (and (role_le FinAdmin W) (executed_0 id3 t8_invokeI))) (or (and (user_role_assign id4 FinAdmin) (and (role_le FinAdmin W) (executed_0 id4 t8_invokeI))) (or (and (user_role_assign id5 FinAdmin) (and (role_le FinAdmin W) (executed_0 id5 t8_invokeI))) (or (and (user_role_assign id6 FinAdmin) (and (role_le FinAdmin W) (executed_0 id6 t8_invokeI))) (or (and (user_role_assign id7 FinAdmin) (and (role_le FinAdmin W) (executed_0 id7 t8_invokeI))) (or (and (user_role_assign id1 POAdmin) (and (role_le POAdmin W) (executed_0 id1 t8_invokeI))) (or (and (user_role_assign id2 POAdmin) (and (role_le POAdmin W) (executed_0 id2 t8_invokeI))) (or (and (user_role_assign id3 POAdmin) (and (role_le POAdmin W) (executed_0 id3 t8_invokeI))) (or (and (user_role_assign id4 POAdmin) (and (role_le POAdmin W) (executed_0 id4 t8_invokeI))) (or (and (user_role_assign id5 POAdmin) (and (role_le POAdmin W) (executed_0 id5 t8_invokeI))) (or (and (user_role_assign id6 POAdmin) (and (role_le POAdmin W) (executed_0 id6 t8_invokeI))) (or (and (user_role_assign id7 POAdmin) (and (role_le POAdmin W) (executed_0 id7 t8_invokeI))) (or (and (user_role_assign id1 Client) (and (role_le Client W) (executed_0 id1 t8_invokeI))) (or (and (user_role_assign id2 Client) (and (role_le Client W) (executed_0 id2 t8_invokeI))) (or (and (user_role_assign id3 Client) (and (role_le Client W) (executed_0 id3 t8_invokeI))) (or (and (user_role_assign id4 Client) (and (role_le Client W) (executed_0 id4 t8_invokeI))) (or (and (user_role_assign id5 Client) (and (role_le Client W) (executed_0 id5 t8_invokeI))) (or (and (user_role_assign id6 Client) (and (role_le Client W) (executed_0 id6 t8_invokeI))) (and (user_role_assign id7 Client) (and (role_le Client W) (executed_0 id7 t8_invokeI))))))))))))))))))))))))))))))))))))))))))))) )) )) (or (and (= V t1_receive) (has_permission U t1_receive)) (or (and (= V t2_invoke) (has_permission U t2_invoke)) (or (and (= V t7_invokeO) (has_permission U t7_invokeO)) (and (= V t8_invokeI) (has_permission U t8_invokeI)))))))))))\n \n\n;assumption 51\n(assert\n(forall ((U Id) (V Action)) (iff (can_exec_1 U V) (or (and (= V t5_invoke) (and (has_permission U t5_invoke) (or (and (not (= U id1)) (executed_1 id1 t2_invoke)) (or (and (not (= U id2)) (executed_1 id2 t2_invoke)) (or (and (not (= U id3)) (executed_1 id3 t2_invoke)) (or (and (not (= U id4)) (executed_1 id4 t2_invoke)) (or (and (not (= U id5)) (executed_1 id5 t2_invoke)) (or (and (not (= U id6)) (executed_1 id6 t2_invoke)) (and (not (= U id7)) (executed_1 id7 t2_invoke)))))))))) (or (and (= V t6_invoke) (and (and (has_permission U t6_invoke) (or (and (not (= U id1)) (executed_1 id1 t2_invoke)) (or (and (not (= U id2)) (executed_1 id2 t2_invoke)) (or (and (not (= U id3)) (executed_1 id3 t2_invoke)) (or (and (not (= U id4)) (executed_1 id4 t2_invoke)) (or (and (not (= U id5)) (executed_1 id5 t2_invoke)) (or (and (not (= U id6)) (executed_1 id6 t2_invoke)) (and (not (= U id7)) (executed_1 id7 t2_invoke))))))))) (and (has_permission U t6_invoke) (or (and (not (= U id1)) (executed_1 id1 t5_invoke)) (or (and (not (= U id2)) (executed_1 id2 t5_invoke)) (or (and (not (= U id3)) (executed_1 id3 t5_invoke)) (or (and (not (= U id4)) (executed_1 id4 t5_invoke)) (or (and (not (= U id5)) (executed_1 id5 t5_invoke)) (or (and (not (= U id6)) (executed_1 id6 t5_invoke)) (and (not (= U id7)) (executed_1 id7 t5_invoke))))))))))) (or (and (= V t9_invoke) (and (has_permission U t9_invoke) (exists ((W Role))  (and (user_role_assign U W) (and (or (and (user_role_assign id1 Manager) (and (role_le Manager W) (executed_1 id1 t7_invokeO))) (or (and (user_role_assign id2 Manager) (and (role_le Manager W) (executed_1 id2 t7_invokeO))) (or (and (user_role_assign id3 Manager) (and (role_le Manager W) (executed_1 id3 t7_invokeO))) (or (and (user_role_assign id4 Manager) (and (role_le Manager W) (executed_1 id4 t7_invokeO))) (or (and (user_role_assign id5 Manager) (and (role_le Manager W) (executed_1 id5 t7_invokeO))) (or (and (user_role_assign id6 Manager) (and (role_le Manager W) (executed_1 id6 t7_invokeO))) (or (and (user_role_assign id7 Manager) (and (role_le Manager W) (executed_1 id7 t7_invokeO))) (or (and (user_role_assign id1 POClerk) (and (role_le POClerk W) (executed_1 id1 t7_invokeO))) (or (and (user_role_assign id2 POClerk) (and (role_le POClerk W) (executed_1 id2 t7_invokeO))) (or (and (user_role_assign id3 POClerk) (and (role_le POClerk W) (executed_1 id3 t7_invokeO))) (or (and (user_role_assign id4 POClerk) (and (role_le POClerk W) (executed_1 id4 t7_invokeO))) (or (and (user_role_assign id5 POClerk) (and (role_le POClerk W) (executed_1 id5 t7_invokeO))) (or (and (user_role_assign id6 POClerk) (and (role_le POClerk W) (executed_1 id6 t7_invokeO))) (or (and (user_role_assign id7 POClerk) (and (role_le POClerk W) (executed_1 id7 t7_invokeO))) (or (and (user_role_assign id1 FinClerk) (and (role_le FinClerk W) (executed_1 id1 t7_invokeO))) (or (and (user_role_assign id2 FinClerk) (and (role_le FinClerk W) (executed_1 id2 t7_invokeO))) (or (and (user_role_assign id3 FinClerk) (and (role_le FinClerk W) (executed_1 id3 t7_invokeO))) (or (and (user_role_assign id4 FinClerk) (and (role_le FinClerk W) (executed_1 id4 t7_invokeO))) (or (and (user_role_assign id5 FinClerk) (and (role_le FinClerk W) (executed_1 id5 t7_invokeO))) (or (and (user_role_assign id6 FinClerk) (and (role_le FinClerk W) (executed_1 id6 t7_invokeO))) (or (and (user_role_assign id7 FinClerk) (and (role_le FinClerk W) (executed_1 id7 t7_invokeO))) (or (and (user_role_assign id1 FinAdmin) (and (role_le FinAdmin W) (executed_1 id1 t7_invokeO))) (or (and (user_role_assign id2 FinAdmin) (and (role_le FinAdmin W) (executed_1 id2 t7_invokeO))) (or (and (user_role_assign id3 FinAdmin) (and (role_le FinAdmin W) (executed_1 id3 t7_invokeO))) (or (and (user_role_assign id4 FinAdmin) (and (role_le FinAdmin W) (executed_1 id4 t7_invokeO))) (or (and (user_role_assign id5 FinAdmin) (and (role_le FinAdmin W) (executed_1 id5 t7_invokeO))) (or (and (user_role_assign id6 FinAdmin) (and (role_le FinAdmin W) (executed_1 id6 t7_invokeO))) (or (and (user_role_assign id7 FinAdmin) (and (role_le FinAdmin W) (executed_1 id7 t7_invokeO))) (or (and (user_role_assign id1 POAdmin) (and (role_le POAdmin W) (executed_1 id1 t7_invokeO))) (or (and (user_role_assign id2 POAdmin) (and (role_le POAdmin W) (executed_1 id2 t7_invokeO))) (or (and (user_role_assign id3 POAdmin) (and (role_le POAdmin W) (executed_1 id3 t7_invokeO))) (or (and (user_role_assign id4 POAdmin) (and (role_le POAdmin W) (executed_1 id4 t7_invokeO))) (or (and (user_role_assign id5 POAdmin) (and (role_le POAdmin W) (executed_1 id5 t7_invokeO))) (or (and (user_role_assign id6 POAdmin) (and (role_le POAdmin W) (executed_1 id6 t7_invokeO))) (or (and (user_role_assign id7 POAdmin) (and (role_le POAdmin W) (executed_1 id7 t7_invokeO))) (or (and (user_role_assign id1 Client) (and (role_le Client W) (executed_1 id1 t7_invokeO))) (or (and (user_role_assign id2 Client) (and (role_le Client W) (executed_1 id2 t7_invokeO))) (or (and (user_role_assign id3 Client) (and (role_le Client W) (executed_1 id3 t7_invokeO))) (or (and (user_role_assign id4 Client) (and (role_le Client W) (executed_1 id4 t7_invokeO))) (or (and (user_role_assign id5 Client) (and (role_le Client W) (executed_1 id5 t7_invokeO))) (or (and (user_role_assign id6 Client) (and (role_le Client W) (executed_1 id6 t7_invokeO))) (and (user_role_assign id7 Client) (and (role_le Client W) (executed_1 id7 t7_invokeO)))))))))))))))))))))))))))))))))))))))))))) (or (and (user_role_assign id1 Manager) (and (role_le Manager W) (executed_1 id1 t8_invokeI))) (or (and (user_role_assign id2 Manager) (and (role_le Manager W) (executed_1 id2 t8_invokeI))) (or (and (user_role_assign id3 Manager) (and (role_le Manager W) (executed_1 id3 t8_invokeI))) (or (and (user_role_assign id4 Manager) (and (role_le Manager W) (executed_1 id4 t8_invokeI))) (or (and (user_role_assign id5 Manager) (and (role_le Manager W) (executed_1 id5 t8_invokeI))) (or (and (user_role_assign id6 Manager) (and (role_le Manager W) (executed_1 id6 t8_invokeI))) (or (and (user_role_assign id7 Manager) (and (role_le Manager W) (executed_1 id7 t8_invokeI))) (or (and (user_role_assign id1 POClerk) (and (role_le POClerk W) (executed_1 id1 t8_invokeI))) (or (and (user_role_assign id2 POClerk) (and (role_le POClerk W) (executed_1 id2 t8_invokeI))) (or (and (user_role_assign id3 POClerk) (and (role_le POClerk W) (executed_1 id3 t8_invokeI))) (or (and (user_role_assign id4 POClerk) (and (role_le POClerk W) (executed_1 id4 t8_invokeI))) (or (and (user_role_assign id5 POClerk) (and (role_le POClerk W) (executed_1 id5 t8_invokeI))) (or (and (user_role_assign id6 POClerk) (and (role_le POClerk W) (executed_1 id6 t8_invokeI))) (or (and (user_role_assign id7 POClerk) (and (role_le POClerk W) (executed_1 id7 t8_invokeI))) (or (and (user_role_assign id1 FinClerk) (and (role_le FinClerk W) (executed_1 id1 t8_invokeI))) (or (and (user_role_assign id2 FinClerk) (and (role_le FinClerk W) (executed_1 id2 t8_invokeI))) (or (and (user_role_assign id3 FinClerk) (and (role_le FinClerk W) (executed_1 id3 t8_invokeI))) (or (and (user_role_assign id4 FinClerk) (and (role_le FinClerk W) (executed_1 id4 t8_invokeI))) (or (and (user_role_assign id5 FinClerk) (and (role_le FinClerk W) (executed_1 id5 t8_invokeI))) (or (and (user_role_assign id6 FinClerk) (and (role_le FinClerk W) (executed_1 id6 t8_invokeI))) (or (and (user_role_assign id7 FinClerk) (and (role_le FinClerk W) (executed_1 id7 t8_invokeI))) (or (and (user_role_assign id1 FinAdmin) (and (role_le FinAdmin W) (executed_1 id1 t8_invokeI))) (or (and (user_role_assign id2 FinAdmin) (and (role_le FinAdmin W) (executed_1 id2 t8_invokeI))) (or (and (user_role_assign id3 FinAdmin) (and (role_le FinAdmin W) (executed_1 id3 t8_invokeI))) (or (and (user_role_assign id4 FinAdmin) (and (role_le FinAdmin W) (executed_1 id4 t8_invokeI))) (or (and (user_role_assign id5 FinAdmin) (and (role_le FinAdmin W) (executed_1 id5 t8_invokeI))) (or (and (user_role_assign id6 FinAdmin) (and (role_le FinAdmin W) (executed_1 id6 t8_invokeI))) (or (and (user_role_assign id7 FinAdmin) (and (role_le FinAdmin W) (executed_1 id7 t8_invokeI))) (or (and (user_role_assign id1 POAdmin) (and (role_le POAdmin W) (executed_1 id1 t8_invokeI))) (or (and (user_role_assign id2 POAdmin) (and (role_le POAdmin W) (executed_1 id2 t8_invokeI))) (or (and (user_role_assign id3 POAdmin) (and (role_le POAdmin W) (executed_1 id3 t8_invokeI))) (or (and (user_role_assign id4 POAdmin) (and (role_le POAdmin W) (executed_1 id4 t8_invokeI))) (or (and (user_role_assign id5 POAdmin) (and (role_le POAdmin W) (executed_1 id5 t8_invokeI))) (or (and (user_role_assign id6 POAdmin) (and (role_le POAdmin W) (executed_1 id6 t8_invokeI))) (or (and (user_role_assign id7 POAdmin) (and (role_le POAdmin W) (executed_1 id7 t8_invokeI))) (or (and (user_role_assign id1 Client) (and (role_le Client W) (executed_1 id1 t8_invokeI))) (or (and (user_role_assign id2 Client) (and (role_le Client W) (executed_1 id2 t8_invokeI))) (or (and (user_role_assign id3 Client) (and (role_le Client W) (executed_1 id3 t8_invokeI))) (or (and (user_role_assign id4 Client) (and (role_le Client W) (executed_1 id4 t8_invokeI))) (or (and (user_role_assign id5 Client) (and (role_le Client W) (executed_1 id5 t8_invokeI))) (or (and (user_role_assign id6 Client) (and (role_le Client W) (executed_1 id6 t8_invokeI))) (and (user_role_assign id7 Client) (and (role_le Client W) (executed_1 id7 t8_invokeI))))))))))))))))))))))))))))))))))))))))))))) )) )) (or (and (= V t1_receive) (has_permission U t1_receive)) (or (and (= V t2_invoke) (has_permission U t2_invoke)) (or (and (= V t7_invokeO) (has_permission U t7_invokeO)) (and (= V t8_invokeI) (has_permission U t8_invokeI)))))))))))\n \n\n;assumption 52\n(assert\n(forall ((U Id)) (iff (t1_receive_0_1 U)\n   (and (and (can_exec_0 U t1_receive) (and (= 1 in_customer_crtPO_0) (= 1 p9_initial_0)))\n  (and (and (= p1_final_1 p1_final_0) (and (= p2_final_1 p2_final_0) (and (= p3_running_1 p3_running_0) (and (= p4_final_1 p4_final_0) (and (= p5_final_1 p5_final_0) (and (= p6_initial_1 p6_initial_0) (and (= p7_final_1 p7_final_0) (and (= p8_initial_1 p8_initial_0) (and (= p9_initial_1 (+ (~ 1) p9_initial_0)) (and (= p10_final_1 (+ 1 p10_final_0)) (and (= p11_final_1 p11_final_0) (and (= in_customer_crtPO_1 (+ (~ 1) in_customer_crtPO_0)) (and (= in_creator_ctrPay_1 in_creator_ctrPay_0) (and (= out_creator_ctrPay_1 out_creator_ctrPay_0) (and (= out_approverPOPayment_apprPay_1 out_approverPOPayment_apprPay_0) (and (= out_approverPO_apprPO_1 out_approverPO_apprPO_0) (and (= out_signerGRN_signGRN_1 out_signerGRN_signGRN_0) (and (= out_signerGRN_ctrsignGRN_1 out_signerGRN_ctrsignGRN_0) true))))))))))))))))))\n  (forall ((V Id) (W Action)) (iff (executed_1 V W) (or (and (= V U) (= W t1_receive)) (executed_0 V W))))\n  )\n  )\n   )))\n \n\n;assumption 53\n(assert \n (not (and initial_wf_0 (and initial_pm_0 (t1_receive_0_1 id6))))\n )\n\n(set-info status sat)\n(check-sat)\n(get-model)\n")),(0,i.kt)("p",null,"It is very effective in this benchmark since it contains many quantifiers of the form"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"forall x.  p(x) = ....")),(0,i.kt)("p",null,"The Z3 model finder is more effective if the input formula does not contain nested quantifiers. If that is not the case for your formula, you can use the option"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"(set-option smt.pull-nested-quantifiers true)")),(0,i.kt)("p",null,"The following challenge problem from the paper ",(0,i.kt)("a",{parentName:"p",href:"httpacademic.research.microsoft.comPaper615910.aspx"},"SEM a system for enumerating models")," is proved to be unsatisfiable in less than one second by Z3."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(set-option smt.mbqi true)\n(declare-sort S)\n(declare-fun g (S S) S)\n(declare-fun f (S S) S)\n(declare-const a S)\n(declare-const b S)\n\n(assert (forall ((x S) (y S))\n                (= (g (f x y) (f x x)) x)))\n(assert (forall ((x S) (y S))\n                (= (f (g x y) (g x x)) x)))\n(assert (forall ((x S) (y S) (z S))\n                (= (g (g x y) z) (g (g y z) x))))\n(assert (forall ((x S) (y S) (z S))\n                (= (f (f x y) z) (f (f y z) x))))\n(assert (distinct (g a (f b a)) (f a (g b a))))\n(check-sat)\n")),(0,i.kt)("h2",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"Z3 is an efficient theorem prover used in many software testing, analysis and verification applications. In this tutorial, we covered its main capabilities using the textual interface. However, most applications use the Z3 programmatic ",(0,i.kt)("a",{parentName:"p",href:"httpsz3prover.github.ioapihtmlindex.html"},"API")," to access these features."))}u.isMDXComponent=!0}}]);