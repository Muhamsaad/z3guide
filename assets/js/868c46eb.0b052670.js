"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8],{3043:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>m,frontMatter:()=>a,metadata:()=>l,toc:()=>u});var n=o(3117),i=(o(7294),o(3905)),s=o(7689);const a={title:"Configuration"},r=void 0,l={unversionedId:"guide/basic-commands/configuration",id:"guide/basic-commands/configuration",title:"Configuration",description:"The command set-option is used to configure Z3. Z3 has several options to control its behavior. Some of these options (e.g., produce-proofs) can only be set before any declaration or assertion. We use the reset command to erase all assertions and declarations. After the reset command, all configuration options can be set.",source:"@site/docs/guide/02 - basic-commands/03 - configuration.md",sourceDirName:"guide/02 - basic-commands",slug:"/guide/basic-commands/configuration",permalink:"/rise4fun/docs/guide/basic-commands/configuration",draft:!1,editUrl:"https://github.com/microsoft/rise4fun/tree/main/website/docs/guide/02 - basic-commands/03 - configuration.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Configuration"},sidebar:"tutorialSidebar",previous:{title:"Using Scopes",permalink:"/rise4fun/docs/guide/basic-commands/using-scopes"},next:{title:"Propositional Logic",permalink:"/rise4fun/docs/guide/propositional-logic"}},d={},u=[{value:"Additional commands",id:"additional-commands",level:3}],c={toc:u};function m(e){let{components:t,...o}=e;return(0,i.kt)("wrapper",(0,n.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The command set-option is used to configure Z3. Z3 has several options to control its behavior. Some of these options (e.g., produce-proofs) can only be set before any declaration or assertion. We use the reset command to erase all assertions and declarations. After the reset command, all configuration options can be set."),(0,i.kt)(s.Z,{input:{code:"(set-option :print-success true) \n(set-option :produce-unsat-cores true) ; enable generation of unsat cores\n(set-option :produce-models true) ; enable model generation\n(set-option :produce-proofs true) ; enable proof generation\n(declare-const x Int)\n(set-option :produce-proofs false) ; error, cannot change this option after a declaration or assertion\n(echo before reset)\n(reset)\n(set-option :produce-proofs false) ; ok",result:{output:'success\n(error "line 2 column 33: error setting \':produce-unsat-cores\', option value cannot be modified after initialization")\nsuccess\n(error "line 4 column 29: error setting \':produce-proofs\', option value cannot be modified after initialization")\nsuccess\n(error "line 6 column 28: error setting \':produce-proofs\', option value cannot be modified after initialization")\n(error "line 7 column 7: invalid command argument, string expected")\nsuccess\n(error "line 9 column 28: error setting \':produce-proofs\', option value cannot be modified after initialization")\n',error:"",status:"z3-ran",hash:"7a0b5fd26701e6863f08d1991ecba759356388a8"}},mdxType:"Z3CodeBlock"}),(0,i.kt)("p",null,"The option print-success true is particularly useful when Z3 is being controlled by another application using pipes. In this mode, commands, that otherwise would not print any output, will print success."),(0,i.kt)("h3",{id:"additional-commands"},"Additional commands"),(0,i.kt)("p",null,"The command (display t) just applies the Z3 pretty printer to the given expression. The command (simplify t) displays a possibly simpler expression equivalent to t. This command accepts many different options, (help simplify) will display all available options."),(0,i.kt)(s.Z,{input:{code:"(declare-const a (Array Int Int))\n(declare-const x Int)\n(declare-const y Int)\n(display (+ x 2 x 1))\n(simplify (+ x 2 x 1))\n(simplify (< (+ x y) (+ x y)))\n(simplify (< (+ x y) (+ x y)) som true) ; put all expressions in sum-of-monomials form.\n(simplify (= x (+ y 2)) arith-lhs true)\n(simplify (= (store (store a 1 2) 4 3)\n             (store (store a 4 3) 1 2)))\n(simplify (= (store (store a 1 2) 4 3)\n             (store (store a 4 3) 1 2))\n          sort-store true)\n(help simplify)",result:{output:'(+ x 2 x 1)\n(+ 3 (* 2 x))\nfalse\n(error "line 7 column 30: invalid command argument, keyword expected")\n(error "line 8 column 25: invalid command argument, keyword expected")\n(= (store (store a 1 2) 4 3) (store (store a 4 3) 1 2))\n(error "line 13 column 10: invalid command argument, keyword expected")\n" (simplify <term> (<keyword> <value>)*)\n    simplify the given term using builtin theory simplification rules.\n    The following options are available:\n      algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\n      arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\n      arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\n      bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\n      blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\n      blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\n      blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\n      blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\n      bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\n      bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\n      bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\n      bv_le2extract (bool) disassemble bvule to extract (default: true)\n      bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\n      bv_not_simpl (bool) apply simplifications for bvnot (default: false)\n      bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\n      cache_all (bool) cache all intermediate results. (default: false)\n      elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\n      elim_ite (bool) eliminate ite in favor of and/or (default: true)\n      elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\n      elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\n      elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\n      eq2ineq (bool) expand equalities into two inequalities (default: false)\n      expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\n      expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\n      expand_select_ite (bool) expand select over ite expressions (default: false)\n      expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\n      expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\n      expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\n      flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\n      gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\n      hi_div0 (bool) use the \'hardware interpretation\' for division by zero (for bit-vector terms) (default: true)\n      hoist_ite (bool) hoist shared summands under ite expressions (default: false)\n      hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\n      ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don\'t mention their bound variables. (default: true)\n      ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)\n      local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\n      local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\n      max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\n      max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\n      max_steps (unsigned int) maximum number of steps (default: 4294967295)\n      mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\n      mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\n      print (bool) (default: true)  print the simplified term.\n      print_proofs (bool) (default: false) print a proof showing the original term is equal to the resultant one.\n      print_statistics (bool) (default: false) print statistics.\n      pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\n      push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\n      push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\n      push_to_real (bool) distribute to_real over * and +. (default: true)\n      rewrite_patterns (bool) rewrite patterns. (default: false)\n      som (bool) put polynomials in sum-of-monomials form (default: false)\n      som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\n      sort_store (bool) sort nested stores when the indices are known to be different (default: false)\n      sort_sums (bool) sort the arguments of + application. (default: false)\n      split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\n      timeout (unsigned int) (default: infty) timeout in milliseconds. (default: 4294967295)\n"\n',error:"",status:"z3-ran",hash:"4965511acd199f4ce6086e5165063e992a80df1d"}},mdxType:"Z3CodeBlock"}),(0,i.kt)("p",null,"The define-sort command defines a new sort symbol that is an abbreviation for a sort expression. The new sort symbol can be parameterized, in which case the names of the parameters are specified in the command and the sort expression uses the sort parameters. The form of the command is this"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"(define-sort ","[symbol]"," (","[symbol]","+) ","[sort]",")")),(0,i.kt)("p",null,"The following example defines several abbreviations for sort expressions."),(0,i.kt)(s.Z,{input:{code:"(define-sort Set (T) (Array T Bool))\n(define-sort IList () (List Int))\n(define-sort List-Set (T) (Array (List T) Bool))\n(define-sort I () Int)\n\n(declare-const s1 (Set I))\n(declare-const s2 (List-Set Int))\n(declare-const a I)\n(declare-const l IList)\n\n(assert (= (select s1 a) true))\n(assert (= (select s2 l) false))\n(check-sat)\n(get-model)",result:{output:'(error "line 1 column 14: invalid sort definition, sort already declared/defined")\n(error "line 2 column 23: unknown sort \'List\'")\n(error "line 3 column 34: unknown sort \'List\'")\n(error "line 7 column 19: unknown sort \'List-Set\'")\n(error "line 9 column 17: Invalid constant declaration: unknown sort \'IList\'")\n(error "line 12 column 19: unknown constant s2")\nsat\n(\n  (define-fun s1 () (Set Int)\n    ((as const (Set Int)) true))\n  (define-fun a () Int\n    0)\n)\n',error:"",status:"z3-ran",hash:"e66942a5075693ef62499048956590f0d499b259"}},mdxType:"Z3CodeBlock"}))}m.isMDXComponent=!0}}]);