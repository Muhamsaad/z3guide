"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2848],{2684:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>l,default:()=>g,frontMatter:()=>a,metadata:()=>c,toc:()=>d});var o=t(3117),r=(t(7294),t(3905)),s=t(504),i=t.n(s);const a={title:"Introduction",sidebar_position:1},l=void 0,c={unversionedId:"Z3 JavaScript/Introduction",id:"Z3 JavaScript/Introduction",title:"Introduction",description:"The Z3 distribution comes with TypeScript (and therefore JavaScript) bindings for Z3.",source:"@site/docs-programming/01 - Z3 JavaScript/01 - Introduction.md",sourceDirName:"01 - Z3 JavaScript",slug:"/Z3 JavaScript/Introduction",permalink:"/z3guide/programming/Z3 JavaScript/Introduction",draft:!1,editUrl:"https://github.com/microsoft/z3guide/tree/main/website/docs-programming/01 - Z3 JavaScript/01 - Introduction.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Introduction",sidebar_position:1},sidebar:"tutorialSidebar",next:{title:"Introduction",permalink:"/z3guide/programming/Z3 Python - Readonly/Introduction"}},u={},d=[{value:"Warmup",id:"warmup",level:2},{value:"Propositional Logic",id:"propositional-logic",level:2},{value:"Integer Arithmetic",id:"integer-arithmetic",level:2},{value:"Dog, cat mouse",id:"dog-cat-mouse",level:3},{value:"Uninterpreted Functions",id:"uninterpreted-functions",level:2},{value:"Prove <code>x = y implies g(x) = g(y)</code>",id:"prove-x--y-implies-gx--gy",level:3},{value:"Disprove <code>x = y implies g(g(x)) = g(y)</code>",id:"disprove-x--y-implies-ggx--gy",level:3},{value:"Prove <code>x = y implies g(x) = g(y)</code>",id:"prove-x--y-implies-gx--gy-1",level:3},{value:"Disprove that <code>x = y implies g(g(x)) = g(y)</code>",id:"disprove-that-x--y-implies-ggx--gy",level:3},{value:"Solve sudoku",id:"solve-sudoku",level:2},{value:"Arithmetic over Reals",id:"arithmetic-over-reals",level:2},{value:"Non-linear arithmetic",id:"non-linear-arithmetic",level:2},{value:"Bit-vectors",id:"bit-vectors",level:2},{value:"Using Z3 objects wrapped in JavaScript",id:"using-z3-objects-wrapped-in-javascript",level:2}],m={toc:d};function g(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,o.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The Z3 distribution comes with TypeScript (and therefore JavaScript) bindings for Z3.\nIn the following we give a few examples of using Z3 through these bindings.\nYou can run and modify the examples locally in your browser."),(0,r.kt)("h2",{id:"warmup"},"Warmup"),(0,r.kt)("p",null,"We use a collection of basic examples to illustrate the bindings.\nThe first example is a formula that establishes that there is no number both above 9 and below 10:"),(0,r.kt)(i(),{input:{lang:"z3-js",highlight:"js",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"const x = Z3.Int.const('x');\nconst solver = new Z3.Solver();\nsolver.add(Z3.And(x.ge(10), x.le(9)));\nawait solver.check();",result:{output:"unsat",error:"",status:"z3-ran",hash:"eddc362daa992ea9c98f05e5f2b71672ad91d5a6"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.10.2",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("p",null,"We note that the JavaScript bindings wrap z3 expressions into JavaScript options that support methods for building new expressions.\nFor example, the method ",(0,r.kt)("inlineCode",{parentName:"p"},"ge")," is available on an arithmetic expression ",(0,r.kt)("inlineCode",{parentName:"p"},"a"),". It takes one argument ",(0,r.kt)("inlineCode",{parentName:"p"},"b")," and returns\nand expression corresponding to the predicate ",(0,r.kt)("inlineCode",{parentName:"p"},"a >= b"),"."),(0,r.kt)("h2",{id:"propositional-logic"},"Propositional Logic"),(0,r.kt)("p",null,"Prove De Morgan's Law"),(0,r.kt)(i(),{input:{lang:"z3-js",highlight:"js",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"const solver = new Z3.Solver();\nconst [x, y] = [Z3.Bool.const('x'), Z3.Bool.const('y')];\nconst conjecture = Z3.Eq(Z3.Not(Z3.And(x, y)), Z3.Or(Z3.Not(x), Z3.Not(y)));\nsolver.add(Z3.Not(conjecture));\nawait solver.check(); // unsat",result:{output:"unsat",error:"",status:"z3-ran",hash:"2368d18177612cc8d7931aba1cf176bc8edb9ed1"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.10.2",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h2",{id:"integer-arithmetic"},"Integer Arithmetic"),(0,r.kt)("p",null,"solve ",(0,r.kt)("inlineCode",{parentName:"p"},"x > 2 and y < 10 and x + 2y = 7")," "),(0,r.kt)(i(),{input:{lang:"z3-js",highlight:"js",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"const x = Z3.Int.const('x');\nconst y = Z3.Int.const('y');\nconst model = await Z3.solve(x.gt(2), y.lt(10), x.add(y.mul(2)).eq(7)) as Model;\nmodel.sexpr()",result:{output:"(define-fun y () Int\n  0)\n(define-fun x () Int\n  7)",error:"",status:"z3-ran",hash:"0deae3b90290aef3c6dfac8e5889eddc8eb7a1c8"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.10.2",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h3",{id:"dog-cat-mouse"},"Dog, cat mouse"),(0,r.kt)(i(),{input:{lang:"z3-js",highlight:"js",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"\n// Create 3 integer variables\n\nconst dog = Z3.Int.const('dog')\nconst cat = Z3.Int.const('cat')\nconst mouse = Z3.Int.const('mouse')\nconst solver = new Z3.Solver()\n// there is at least one dog, one cat, and one mouse\nsolver.add(dog.ge(1), cat.ge(1), mouse.ge(1))\n//      we want to buy 100 animals\n//   \n\nsolver.add(dog.add(cat.add(mouse)).eq(100))\n//       We have 100 dollars (10000 cents):\n//        dogs cost 15 dollars (1500 cents), \n//       cats cost 1 dollar (100 cents), and \n//       mice cost 25 cents \nsolver.add((dog.mul(1500)).add(cat.mul(100)).add(mouse.mul(25)).eq(10000))\nawait solver.check()\nsolver.model().sexpr()",result:{output:"(define-fun mouse () Int\n  56)\n(define-fun cat () Int\n  41)\n(define-fun dog () Int\n  3)",error:"",status:"z3-ran",hash:"37e48cac2a233e67fb82ac82a37becfffe31ecf1"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.10.2",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h2",{id:"uninterpreted-functions"},"Uninterpreted Functions"),(0,r.kt)("h3",{id:"prove-x--y-implies-gx--gy"},"Prove ",(0,r.kt)("inlineCode",{parentName:"h3"},"x = y implies g(x) = g(y)")),(0,r.kt)(i(),{input:{lang:"z3-js",highlight:"js",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"   const solver = new Z3.Solver()\n   const sort = Z3.Int.sort();\n   const x = Z3.Int.const('x');\n   const y = Z3.Int.const('y');\n   const g = Z3.Function.declare('g', sort, sort);\n   const conjecture = Z3.Implies(x.eq(y), g.call(x).eq(g.call(y)));\n   solver.add(Z3.Not(conjecture));\n   await solver.check()",result:{output:"unsat",error:"",status:"z3-ran",hash:"fd178e550fb5faead247d58c2e8caba7890b9f85"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.10.2",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h3",{id:"disprove-x--y-implies-ggx--gy"},"Disprove ",(0,r.kt)("inlineCode",{parentName:"h3"},"x = y implies g(g(x)) = g(y)")),(0,r.kt)(i(),{input:{lang:"z3-js",highlight:"js",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"    const solver = new Z3.Solver();\n\n    const sort = Z3.Int.sort();\n    const x = Z3.Int.const('x');\n    const y = Z3.Int.const('y');\n    const g = Z3.Function.declare('g', sort, sort);\n    const conjecture = Z3.Implies(x.eq(y), g.call(g.call(x)).eq(g.call(y)));\n    solver.add(Z3.Not(conjecture));\n    await solver.check()",result:{output:"sat",error:"",status:"z3-ran",hash:"3ab276a5f5feed20ce6cd044ff50c654a1be88a2"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.10.2",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h3",{id:"prove-x--y-implies-gx--gy-1"},"Prove ",(0,r.kt)("inlineCode",{parentName:"h3"},"x = y implies g(x) = g(y)")),(0,r.kt)(i(),{input:{lang:"z3-js",highlight:"js",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"\nconst solver = new Z3.Solver();\nconst sort = Z3.Int.sort();\nconst x = Z3.Int.const('x');\nconst y = Z3.Int.const('y');\nconst g = Z3.Function.declare('g', sort, sort);\n\nconst conjecture = Z3.Implies(x.eq(y), g.call(x).eq(g.call(y)));\nsolver.add(Z3.Not(conjecture));\nawait solver.check(); // unsat",result:{output:"unsat",error:"",status:"z3-ran",hash:"58c33266d530cd7657b2b6f7a413ed90892b8852"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.10.2",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h3",{id:"disprove-that-x--y-implies-ggx--gy"},"Disprove that ",(0,r.kt)("inlineCode",{parentName:"h3"},"x = y implies g(g(x)) = g(y)")),(0,r.kt)(i(),{input:{lang:"z3-js",highlight:"js",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"const solver = new Z3.Solver();\nconst sort = Z3.Int.sort();\nconst x = Z3.Int.const('x');\nconst y = Z3.Int.const('y');\nconst g = Z3.Function.declare('g', sort, sort);\nconst conjecture = Z3.Implies(x.eq(y), g.call(g.call(x)).eq(g.call(y)));\nsolver.add(Z3.Not(conjecture));\nawait solver.check(); //sat",result:{output:"sat",error:"",status:"z3-ran",hash:"bf0ff77b9a8d3849ee9201bc57ea30e7f7f70210"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.10.2",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h2",{id:"solve-sudoku"},"Solve sudoku"),(0,r.kt)(i(),{input:{lang:"z3-js",highlight:"js",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"function toSudoku(data: string): (number | null)[][] {\n    const cells: (number | null)[][] = Array.from({ length: 9 }, () => Array.from({ length: 9 }, () => null));\n\n    const lines = data.trim().split('\\n');\n    for (let row = 0; row < 9; row++) {\n        const line = lines[row].trim();\n        for (let col = 0; col < 9; col++) {\n            const char = line[col];\n            if (char !== '.') {\n                cells[row][col] = Number.parseInt(char);\n            }\n        }\n    }\n    return cells;\n}\n\nconst INSTANCE = toSudoku(`\n....94.3.\n...51...7\n.89....4.\n......2.8\n.6.2.1.5.\n1.2......\n.7....52.\n9...65...\n.4.97....\n`);\n\nconst EXPECTED = toSudoku(`\n715894632\n234516897\n689723145\n493657218\n867231954\n152489763\n376148529\n928365471\n541972386\n`);\n\n\nconst cells = [];\n// 9x9 matrix of integer variables\nfor (let i = 0; i < 9; i++) {\n    const row = [];\n    for (let j = 0; j < 9; j++) {\n        row.push(Z3.Int.const(`x_${i}_${j}`));\n    }\n    cells.push(row);\n}\n\nconst solver = new Z3.Solver();\n\n// each cell contains a value 1<=x<=9\nfor (let i = 0; i < 9; i++) {\n    for (let j = 0; j < 9; j++) {\n        solver.add(cells[i][j].ge(1), cells[i][j].le(9));\n    }\n}\n\n// each row contains a digit only once\nfor (let i = 0; i < 9; i++) {\n    solver.add(Z3.Distinct(...cells[i]));\n}\n\n// each column contains a digit only once\nfor (let j = 0; j < 9; j++) {\n    const column = [];\n    for (let i = 0; i < 9; i++) {\n        column.push(cells[i][j]);\n    }\n    solver.add(Z3.Distinct(...column));\n}\n\n// each 3x3 contains a digit at most once\nfor (let iSquare = 0; iSquare < 3; iSquare++) {\n    for (let jSquare = 0; jSquare < 3; jSquare++) {\n        const square = [];\n\n        for (let i = iSquare * 3; i < iSquare * 3 + 3; i++) {\n            for (let j = jSquare * 3; j < jSquare * 3 + 3; j++) {\n                square.push(cells[i][j]);\n            }\n        }\n\n        solver.add(Z3.Distinct(...square));\n    }\n}\n\nfor (let i = 0; i < 9; i++) {\n    for (let j = 0; j < 9; j++) {\n        const digit = INSTANCE[i][j];\n        if (digit !== null) {\n            solver.add(cells[i][j].eq(digit));\n        }\n    }\n}\n\nconst is_sat = await solver.check(); // sat\nconst model = solver.model() as Model\nvar buffer = \"\"\n\nfor (let i = 0; i < 9; i++) {\n    for (let j = 0; j < 9; j++) {\n        const v = model.eval(cells[i][j])\n        buffer += `${v}`\n    }\n    buffer += \"\\n\"\n}\nbuffer",result:{output:"715894632\n234516897\n689723145\n493657218\n867231954\n152489763\n376148529\n928365471\n541972386\n",error:"",status:"z3-ran",hash:"e8a62f054a890b59f473d72827bdc128e6498be3"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.10.2",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h2",{id:"arithmetic-over-reals"},"Arithmetic over Reals"),(0,r.kt)(i(),{input:{lang:"z3-js",highlight:"js",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"// numerals 1\nconst n1 = Z3.Real.val('1/2');\nconst n2 = Z3.Real.val('0.5');\nconst n3 = Z3.Real.val(0.5);\n\nconst conjecture = Z3.And(n1.eq(n2), n1.eq(n3));\n\nconst solver = new Z3.Solver();\nsolver.add(Z3.Not(conjecture));\nawait solver.check();",result:{output:"unsat",error:"",status:"z3-ran",hash:"19dd3a36f2945696036e7d99f6cf001942fdd79c"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.10.2",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)(i(),{input:{lang:"z3-js",highlight:"js",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"// numerals 2\nconst n4 = Z3.Real.val('-1/3');\nconst n5 = Z3.Real.val('-0.3333333333333333333333333333333333');\n\nconst conjecture = n4.neq(n5);\n\nconst solver = new Z3.Solver();\nsolver.add(Z3.Not(conjecture));\nawait solver.check();",result:{output:"unsat",error:"",status:"z3-ran",hash:"ca24ea650dd0a0eb086e317a324c479df1e3439c"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.10.2",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h2",{id:"non-linear-arithmetic"},"Non-linear arithmetic"),(0,r.kt)(i(),{input:{lang:"z3-js",highlight:"js",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"setParam('pp.decimal', true);\nsetParam('pp.decimal_precision', 20);\n\nconst x = Z3.Real.const('x');\nconst y = Z3.Real.const('y');\nconst z = Z3.Real.const('z');\n\nconst solver = new Z3.Solver();\nsolver.add(x.mul(x).add(y.mul(y)).eq(1)); // x^2 + y^2 == 1\nsolver.add(x.mul(x).mul(x).add(z.mul(z).mul(z)).lt('1/2')); // x^3 + z^3 < 1/2\n\nawait solver.check(); // sat",result:{output:"sat",error:"",status:"z3-ran",hash:"e9e1f01f16d27492de104245191eb00f652a3c75"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.10.2",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h2",{id:"bit-vectors"},"Bit-vectors"),(0,r.kt)(i(),{input:{lang:"z3-js",highlight:"js",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"\nconst x = Z3.BitVec.const('x', 32);\n\nconst sConj = x.sub(10).sle(0).eq(x.sle(10));\nconst sSolver = new Z3.Solver();\nsSolver.add(sConj);\nawait sSolver.check(); // sat\n\nconst sModel = sSolver.model();\nsModel.get(x) // signed\n\nconst uConj = x.sub(10).ule(0).eq(x.ule(10));\nconst uSolver = new Z3.Solver();\nuSolver.add(uConj);\nawait uSolver.check(); // sat\n\nconst uModel = uSolver.model();\nuModel.get(x) // unsigned",result:{output:"#x0000000a",error:"",status:"z3-ran",hash:"9b4e58b28dbea587f37cc7c969651c432c7ce3d2"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.10.2",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("p",null,"Solves an equation"),(0,r.kt)(i(),{input:{lang:"z3-js",highlight:"js",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"const x = Z3.BitVec.const('x', 32);\nconst y = Z3.BitVec.const('y', 32);\n\nconst solver = new Z3.Solver();\nconst conjecture = x.xor(y).sub(103).eq(x.mul(y));\nsolver.add(conjecture);\nconst is_sat = await solver.check(); // sat\n\nconst model = solver.model();\n\n// need the following cast for `asSignedValue` to work\nconst xSol = model.get(x) as BitVecNum;\nconst ySol = model.get(y) as BitVecNum;\n\n\nconst are_vals = Z3.isBitVecVal(xSol) && Z3.isBitVecVal(ySol); // true\n\nconst xv = xSol.asSignedValue();\nconst yv = ySol.asSignedValue();\n\n// this solutions wraps around so we need to check using modulo\nconst is_eq = (xv ^ yv) - 103n === (xv * yv) % 2n ** 32n; // true\n\n` is-sat: ${is_sat} solutions are values: ${are_vals} satisfy equality: ${is_eq}`",result:{output:" is-sat: sat solutions are values: true satisfy equality: true",error:"",status:"z3-ran",hash:"554a75fac9ea28c3120c37a368ffacac87d25f1d"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.10.2",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,r.kt)("h2",{id:"using-z3-objects-wrapped-in-javascript"},"Using Z3 objects wrapped in JavaScript"),(0,r.kt)("p",null,"The following example illustrates the use of AstVector"),(0,r.kt)(i(),{input:{lang:"z3-js",highlight:"js",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"const solver = new Z3.Solver();\n\nconst vector = new Z3.AstVector<Arith>() as AstVector<string, Arith>;\nfor (let i = 0; i < 5; i++) {\n    vector.push(Z3.Int.const(`int__${i}`));\n}\n\nconst length = vector.length();\nfor (let i = 0; i < length; i++) {\n    solver.add((vector.get(i) as Arith).gt(1));\n}\n\nawait solver.check(); // sat",result:{output:"sat",error:"",status:"z3-ran",hash:"100050dfce4f081d317d3725865b9198226665b1"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.10.2",tool:"z3-solver"},mdxType:"CustomCodeBlock"}))}g.isMDXComponent=!0}}]);