"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8105],{375:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>b,frontMatter:()=>a,metadata:()=>l,toc:()=>u});var i=n(8168),o=(n(6540),n(5680)),s=n(2317),r=n.n(s);const a={title:"Combining Objectives",sidebar_position:5},c=void 0,l={unversionedId:"optimization/combiningobjectives",id:"optimization/combiningobjectives",title:"Combining Objectives",description:"Many optimization problems require solving multiple objectives.",source:"@site/docs-smtlib/04 - optimization/05 - combiningobjectives.md",sourceDirName:"04 - optimization",slug:"/optimization/combiningobjectives",permalink:"/z3guide/docs/optimization/combiningobjectives",draft:!1,editUrl:"https://github.com/microsoft/z3guide/tree/main/website/docs-smtlib/04 - optimization/05 - combiningobjectives.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"Combining Objectives",sidebar_position:5},sidebar:"smtlibSidebar",previous:{title:"Soft Constraints",permalink:"/z3guide/docs/optimization/softconstraints"},next:{title:"A Small Case Study",permalink:"/z3guide/docs/optimization/asmallcasestudy"}},d={},u=[{value:"Lexicographic Combination",id:"lexicographic-combination",level:2},{value:"Pareto Fronts",id:"pareto-fronts",level:2},{value:"Independent Objectives",id:"independent-objectives",level:2}],m={toc:u},p="wrapper";function b(e){let{components:t,...n}=e;return(0,o.yg)(p,(0,i.A)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("p",null,"Many optimization problems require solving multiple objectives."),(0,o.yg)("h2",{id:"lexicographic-combination"},"Lexicographic Combination"),(0,o.yg)("p",null,"Z3 uses by default a lexicographic priority of objectives. It solves first for the objective that is declared first."),(0,o.yg)(r(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Int)\n(declare-const y Int)\n(declare-const z Int)\n(assert (< x z))\n(assert (< y z))\n(assert (< z 5))\n(assert (not (= x y)))\n(maximize x)\n(maximize y)\n(check-sat)\n(get-model)\n(get-objectives)",result:{output:"sat\n(\n  (define-fun z () Int\n    4)\n  (define-fun x () Int\n    3)\n  (define-fun y () Int\n    2)\n)\n(objectives\n (x 3)\n (y 2)\n)\n",error:"",status:"z3-ran",hash:"c411e816628e24309cbc401d6da563882b378d04"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,o.yg)("p",null,"It is also possible to declare multiple classes of soft assertions. To do this, use an optional tag to differentiate classes of soft assertions.\nThe first tag group ",(0,o.yg)("inlineCode",{parentName:"p"},"A")," is given precedence over the second group ",(0,o.yg)("inlineCode",{parentName:"p"},"B")," that is introduced later."),(0,o.yg)(r(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const a Bool)\n(declare-const b Bool)\n(declare-const c Bool)\n(assert-soft a :weight 1 :id A)\n(assert-soft b :weight 2 :id B)\n(assert-soft c :weight 3 :id A)\n(assert (= a c))\n(assert (not (and a b)))\n(check-sat)\n(get-model)\n(get-objectives)",result:{output:"sat\n(\n  (define-fun c () Bool\n    true)\n  (define-fun b () Bool\n    false)\n  (define-fun a () Bool\n    true)\n)\n(objectives\n (A 0)\n (B 2)\n)\n",error:"",status:"z3-ran",hash:"6ea0e76f3c3e25037e6811c2f1016f766889c33c"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,o.yg)("h2",{id:"pareto-fronts"},"Pareto Fronts"),(0,o.yg)("p",null,"To override lexicographic priorities, set the option opt.priority to ",(0,o.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Pareto_front"},"Pareto"),"."),(0,o.yg)(r(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Int)\n(declare-const y Int)\n(assert (>= 5 x))\n(assert (>= x 0))\n(assert (>= 4 y))\n(assert (>= y 0))\n(minimize x)\n(maximize (+ x y))\n(minimize y)\n(set-option :opt.priority pareto)\n(check-sat)\n(get-objectives)\n(check-sat)\n(get-objectives)\n(check-sat)\n(get-objectives)\n(check-sat)\n(get-objectives)",result:{output:"sat\n(objectives\n (x 0)\n ((+ x y) 0)\n (y 0)\n)\nsat\n(objectives\n (x 0)\n ((+ x y) 1)\n (y 1)\n)\nsat\n(objectives\n (x 0)\n ((+ x y) 2)\n (y 2)\n)\nsat\n(objectives\n (x 0)\n ((+ x y) 3)\n (y 3)\n)\n",error:"",status:"z3-ran",hash:"6991be1289b2e194327e967103d1e582c15dad9c"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,o.yg)("h2",{id:"independent-objectives"},"Independent Objectives"),(0,o.yg)("p",null,"If we just want to find the optimal value for each objective, set the option opt.priority to box."),(0,o.yg)(r(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Real)\n(declare-const y Real)\n(assert (>= 5 (- x y)))\n(assert (>= x 0))\n(assert (>= 4 y))\n(assert (> y 0))\n(minimize x)\n(maximize (+ x y))\n(minimize y)\n(maximize y)\n(set-option :opt.priority box)\n(check-sat)\n(get-objectives)",result:{output:"sat\n(objectives\n (x 0)\n ((+ x y) 4)\n (y 1)\n (y 1)\n)\n",error:"",status:"z3-ran",hash:"bb49a5dd37d402fc9ad259bf69bb28b1ed774648"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}))}b.isMDXComponent=!0}}]);