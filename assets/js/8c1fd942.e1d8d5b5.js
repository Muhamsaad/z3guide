"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[456],{4625:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>u,contentTitle:()=>a,default:()=>k,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var s=n(3117),l=(n(7294),n(3905)),r=n(7689);const i={title:"Strings and Sequences",sidebar_position:9},a=void 0,o={unversionedId:"Sequences",id:"Sequences",title:"Strings and Sequences",description:"Introduction",source:"@site/docs/09 - Sequences.md",sourceDirName:".",slug:"/Sequences",permalink:"/rise4fun/docs/Sequences",draft:!1,editUrl:"https://github.com/microsoft/rise4fun/tree/main/website/docs/09 - Sequences.md",tags:[],version:"current",sidebarPosition:9,frontMatter:{title:"Strings and Sequences",sidebar_position:9},sidebar:"tutorialSidebar",previous:{title:"Datatypes",permalink:"/rise4fun/docs/Datatypes"},next:{title:"Regular Expressions",permalink:"/rise4fun/docs/Regular Expressions"}},u={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Strings",id:"strings",level:2},{value:"Built-in types and constants",id:"built-in-types-and-constants",level:3},{value:"String literals",id:"string-literals",level:3},{value:"Operations",id:"operations",level:2},{value:"Examples",id:"examples",level:2},{value:"Operations",id:"operations-1",level:2},{value:"Examples",id:"examples-1",level:2}],d={toc:c};function k(t){let{components:e,...n}=t;return(0,l.kt)("wrapper",(0,s.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"introduction"},"Introduction"),(0,l.kt)("p",null,"This section describes Z3's handling of strings and sequences.\nStrings are represented as a sequence of Characters. The default character sort is Unicode.\nYou can reason about regular expressions of sequences. Regular expressions are described in the next secion.\nZ3 offers built-in support for\nusing string constants and dedicated solvers for checking\nsatisfiability over constraints using strings and sequences.\nNote that the (current) specialized solver is able to establish\nsatisfiability for a non-trivial class of formulas, but is far from\na decision procedure even for fragments of string equalities that can be decided:\nZ3 only solves string equalities using an incomplete\nheuristic solver\nand the full combination of lengths and sequences\n(and regular expressions) is not decidable anyway.\nIn Z3, strings are a special case of sequences, and for the case of Unicode strings,\nand regular expressions over Unicode strings seeks to implement the ",(0,l.kt)("a",{parentName:"p",href:"http://smtlib.cs.uiowa.edu/theories-UnicodeStrings.shtml"},"SMTLIB2 standard"),"."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"TBDs")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"update documentation to use new names"),(0,l.kt)("li",{parentName:"ul"},"add notes about regex capabilities (comparing regex)"),(0,l.kt)("li",{parentName:"ul"},"update reference to z3str3")),(0,l.kt)("h2",{id:"strings"},"Strings"),(0,l.kt)("h3",{id:"built-in-types-and-constants"},"Built-in types and constants"),(0,l.kt)("p",null,"The name ",(0,l.kt)("inlineCode",{parentName:"p"},"String")," is a built-in name for the String sort.\nString literals can furthermore be entered directly as literals\ndelimited by quotes. The following example asks whether there are\nstrings ",(0,l.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"b")," that concatenate to ",(0,l.kt)("inlineCode",{parentName:"p"},'"abc"'),"\nfollowed by ",(0,l.kt)("inlineCode",{parentName:"p"},"b"),"."),(0,l.kt)(r.Z,{input:{code:'(declare-const a String)\n(declare-const b String)\n(assert (= (str.++ b a) (str.++ "abc" b)))\n(check-sat)\n(get-model)'},mdxType:"Z3CodeBlock"}),(0,l.kt)("h3",{id:"string-literals"},"String literals"),(0,l.kt)("p",null,"Z3 follows the proposed SMT-LIB2.5 format for string\nliterals. Thus, strings are enclosed using double quotes. A sequence\nof two adjacent double quotes within a string literal is used as the\nescape sequence for a quote. So for example ",(0,l.kt)("inlineCode",{parentName:"p"},'"quote ""me"" on this"'),"\ncorresponds to the string ",(0,l.kt)("inlineCode",{parentName:"p"},'quote "me" on this'),". Other\ncharacters are treated as part of the string. For example, a newline within a string\nis treated as a new-line character. "),(0,l.kt)("p",null,"To represent non-ASCII characters the SMTLIB2 standard uses unicode escape sequences.\nThe escape sequences are of the form ",(0,l.kt)("inlineCode",{parentName:"p"},"\\u{N}"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"\\u{NN}"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"\\u{NNN}"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"\\u{NNNN}"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"\\u{NNNNN}"),",\nwhere ",(0,l.kt)("inlineCode",{parentName:"p"},"N")," is a hexidecimal digit."),(0,l.kt)("p",null,"The following example shows\nthree ways to enter the newline character."),(0,l.kt)(r.Z,{input:{code:'(define-const a String "\\u{a}")\n(define-const b String "\n")\n(define-const c String "\\n")\n(simplify (= a b))\n(simplify (= a c))\n(simplify (str.++ a b c))'},mdxType:"Z3CodeBlock"}),(0,l.kt)("h2",{id:"operations"},"Operations"),(0,l.kt)("p",null,"Let us start out with a summary of available string operations."),(0,l.kt)("table",null,(0,l.kt)("tr",null,(0,l.kt)("td",null,"Operation"),(0,l.kt)("td",null,"Brief description")),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(str.++ a b c)")),(0,l.kt)("td",null,"String concatenation of one or more strings")),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(str.len s)")),(0,l.kt)("td",null,"String length. Returns an integer.")),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(str.substr s offset length)")),(0,l.kt)("td",null,"Retrieves substring of ",(0,l.kt)("tt",null,"s")," at ",(0,l.kt)("tt",null,"offset"))),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(str.indexof s sub)")),(0,l.kt)("td",null,"Retrieves first position of ",(0,l.kt)("tt",null,"sub")," in ",(0,l.kt)("tt",null,"s"),", -1 if there are no occurrences")),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(str.indexof s sub offset)")),(0,l.kt)("td",null,"Retrieves first position of ",(0,l.kt)("tt",null,"sub")," at or after ",(0,l.kt)("tt",null,"offset")," in ",(0,l.kt)("tt",null,"s"),", -1 if there are no occurrences")),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(str.at s offset)")),(0,l.kt)("td",null,"Substring of length 1 at ",(0,l.kt)("tt",null,"offset")," in ",(0,l.kt)("tt",null,"s"),".")),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(str.contains s sub)")),(0,l.kt)("td",null,"Does ",(0,l.kt)("tt",null,"s")," contain the substring ",(0,l.kt)("tt",null,"sub"),"?")),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(str.prefixof pre s)")),(0,l.kt)("td",null,"Is ",(0,l.kt)("tt",null,"pre")," a prefix of ",(0,l.kt)("tt",null,"s"),"?")),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(str.suffixof suf s)")),(0,l.kt)("td",null,"Is ",(0,l.kt)("tt",null,"suf")," a suffix of ",(0,l.kt)("tt",null,"s"),"?")),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(str.replace s src dst)")),(0,l.kt)("td",null,"Replace the first occurrence of ",(0,l.kt)("tt",null,"src")," by ",(0,l.kt)("tt",null,"dst")," in ",(0,l.kt)("tt",null,"s"),".")),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(str.to_int s)")),(0,l.kt)("td",null,"Retrieve integer encoded by string ",(0,l.kt)("tt",null,"s")," (ground rewriting only).")),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(str.from_int i)")),(0,l.kt)("td",null,"Retrieve string encoding of integer ",(0,l.kt)("tt",null,"i")," (ground rewriting only).")),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(str.< s1 s2)")),(0,l.kt)("td",null,"Lexicographic string less than")),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(str.&leq; s1 s2)")),(0,l.kt)("td",null,"Lexicographic string less or equal to.")),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(_ char ch)")),(0,l.kt)("td",null,"Unit string from unicode character code.")),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(str.is_digit s)")),(0,l.kt)("td",null,"A predicate whether string is a one of the digits 0 to 9.")),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(str.to_code s)")),(0,l.kt)("td",null,"Convert string of length one to the character code (an integer). Produce -1 if the string is not of length 1")),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(str.from_code i)")),(0,l.kt)("td",null,"Convert an integer in the range of valid unicodes to a string of length one"))),(0,l.kt)("p",null,"Note that ",(0,l.kt)("inlineCode",{parentName:"p"},"(str.indexof s offset)")," is shorthand for ",(0,l.kt)("inlineCode",{parentName:"p"},"(str.indexof s offset 0)"),"."),(0,l.kt)("p",null,"Some operations have under-specified behavior on certain arguments.\nNamely, ",(0,l.kt)("inlineCode",{parentName:"p"},"(str.at s i)")," is unconstrained for indices that are either negative or beyond\n",(0,l.kt)("inlineCode",{parentName:"p"},"(- (str.len s) 1)"),". Furthermore ",(0,l.kt)("inlineCode",{parentName:"p"},"(str.substr s offset length)")," is under-specified\nwhen the offset is outside the range of positions in ",(0,l.kt)("inlineCode",{parentName:"p"},"s")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"length")," is negative or\n",(0,l.kt)("inlineCode",{parentName:"p"},"offset+length")," exceeds the length of ",(0,l.kt)("inlineCode",{parentName:"p"},"s"),"."),(0,l.kt)("h2",{id:"examples"},"Examples"),(0,l.kt)("p",null,"Basic string operations"),(0,l.kt)(r.Z,{input:{code:'(simplify (str.++ (str.at "abc" 1) (str.at "abc" 0)))\n(simplify (str.indexof "abcabc" "a"))\n(simplify (str.indexof "abcabc" "a" 1))\n(simplify (str.substr "xxabcyy" 2 3))'},mdxType:"Z3CodeBlock"}),(0,l.kt)("p",null,"A string cannot overlap with two different characters."),(0,l.kt)(r.Z,{input:{code:'(declare-const a String)\n(assert (= (str.++ a "b") (str.++ "a" a)))\n(check-sat)'},mdxType:"Z3CodeBlock"}),(0,l.kt)("p",null,"Strings ",(0,l.kt)("tt",null,"a, b, c")," can have a non-trivial overlap."),(0,l.kt)(r.Z,{input:{code:'(declare-const a String)\n(declare-const b String)\n(declare-const c String)\n(assert (= (str.++ a b) "abcd"))\n(assert (= (str.++ b c) "cdef"))\n(assert (not (= b "")))\n(check-sat)'},mdxType:"Z3CodeBlock"}),(0,l.kt)("p",null,"There is a solution to ",(0,l.kt)("inlineCode",{parentName:"p"},"a")," of length at most 2."),(0,l.kt)(r.Z,{input:{code:'(declare-const a String)\n(declare-const b String)\n(assert (= (str.++ "abc" a) (str.++ b "cef")))\n(assert (<= (str.len a) 2))\n(check-sat)'},mdxType:"Z3CodeBlock"}),(0,l.kt)("p",null,"There is a solution to ",(0,l.kt)("inlineCode",{parentName:"p"},"a"),' that is not a sequence of "a"\'s.'),(0,l.kt)(r.Z,{input:{code:'(declare-const a String)\n(declare-const b String)\n(declare-const c String)\n(assert (= (str.++ a "ab" b) (str.++ b "ba" c)))\n(assert (= c (str.++ a b)))\n(assert (not (= (str.++ a "a") (str.++ "a" a))))\n(check-sat)\n(get-model)'},mdxType:"Z3CodeBlock"}),(0,l.kt)("p",null,"Contains is transitive."),(0,l.kt)(r.Z,{input:{code:"(declare-const a String)\n(declare-const b String)\n(declare-const c String)\n(assert (str.contains a b))\n(assert (str.contains b c))\n(assert (not (str.contains a c)))\n(check-sat)"},mdxType:"Z3CodeBlock"}),(0,l.kt)("p",null,"But containment is not a linear order."),(0,l.kt)(r.Z,{input:{code:"(declare-const a String)\n(declare-const b String)\n(declare-const c String)\n(assert (str.contains a b))\n(assert (str.contains a c))\n(assert (not (str.contains b c)))\n(assert (not (str.contains c b)))\n(check-sat)\n(get-model)"},mdxType:"Z3CodeBlock"}),(0,l.kt)("p",null,"Any string is equal to the prefix and suffix that add up to a its length."),(0,l.kt)(r.Z,{input:{code:"(declare-const a String)\n(declare-const b String)\n(declare-const c String)\n(assert (str.prefixof b a))\n(assert (str.suffixof c a))\n(assert (= (str.len a) (+ (str.len b) (str.len c))))\n(assert (not (= a (str.++ b c))))\n(check-sat)"},mdxType:"Z3CodeBlock"}),(0,l.kt)("h1",{id:"sequences"},"Sequences"),(0,l.kt)("p",null,"The sort constructor ",(0,l.kt)("inlineCode",{parentName:"p"},"Seq")," can be used to create sequences over any base sort.\nFor example, a sequence of integers is ",(0,l.kt)("inlineCode",{parentName:"p"},"(Seq Int)"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"(Seq (_ BitVec 8))"),"\nis the definition of ",(0,l.kt)("inlineCode",{parentName:"p"},"String"),"."),(0,l.kt)("h2",{id:"operations-1"},"Operations"),(0,l.kt)("p",null,"Most string operations have corresponding sequence variants. In addition, there are operations\nto create a unit sequence and the empty sequence over any base sort."),(0,l.kt)("table",null,(0,l.kt)("tr",null,(0,l.kt)("td",null,"Operation"),(0,l.kt)("td",null,"Brief description")),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(seq.unit elem)")),(0,l.kt)("td",null,"Sequence with a single element ",(0,l.kt)("tt",null,"elem"),".")),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(as seq.empty (Seq Int))")),(0,l.kt)("td",null,"The empty sequence of integers.")),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(seq.++ a b c)")),(0,l.kt)("td",null,"Concatenation of one or more sequences.")),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(seq.len s)")),(0,l.kt)("td",null,"Sequence length. Returns an integer.")),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(seq.extract s offset length)")),(0,l.kt)("td",null,"Retrieves sub-sequence of ",(0,l.kt)("tt",null,"s")," at ",(0,l.kt)("tt",null,"offset"))),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(seq.indexof s sub)")),(0,l.kt)("td",null,"Retrieves first position of ",(0,l.kt)("tt",null,"sub")," in ",(0,l.kt)("tt",null,"s"),", -1 if there are no occurrences")),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(seq.indexof s sub offset)")),(0,l.kt)("td",null,"Retrieves first position of ",(0,l.kt)("tt",null,"sub")," at or after ",(0,l.kt)("tt",null,"offset")," in ",(0,l.kt)("tt",null,"s"),", -1 if there are no occurrences")),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(seq.at s offset)")),(0,l.kt)("td",null,"Sub-sequence of length 1 at ",(0,l.kt)("tt",null,"offset")," in ",(0,l.kt)("tt",null,"s"),".")),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(seq.contains s sub)")),(0,l.kt)("td",null,"Does ",(0,l.kt)("tt",null,"s")," contain the sub-sequence ",(0,l.kt)("tt",null,"sub"),"?")),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(seq.prefixof pre s)")),(0,l.kt)("td",null,"Is ",(0,l.kt)("tt",null,"pre")," a prefix of ",(0,l.kt)("tt",null,"s"),"?")),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(seq.suffixof suf s)")),(0,l.kt)("td",null,"Is ",(0,l.kt)("tt",null,"suf")," a suffix of ",(0,l.kt)("tt",null,"s"),"?")),(0,l.kt)("tr",null,(0,l.kt)("td",null,(0,l.kt)("tt",null,"(seq.replace s src dst)")),(0,l.kt)("td",null,"Replace the first occurrence of ",(0,l.kt)("tt",null,"src")," by ",(0,l.kt)("tt",null,"dst")," in ",(0,l.kt)("tt",null,"s"),"."))),(0,l.kt)("h2",{id:"examples-1"},"Examples"),(0,l.kt)("p",null,"When inserting ",(0,l.kt)("inlineCode",{parentName:"p"},"b")," at or after position 8, but before the length of the string, which is at least 10,\nthen the resulting string has the same length, and either character 8 or 9 are unchanged."),(0,l.kt)(r.Z,{input:{code:"(declare-const s (Seq Int))\n(declare-const t (Seq Int))\n(declare-const j Int)\n(declare-const b Int)\n\n(assert (<= 10 (seq.len s)))\n(assert (<= 8 j))\n(assert (< j (seq.len s)))\n(assert (= t (seq.++ (seq.extract s 0 j) (seq.unit b) (seq.extract s (+ j 1) (- (seq.len s) j 1)))))\n(push)\n(assert (not (= (seq.unit b) (seq.at t j))))\n(check-sat)\n(pop)\n(push)\n(assert (not (= (seq.len s) (seq.len t))))\n(check-sat)\n(pop)\n(push)\n(assert (not (= (seq.at s 8) (seq.at t 8))))\n(assert (not (= (seq.at s 9) (seq.at t 9))))\n(check-sat)\n(pop)"},mdxType:"Z3CodeBlock"}))}k.isMDXComponent=!0}}]);