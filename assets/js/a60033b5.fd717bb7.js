"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[241],{8275:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>m});var i=t(3117),o=(t(7294),t(3905)),r=t(7689);const a={title:"Syntax",sidebar_position:5},l=void 0,s={unversionedId:"fixedpoints/syntax",id:"fixedpoints/syntax",title:"Syntax",description:"Three different text-based input formats are accepted.",source:"@site/docs/fixedpoints/05 - syntax.md",sourceDirName:"fixedpoints",slug:"/fixedpoints/syntax",permalink:"/rise4fun/docs/fixedpoints/syntax",draft:!1,editUrl:"https://github.com/microsoft/rise4fun/tree/main/website/docs/fixedpoints/05 - syntax.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"Syntax",sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Traffic Jam",permalink:"/rise4fun/docs/fixedpoints/trafficjam"},next:{title:"Z3 Guide Introduction",permalink:"/rise4fun/docs/guide/intro"}},d={},m=[{value:"1. Basic datalog",id:"1-basic-datalog",level:2},{value:"2. SMT-LIB2 extension",id:"2-smt-lib2-extension",level:2},{value:"3. Pure SMT-LIB2",id:"3-pure-smt-lib2",level:2},{value:"Note the following:",id:"note-the-following",level:2},{value:"Programmatic API",id:"programmatic-api",level:2}],c={toc:m};function p(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Three different text-based input formats are accepted."),(0,o.kt)("h2",{id:"1-basic-datalog"},"1. Basic datalog"),(0,o.kt)("p",null,"Files with suffix .datalog are parsed using the BDDBDDB format. The format can be used for comparing benchmarks with the BDDBDDB tool."),(0,o.kt)("p",null,"We use an artificial program to illustrate the basic Datalog format that complies to the format used by BDDBDDB."),(0,o.kt)(r.Z,{input:{code:'Z 64\n\nP0(x: Z) input\nGt0(x : Z, y : Z) input\nR(x : Z) printtuples\nS(x : Z) printtuples\nGt(x : Z, y : Z) printtuples\nGt(x,y) :- Gt0(x,y).\nGt(x,y) :- Gt(x,z), Gt(z,y).\nR(x) :- Gt(x,_).\nS(x) :- Gt(x,x0), Gt0(x,y), Gt0(y,z), P0(z).\nGt0("a","b").\nGt0("b","c").\nGt0("c","d").\nGt0("a1","b").\nGt0("b","a1").\nGt0("d","d1").\nGt0("d1","d").\nP0("a1").',result:{output:'(error "line 1 column 1: invalid command, \'(\' expected")\nunsupported\n; x line: 3 position: 7\n(error "line 3 column 9: invalid command, \'(\' expected")\nunsupported\n; x line: 4 position: 16\n(error "line 4 column 18: invalid command, \'(\' expected")\nunsupported\n; x line: 5 position: 7\n(error "line 5 column 9: invalid command, \'(\' expected")\nunsupported\n; x line: 6 position: 7\n(error "line 6 column 9: invalid command, \'(\' expected")\nunsupported\n; x line: 7 position: 15\n(error "line 7 column 17: invalid command, \'(\' expected")\nunsupported\n; x,y line: 8 position: 6\n(error "line 8 column 8: invalid command, \'(\' expected")\nunsupported\n; x,y line: 8 position: 18\n(error "line 8 column 19: invalid command, \'(\' expected")\nunsupported\n; x,y line: 9 position: 6\n(error "line 9 column 8: invalid command, \'(\' expected")\nunsupported\n; x,z line: 9 position: 17\n(error "line 9 column 18: invalid command, \'(\' expected")\nunsupported\n; z,y line: 9 position: 26\n(error "line 9 column 27: invalid command, \'(\' expected")\nunsupported\n; x line: 10 position: 3\n(error "line 10 column 5: invalid command, \'(\' expected")\nunsupported\n; x,_ line: 10 position: 14\n(error "line 10 column 15: invalid command, \'(\' expected")\nunsupported\n; x line: 11 position: 3\n(error "line 11 column 5: invalid command, \'(\' expected")\nunsupported\n; x,x0 line: 11 position: 15\n(error "line 11 column 16: invalid command, \'(\' expected")\nunsupported\n; x,y line: 11 position: 25\n(error "line 11 column 26: invalid command, \'(\' expected")\nunsupported\n; y,z line: 11 position: 35\n(error "line 11 column 36: invalid command, \'(\' expected")\nunsupported\n; z line: 11 position: 42\n(error "line 11 column 43: invalid command, \'(\' expected")\n(error "line 12 column 4: invalid command, symbol expected")\n(error "line 13 column 4: invalid command, symbol expected")\n(error "line 14 column 4: invalid command, symbol expected")\n(error "line 15 column 4: invalid command, symbol expected")\n(error "line 16 column 4: invalid command, symbol expected")\n(error "line 17 column 4: invalid command, symbol expected")\n(error "line 18 column 4: invalid command, symbol expected")\n(error "line 19 column 3: invalid command, symbol expected")\n',error:"",status:"z3-ran",hash:"6f973a0e8c1e94968e505478b3b5c8968c5e8314"}},mdxType:"Z3CodeBlock"}),(0,o.kt)("h2",{id:"2-smt-lib2-extension"},"2. SMT-LIB2 extension"),(0,o.kt)("p",null,"The following commands are added to the SMT-LIB2 syntax:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"(declare-var [var] [sort])")," Declare a variable that is universally quantified in Horn clauses."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"(declare-rel [relation-name] ([sorts]))")," Declare relation signature. Relations are uninterpreted."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"(rule [universal-horn-formula])")," Assert a rule or a fact as a universally quantified Horn formula."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"(query [relation-name])")," Pose a query. Is the relation non-empty."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"(set-predicate-representation [function-name] [symbol]+)")," Specify the representation of a predicate.")),(0,o.kt)("h2",{id:"3-pure-smt-lib2"},"3. Pure SMT-LIB2"),(0,o.kt)("p",null,"Many problems about program safety can be reduced to pure Horn clause satisfiability modulo theories (typically of arithmetic). These problems are expressible directly in SMT-LIB2. The repository Horn clause benchmarks in SMT-LIB2 contains more than 10,000 samples taken from different benchmarks and different encodings of the same benchmarks. An assertion is Horn if it is an implication; the head of the implication is either a formula using only interpreted functions, or it is an uninterpreted predicate; the body of the implication is a formula in negation normal form where the uninterpreted predicates occur positively."),(0,o.kt)(r.Z,{input:{code:"(set-logic HORN)\n(declare-fun mc (Int Int) Bool)\n\n(assert (forall ((m Int)) (=> (> m 100) (mc m (- m 10)))))\n(assert (forall ((m Int) (n Int) (p Int)) \n           (=> (and (<= m 100) (mc (+ m 11) p) (mc p n)) (mc m n))))\n\n(assert (forall ((m Int) (n Int))\n       (=> (and (mc m n) (<= m 101)) (= n 91))))\n(check-sat)\n(get-model)",result:{output:"",error:"",status:"z3-ran",hash:"1f7f961f4cbb8ece7d57ee27c1871ff5c5b9b23e"}},mdxType:"Z3CodeBlock"}),(0,o.kt)("h2",{id:"note-the-following"},"Note the following:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"To ensure that the fixedpoint engine is used, specify ",(0,o.kt)("inlineCode",{parentName:"li"},"(set-logic HORN)")),(0,o.kt)("li",{parentName:"ul"},"There is no separate query. Instead, queries correspond to Horn clause that have no positive occurrence of any uninterpreted relation.")),(0,o.kt)("h2",{id:"programmatic-api"},"Programmatic API"),(0,o.kt)("p",null,"You can interact with muZ over the programmatic API from Python, C, OCaml, Java, and .NET. The APIs support adding rules and posing queries."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"To add a rule, call: ","[Z3_fixedpoint_add_rule]"," (",(0,o.kt)("a",{parentName:"li",href:"http://research.microsoft.com/en-us/um/redmond/projects/z3/group__capi.html#ga5a103b212a663889a458a3b31efb91ed"},"http://research.microsoft.com/en-us/um/redmond/projects/z3/group__capi.html#ga5a103b212a663889a458a3b31efb91ed"),")."),(0,o.kt)("li",{parentName:"ul"},"To query, use: ","[Z3_fixedpoint_query]"," (",(0,o.kt)("a",{parentName:"li",href:"http://research.microsoft.com/en-us/um/redmond/projects/z3/group__capi.html#gac5d521e37bb0c8aa2843142c58c32749"},"http://research.microsoft.com/en-us/um/redmond/projects/z3/group__capi.html#gac5d521e37bb0c8aa2843142c58c32749"),").")))}p.isMDXComponent=!0}}]);