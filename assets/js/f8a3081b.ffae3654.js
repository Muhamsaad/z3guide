"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5177],{1250:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>c,toc:()=>d});var o=t(3117),r=(t(7294),t(3905)),s=t(504),a=t.n(s);const i={},l="Examples from the JS bindings unit test",c={unversionedId:"Z3 JavaScript/more JS examples",id:"Z3 JavaScript/more JS examples",title:"Examples from the JS bindings unit test",description:"Type checking for Z3-typed function parameters messes up with how we process JS/TS inputs, so for now we don't include any top-level functions that include such parameters.",source:"@site/docs-programming/02 - Z3 JavaScript/03 - more JS examples.md",sourceDirName:"02 - Z3 JavaScript",slug:"/Z3 JavaScript/more JS examples",permalink:"/z3guide/programming/Z3 JavaScript/more JS examples",draft:!1,editUrl:"https://github.com/microsoft/z3guide/tree/main/website/docs-programming/02 - Z3 JavaScript/03 - more JS examples.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"This file is to contain more tests",permalink:"/z3guide/programming/Z3 JavaScript/more tests"},next:{title:"Cores and Satisfying Subsets",permalink:"/z3guide/programming/Examples/Cores and Satisfying Subsets"}},u={},d=[],m={toc:d};function p(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,o.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"examples-from-the-js-bindings-unit-test"},"Examples from the JS bindings unit test"),(0,r.kt)("div",{className:"admonition admonition-warning alert alert--danger"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))),"warning")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"Type checking for Z3-typed function parameters messes up with how we process JS/TS inputs, so for now we don't include any top-level functions that include such parameters."))),(0,r.kt)(a(),{input:{lang:"z3-js",highlight:"js",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"// proves x = y implies g(x) = g(y)\n\nconst solver = new Z3.Solver();\nconst sort = Z3.Int.sort();\nconst x = Z3.Int.const('x');\nconst y = Z3.Int.const('y');\nconst g = Z3.Function.declare('g', sort, sort);\n\nconst conjecture = Z3.Implies(x.eq(y), g.call(x).eq(g.call(y)));\nsolver.add(Z3.Not(conjecture));\nawait solver.check(); // unsat",result:{output:"unsat",error:"",status:"z3-ran",hash:"16a515db3b88471d8f266b464b2344b2a30d00b7"},githubRepo:"Z3Prover/z3"},mdxType:"CustomCodeBlock"}),(0,r.kt)(a(),{input:{lang:"z3-js",highlight:"js",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"// disproves that x = y implies g(g(x)) = g(y)\n\nconst solver = new Z3.Solver();\nconst sort = Z3.Int.sort();\nconst x = Z3.Int.const('x');\nconst y = Z3.Int.const('y');\nconst g = Z3.Function.declare('g', sort, sort);\nconst conjecture = Z3.Implies(x.eq(y), g.call(g.call(x)).eq(g.call(y)));\nsolver.add(Z3.Not(conjecture));\nawait solver.check(); //sat",result:{output:"sat",error:"",status:"z3-ran",hash:"c55e03a7cc02e5abf176f20763b498f989027b91"},githubRepo:"Z3Prover/z3"},mdxType:"CustomCodeBlock"}),(0,r.kt)(a(),{input:{lang:"z3-js",highlight:"js",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"// proves De Morgan's Law\nconst solver = new Z3.Solver();\nconst [x, y] = [Z3.Bool.const('x'), Z3.Bool.const('y')];\nconst conjecture = Z3.Eq(Z3.Not(Z3.And(x, y)), Z3.Or(Z3.Not(x), Z3.Not(y)));\nsolver.add(Z3.Not(conjecture));\nawait solver.check(); // unsat",result:{output:"unsat",error:"",status:"z3-ran",hash:"e54e8215ee8788a22b2dcfca2420107f804c4de2"},githubRepo:"Z3Prover/z3"},mdxType:"CustomCodeBlock"}),(0,r.kt)(a(),{input:{lang:"z3-js",highlight:"js",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"// finds a model\nconst solver = new Z3.Solver();\nconst x = Z3.Int.const('x');\nconst y = Z3.Int.const('y');\n\nsolver.add(x.ge(1)); // x >= 1\nsolver.add(y.lt(x.add(3))); // y < x + 3\n\nawait solver.check(); // sat\n\nconst model = solver.model();\nawait model.sexpr();",result:{output:"(define-fun y () Int\n  3)\n(define-fun x () Int\n  1)",error:"",status:"z3-ran",hash:"f9dd66b1e430f36b7e955869f1646e0370ce0641"},githubRepo:"Z3Prover/z3"},mdxType:"CustomCodeBlock"}),(0,r.kt)(a(),{input:{lang:"z3-js",highlight:"js",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"// solves sudoku\nfunction toSudoku(data: string): (number | null)[][] {\n    const cells: (number | null)[][] = Array.from({ length: 9 }, () => Array.from({ length: 9 }, () => null));\n\n    const lines = data.trim().split('\\n');\n    for (let row = 0; row < 9; row++) {\n        const line = lines[row].trim();\n        for (let col = 0; col < 9; col++) {\n            const char = line[col];\n            if (char !== '.') {\n                cells[row][col] = Number.parseInt(char);\n            }\n        }\n    }\n    return cells;\n}\n\nconst INSTANCE = toSudoku(`\n....94.3.\n...51...7\n.89....4.\n......2.8\n.6.2.1.5.\n1.2......\n.7....52.\n9...65...\n.4.97....\n`);\n\nconst EXPECTED = toSudoku(`\n715894632\n234516897\n689723145\n493657218\n867231954\n152489763\n376148529\n928365471\n541972386\n`);\n\n\nconst cells = [];\n// 9x9 matrix of integer variables\nfor (let i = 0; i < 9; i++) {\n    const row = [];\n    for (let j = 0; j < 9; j++) {\n        row.push(Z3.Int.const(`x_${i}_${j}`));\n    }\n    cells.push(row);\n}\n\nconst solver = new Z3.Solver();\n\n// each cell contains a value 1<=x<=9\nfor (let i = 0; i < 9; i++) {\n    for (let j = 0; j < 9; j++) {\n        solver.add(cells[i][j].ge(1), cells[i][j].le(9));\n    }\n}\n\n// each row contains a digit only once\nfor (let i = 0; i < 9; i++) {\n    solver.add(Z3.Distinct(...cells[i]));\n}\n\n// each column contains a digit only once\nfor (let j = 0; j < 9; j++) {\n    const column = [];\n    for (let i = 0; i < 9; i++) {\n        column.push(cells[i][j]);\n    }\n    solver.add(Z3.Distinct(...column));\n}\n\n// each 3x3 contains a digit at most once\nfor (let iSquare = 0; iSquare < 3; iSquare++) {\n    for (let jSquare = 0; jSquare < 3; jSquare++) {\n        const square = [];\n\n        for (let i = iSquare * 3; i < iSquare * 3 + 3; i++) {\n            for (let j = jSquare * 3; j < jSquare * 3 + 3; j++) {\n                square.push(cells[i][j]);\n            }\n        }\n\n        solver.add(Z3.Distinct(...square));\n    }\n}\n\nfor (let i = 0; i < 9; i++) {\n    for (let j = 0; j < 9; j++) {\n        const digit = INSTANCE[i][j];\n        if (digit !== null) {\n            solver.add(cells[i][j].eq(digit));\n        }\n    }\n}\n\nawait solver.check(); // sat",result:{output:"sat",error:"",status:"z3-ran",hash:"d274fcbbef696d7b8023d37cf910015ab7ce9c12"},githubRepo:"Z3Prover/z3"},mdxType:"CustomCodeBlock"}),(0,r.kt)(a(),{input:{lang:"z3-js",highlight:"js",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"// numerals 1\nconst n1 = Z3.Real.val('1/2');\nconst n2 = Z3.Real.val('0.5');\nconst n3 = Z3.Real.val(0.5);\n\nconst conjecture = Z3.And(n1.eq(n2), n1.eq(n3));\n\nconst solver = new Z3.Solver();\nsolver.add(Z3.Not(conjecture));\nawait solver.check();",result:{output:"unsat",error:"",status:"z3-ran",hash:"18db6515b197b55df72654ada88a28ab104776e0"},githubRepo:"Z3Prover/z3"},mdxType:"CustomCodeBlock"}),(0,r.kt)(a(),{input:{lang:"z3-js",highlight:"js",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"// numerals 2\nconst n4 = Z3.Real.val('-1/3');\nconst n5 = Z3.Real.val('-0.3333333333333333333333333333333333');\n\nconst conjecture = n4.neq(n5);\n\nconst solver = new Z3.Solver();\nsolver.add(Z3.Not(conjecture));\nawait solver.check();",result:{output:"unsat",error:"",status:"z3-ran",hash:"6de42c85389d4407f0925ad8638fbd9b5b071cb4"},githubRepo:"Z3Prover/z3"},mdxType:"CustomCodeBlock"}),(0,r.kt)("p",null,"TODO: setParam doesn't work with how with process JS inputs"),(0,r.kt)(a(),{input:{lang:"z3-js",highlight:"js",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"// non-linear arithmetic\n\nsetParam('pp.decimal', true);\nsetParam('pp.decimal_precision', 20);\n\nconst x = Z3.Real.const('x');\nconst y = Z3.Real.const('y');\nconst z = Z3.Real.const('z');\n\nconst solver = new Z3.Solver();\nsolver.add(x.mul(x).add(y.mul(y)).eq(1)); // x^2 + y^2 == 1\nsolver.add(x.mul(x).mul(x).add(z.mul(z).mul(z)).lt('1/2')); // x^3 + z^3 < 1/2\n\nawait solver.check(); // sat",result:{output:"sat",error:"",status:"z3-ran",hash:"56189d20f2dbb1202f0fd8c607509eff52173d82"},githubRepo:"Z3Prover/z3"},mdxType:"CustomCodeBlock"}),(0,r.kt)("p",null,"TODO: seems that we can only get the final output, not intermediate ones"),(0,r.kt)(a(),{input:{lang:"z3-js",highlight:"js",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"// bitvectors: simple proofs\nconst x = Z3.BitVec.const('x', 32);\n\nconst sConj = x.sub(10).sle(0).eq(x.sle(10));\nconst sSolver = new Z3.Solver();\nsSolver.add(sConj);\nawait sSolver.check(); // sat\n\nconst sModel = sSolver.model();\nsModel.get(x) // signed\n\nconst uConj = x.sub(10).ule(0).eq(x.ule(10));\nconst uSolver = new Z3.Solver();\nuSolver.add(uConj);\nawait uSolver.check(); // sat\n\nconst uModel = uSolver.model();\nuModel.get(x) // unsigned",result:{output:"#x0000000a",error:"",status:"z3-ran",hash:"f3e627e0f970fbc7fa1f6650366db67e71053bbd"},githubRepo:"Z3Prover/z3"},mdxType:"CustomCodeBlock"}),(0,r.kt)(a(),{input:{lang:"z3-js",highlight:"js",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"// solves an equation\nconst x = Z3.BitVec.const('x', 32);\nconst y = Z3.BitVec.const('y', 32);\n\nconst solver = new Z3.Solver();\nconst conjecture = x.xor(y).sub(103).eq(x.mul(y));\nsolver.add(conjecture);\nawait solver.check(); // sat\n\nconst model = solver.model();\n// need the following cast for `asSignedValue` to work\nconst xSol = model.get(x) as BitVecNum;\nconst ySol = model.get(y) as BitVecNum;\n\nZ3.isBitVecVal(xSol) && Z3.isBitVecVal(ySol); // true\n\n// TODO: fix the remaining lines\nconst xv = xSol.asSignedValue();\nconst yv = ySol.asSignedValue();\n\n// this solutions wraps around so we need to check using modulo\n(xv ^ yv) - 103n === (xv * yv) % 2n ** 32n; // true",result:{output:"true",error:"",status:"z3-ran",hash:"50b6802118bc332a2cf3a387516a47535ddb1a9b"},githubRepo:"Z3Prover/z3"},mdxType:"CustomCodeBlock"}),(0,r.kt)(a(),{input:{lang:"z3-js",highlight:"js",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"// AstVector\nconst solver = new Z3.Solver();\n\nconst vector = new Z3.AstVector<Arith>() as AstVector<string, Arith>;\nfor (let i = 0; i < 5; i++) {\n    vector.push(Z3.Int.const(`int__${i}`));\n}\n\nconst length = vector.length();\nfor (let i = 0; i < length; i++) {\n    solver.add((vector.get(i) as Arith).gt(1));\n}\n\nawait solver.check(); // sat",result:{output:"sat",error:"",status:"z3-ran",hash:"38b83a5f2eaf18869b5eab64231fa5867fe54769"},githubRepo:"Z3Prover/z3"},mdxType:"CustomCodeBlock"}))}p.isMDXComponent=!0}}]);