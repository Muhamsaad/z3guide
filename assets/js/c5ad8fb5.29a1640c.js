"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8951],{6785:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>u,contentTitle:()=>l,default:()=>f,frontMatter:()=>s,metadata:()=>d,toc:()=>c});var a=t(3117),i=(t(7294),t(3905)),o=t(504),n=t.n(o);const s={title:"Special Relations",sidebar_position:14},l=void 0,d={unversionedId:"theories/Special Relations",id:"theories/Special Relations",title:"Special Relations",description:"Special Binary Relations",source:"@site/docs-smtlib/02 - theories/14 - Special Relations.md",sourceDirName:"02 - theories",slug:"/theories/Special Relations",permalink:"/z3guide/docs/theories/Special Relations",draft:!1,editUrl:"https://github.com/microsoft/z3guide/tree/main/website/docs-smtlib/02 - theories/14 - Special Relations.md",tags:[],version:"current",sidebarPosition:14,frontMatter:{title:"Special Relations",sidebar_position:14},sidebar:"smtlibSidebar",previous:{title:"Sequences",permalink:"/z3guide/docs/theories/Sequences"},next:{title:"Introduction",permalink:"/z3guide/docs/strategies/intro"}},u={},c=[{value:"Special Binary Relations",id:"special-binary-relations",level:2},{value:"Partial Order",id:"partial-order",level:3},{value:"Linear Order",id:"linear-order",level:3},{value:"Tree Order",id:"tree-order",level:3},{value:"Piece-wise Linear Order",id:"piece-wise-linear-order",level:3},{value:"Transitive Closures",id:"transitive-closures",level:2}],p={toc:c};function f(e){let{components:r,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,t,{components:r,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"special-binary-relations"},"Special Binary Relations"),(0,i.kt)("p",null,"Binary relations that are partial orders, linear orders, tree orders, and piece-wise linear orders\ncan be axiomatized using first order quantifiers. However, reasoning with these quantified axioms involves\nnon-linear overhead, up to a quadratic number of quantifier instantiations.\nThe decision procedures for partial, linear, tree and piece-wise linear orders in z3\nuse variants of Ford-Fulkerson push relabeling graphs."),(0,i.kt)("h3",{id:"partial-order"},"Partial Order"),(0,i.kt)(n(),{input:{lang:"z3",highlight:"lisp",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-sort A 0)\n(declare-fun R (A A) Bool)\n(assert (forall ((x A)) (R x x)))\n(assert (forall ((x A) (y A)) (=> (and (R x y) (R y x)) (= x y))))\n(assert (forall ((x A) (y A) (z A)) (=> (and (R x y) (R y z)) (R x z))))",result:{output:"",error:"",status:"z3-ran",hash:"91e839a0ab274477d7402190d6fb32f83179d2b6"},githubRepo:"Z3Prover/z3"},mdxType:"CustomCodeBlock"}),(0,i.kt)("p",null,"Use instead"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(define-fun R ((x A) (y A)) Bool ((_ partial-order 0) x y))\n")),(0,i.kt)("p",null,"We are using the index 0 to identify the partial order relation ",(0,i.kt)("inlineCode",{parentName:"p"},"R"),". To create a different relation that is also a partial order use\na different index, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"(_ partial-order 1)"),"."),(0,i.kt)("h3",{id:"linear-order"},"Linear Order"),(0,i.kt)(n(),{input:{lang:"z3",highlight:"lisp",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-sort A 0)\n(declare-fun R (A A) Bool)\n(assert (forall ((x A)) (R x x)))\n(assert (forall ((x A) (y A)) (=> (and (R x y) (R y x)) (= x y))))\n(assert (forall ((x A) (y A) (z A)) (=> (and (R x y) (R y z)) (R x z))))\n(assert (forall ((x A) (y A)) (or (R x y) (R y x))))",result:{output:"",error:"",status:"z3-ran",hash:"147e9285976dd5580ee4e14d84a6a238f00a23f4"},githubRepo:"Z3Prover/z3"},mdxType:"CustomCodeBlock"}),(0,i.kt)("p",null,"Use instead"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(define-fun R ((x A) (y A)) Bool ((_ linear-order 0) x y))\n")),(0,i.kt)("h3",{id:"tree-order"},"Tree Order"),(0,i.kt)(n(),{input:{lang:"z3",highlight:"lisp",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-sort A 0)\n(declare-fun R (A A) Bool)\n(assert (forall ((x A)) (R x x)))\n(assert (forall ((x A) (y A)) (=> (and (R x y) (R y x)) (= x y))))\n(assert (forall ((x A) (y A) (z A)) (=> (and (R x y) (R y z)) (R x z))))\n(assert (forall ((x A) (y A) (z A)) (=> (and (R x y) (R x z)) (or (R y z) (R z y)))))",result:{output:"",error:"",status:"z3-ran",hash:"8061a323a17e29c36baeb018faecdabf91b9d22e"},githubRepo:"Z3Prover/z3"},mdxType:"CustomCodeBlock"}),(0,i.kt)("p",null,"Use instead"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(define-fun R ((x A) (y A)) Bool ((_ tree-order 0) x y))\n")),(0,i.kt)("h3",{id:"piece-wise-linear-order"},"Piece-wise Linear Order"),(0,i.kt)(n(),{input:{lang:"z3",highlight:"lisp",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-sort A 0)\n(declare-fun R (A A) Bool)\n(assert (forall ((x A)) (R x x)))\n(assert (forall ((x A) (y A)) (=> (and (R x y) (R y x)) (= x y))))\n(assert (forall ((x A) (y A) (z A)) (=> (and (R x y) (R y z)) (R x z))))\n(assert (forall ((x A) (y A) (z A)) (=> (and (R x y) (R x z)) (or (R y z) (R z y)))))\n(assert (forall ((x A) (y A) (z A)) (=> (and (R y x) (R z x)) (or (R y z) (R z y)))))",result:{output:"",error:"",status:"z3-ran",hash:"003cc14e54fdbb8af94b17d0932d23b5172cf666"},githubRepo:"Z3Prover/z3"},mdxType:"CustomCodeBlock"}),(0,i.kt)("p",null,"Use instead"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(define-fun R ((x A) (y A)) Bool ((_ piecewise-linear-order 0) x y))\n")),(0,i.kt)("h2",{id:"transitive-closures"},"Transitive Closures"),(0,i.kt)("p",null,"The transitive closure of a relation is not first-order axiomatizable. However, the decision problem for ground formulas is decidable\nbecause for every binary relation ",(0,i.kt)("inlineCode",{parentName:"p"},"R")," over a finite domain, the transitive closure of it is defined over the finite graph of ",(0,i.kt)("inlineCode",{parentName:"p"},"R"),".\nThe small model property contrasts non-ground first-order formulas using transitive closure that are not first-order axiomatizable."),(0,i.kt)(n(),{input:{lang:"z3",highlight:"lisp",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-sort A 0)\n(declare-fun R (A A) Bool)\n(declare-fun b () A)\n(declare-fun a () A)\n(declare-fun c () A)\n(assert (R a b))\n(assert (R b c))\n(assert (not ((_ transitive-closure R) a c)))\n(check-sat)",result:{output:"unsat\n",error:"",status:"z3-ran",hash:"1eae467d518e38a4a961b637e3a23ee6d6950465"},githubRepo:"Z3Prover/z3"},mdxType:"CustomCodeBlock"}))}f.isMDXComponent=!0}}]);