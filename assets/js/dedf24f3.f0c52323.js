"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4584],{1037:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>b,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var i=n(3117),o=(n(7294),n(3905)),s=n(7689);const a={title:"Combining Objectives",sidebar_position:5},c=void 0,r={unversionedId:"optimization/combiningobjectives",id:"optimization/combiningobjectives",title:"Combining Objectives",description:"Many optimization problems require solving multiple objectives.",source:"@site/docs/03 - optimization/05 - combiningobjectives.md",sourceDirName:"03 - optimization",slug:"/optimization/combiningobjectives",permalink:"/z3guide/docs/optimization/combiningobjectives",draft:!1,editUrl:"https://github.com/microsoft/z3guide/tree/main/website/docs/03 - optimization/05 - combiningobjectives.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"Combining Objectives",sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Soft Constraints",permalink:"/z3guide/docs/optimization/softconstraints"},next:{title:"A Small Case Study",permalink:"/z3guide/docs/optimization/asmallcasestudy"}},d={},l=[{value:"Lexicographic Combination",id:"lexicographic-combination",level:2},{value:"Pareto Fronts",id:"pareto-fronts",level:2},{value:"Independent Objectives",id:"independent-objectives",level:2}],p={toc:l};function b(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,i.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Many optimization problems require solving multiple objectives."),(0,o.kt)("h2",{id:"lexicographic-combination"},"Lexicographic Combination"),(0,o.kt)("p",null,"Z3 uses by default a lexicographic priority of objectives. It solves first for the objective that is declared first."),(0,o.kt)(s.Z,{input:{code:"(declare-const x Int)\n(declare-const y Int)\n(declare-const z Int)\n(assert (< x z))\n(assert (< y z))\n(assert (< z 5))\n(assert (not (= x y)))\n(maximize x)\n(maximize y)\n(check-sat)\n(get-model)\n(get-objectives)",result:{output:"sat\n(\n  (define-fun z () Int\n    4)\n  (define-fun x () Int\n    3)\n  (define-fun y () Int\n    2)\n)\n(objectives\n (x 3)\n (y 2)\n)\n",error:"",status:"z3-ran",hash:"861da7d776990b16b624b5df710c7e7712eb3728"}},mdxType:"Z3CodeBlock"}),(0,o.kt)("p",null,"It is also possible to declare multiple classes of soft assertions. To do this, use an optional tag to differentiate classes of soft assertions."),(0,o.kt)(s.Z,{input:{code:"(declare-const a Bool)\n(declare-const b Bool)\n(declare-const c Bool)\n(assert-soft a :weight 1 :id A)\n(assert-soft b :weight 2 :id B)\n(assert-soft c :weight 3 :id A)\n(assert (= a c))\n(assert (not (and a b)))\n(check-sat)\n(get-model)\n(get-objectives)",result:{output:"sat\n(\n  (define-fun c () Bool\n    true)\n  (define-fun b () Bool\n    false)\n  (define-fun a () Bool\n    true)\n)\n(objectives\n (A 0)\n (B 2)\n)\n",error:"",status:"z3-ran",hash:"da16717a61f6c69cc25b8aa601e8b8467f07d493"}},mdxType:"Z3CodeBlock"}),(0,o.kt)("h2",{id:"pareto-fronts"},"Pareto Fronts"),(0,o.kt)("p",null,"To override lexicographic priorities, set the option opt.priority to pareto."),(0,o.kt)(s.Z,{input:{code:"(declare-const x Int)\n(declare-const y Int)\n(assert (>= 5 x))\n(assert (>= x 0))\n(assert (>= 4 y))\n(assert (>= y 0))\n(minimize x)\n(maximize (+ x y))\n(minimize y)\n(set-option :opt.priority pareto)\n(check-sat)\n(get-objectives)\n(check-sat)\n(get-objectives)\n(check-sat)\n(get-objectives)\n(check-sat)\n(get-objectives)",result:{output:"sat\n(objectives\n (x 0)\n ((+ x y) 0)\n (y 0)\n)\nsat\n(objectives\n (x 0)\n ((+ x y) 1)\n (y 1)\n)\nsat\n(objectives\n (x 0)\n ((+ x y) 2)\n (y 2)\n)\nsat\n(objectives\n (x 0)\n ((+ x y) 3)\n (y 3)\n)\n",error:"",status:"z3-ran",hash:"68adadc712500bd13c74616136132567c4c796f0"}},mdxType:"Z3CodeBlock"}),(0,o.kt)("h2",{id:"independent-objectives"},"Independent Objectives"),(0,o.kt)("p",null,"If we just want to find the optimal value for each objective, set the option opt.priority to box."),(0,o.kt)(s.Z,{input:{code:"(declare-const x Real)\n(declare-const y Real)\n(assert (>= 5 (- x y)))\n(assert (>= x 0))\n(assert (>= 4 y))\n(assert (> y 0))\n(minimize x)\n(maximize (+ x y))\n(minimize y)\n(maximize y)\n(set-option :opt.priority box)\n(check-sat)\n(get-objectives)",result:{output:"sat\n(objectives\n (x 0)\n ((+ x y) 4)\n (y 1)\n (y 1)\n)\n",error:"",status:"z3-ran",hash:"232be249ca6e0a14d7ea7031b9a5e2fecd4a13a8"}},mdxType:"Z3CodeBlock"}))}b.isMDXComponent=!0}}]);