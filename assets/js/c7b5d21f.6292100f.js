"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[785],{2122:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>f,frontMatter:()=>s,metadata:()=>d,toc:()=>l});var t=i(3117),a=(i(7294),i(3905)),r=i(7689);const s={title:"Division"},o=void 0,d={unversionedId:"Arithmetic/division",id:"Arithmetic/division",title:"Division",description:"Z3 also has support for division, integer division, modulo and remainder operators. Internally, they are all mapped to multiplication.",source:"@site/docs/05 - Arithmetic/03 - division.md",sourceDirName:"05 - Arithmetic",slug:"/Arithmetic/division",permalink:"/rise4fun/docs/Arithmetic/division",draft:!1,editUrl:"https://github.com/microsoft/rise4fun/tree/main/website/docs/05 - Arithmetic/03 - division.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Division"},sidebar:"tutorialSidebar",previous:{title:"Arithmetic",permalink:"/rise4fun/docs/category/arithmetic"},next:{title:"Bitvectors",permalink:"/rise4fun/docs/Bitvectors"}},c={},l=[],u={toc:l};function f(e){let{components:n,...i}=e;return(0,a.kt)("wrapper",(0,t.Z)({},u,i,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Z3 also has support for division, integer division, modulo and remainder operators. Internally, they are all mapped to multiplication."),(0,a.kt)(r.Z,{input:{code:"(declare-const a Int)\n(declare-const r1 Int)\n(declare-const r2 Int)\n(declare-const r3 Int)\n(declare-const r4 Int)\n(declare-const r5 Int)\n(declare-const r6 Int)\n(assert (= a 10))\n(assert (= r1 (div a 4))) ; integer division\n(assert (= r2 (mod a 4))) ; mod\n(assert (= r3 (rem a 4))) ; remainder\n(assert (= r4 (div a (- 4)))) ; integer division\n(assert (= r5 (mod a (- 4)))) ; mod\n(assert (= r6 (rem a (- 4)))) ; remainder\n(declare-const b Real)\n(declare-const c Real)\n(assert (= b ( c 3.0)))\n(assert (= c 20.0))\n(check-sat)\n(get-model)",result:{output:'(error "line 17 column 20: unknown constant c (Real) \ndeclared: (declare-fun c () Real) ")\nsat\n(\n  (define-fun c () Real\n    20.0)\n  (define-fun r6 () Int\n    (- 2))\n  (define-fun r5 () Int\n    2)\n  (define-fun r4 () Int\n    (- 2))\n  (define-fun r3 () Int\n    2)\n  (define-fun r2 () Int\n    2)\n  (define-fun r1 () Int\n    2)\n  (define-fun a () Int\n    10)\n  (define-fun b () Real\n    0.0)\n)\n',error:"",status:"z3-ran",hash:"bc00ea23f884d740aa572514741a4082e9145179"}},mdxType:"Z3CodeBlock"}),(0,a.kt)("p",null,"In Z3, division by zero is allowed, but the result is not specified. Division is not a partial function. Actually, in Z3 all functions are total, although the result may be underspecified in some cases like division by zero."),(0,a.kt)(r.Z,{input:{code:"(declare-const a Real)\n; The following formula is satisfiable since division by zero is not specified.\n(assert (= (/ a 0.0) 10.0)) \n(check-sat)\n(get-model)\n\n; Although division by zero is not specified, division is still a function.\n; So, (/ a 0.0) cannot evaluated to 10.0 and 2.0.\n(assert (= (/ a 0.0) 2.0)) \n(check-sat)",result:{output:"sat\n(\n  (define-fun a () Real\n    38.0)\n  (define-fun /0 ((x!0 Real) (x!1 Real)) Real\n    10.0)\n)\nunsat\n",error:"",status:"z3-ran",hash:"cddbaffa0fc324db2dda111ca2caa6a3d43a71fe"}},mdxType:"Z3CodeBlock"}),(0,a.kt)("p",null,"If you are not happy with this behavior, you may use ite (if-then-else) operator to guard every division, and assign whatever intepretation you like to the division by zero. This example uses define-fun constructor to create a new operator mydiv. This is essentially a macro, and Z3 will expand its definition for every application of mydiv."),(0,a.kt)(r.Z,{input:{code:"; defining my own division operator where x0.0 == 0.0 for every x.\n(define-fun mydiv ((x Real) (y Real)) Real\n  (if (not (= y 0.0))\n      (/ x y)\n      0.0))\n(declare-const a Real)\n(declare-const b Real)\n(assert (= (mydiv a b) 1.0))\n(assert (= b 0.0))\n(check-sat)",result:{output:"unsat\n",error:"",status:"z3-ran",hash:"c754ed69a75db339e0be02574c9606f3cc76ccf5"}},mdxType:"Z3CodeBlock"}))}f.isMDXComponent=!0}}]);