"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6759],{7258:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>u,contentTitle:()=>l,default:()=>f,frontMatter:()=>s,metadata:()=>d,toc:()=>c});var a=t(3117),i=(t(7294),t(3905)),o=t(504),n=t.n(o);const s={title:"Special Relations",sidebar_position:10},l=void 0,d={unversionedId:"theories/Special Relations",id:"theories/Special Relations",title:"Special Relations",description:"Special Binary Relations",source:"@site/docs-smtlib/02 - theories/10 - Special Relations.md",sourceDirName:"02 - theories",slug:"/theories/Special Relations",permalink:"/z3guide/docs/theories/Special Relations",draft:!1,editUrl:"https://github.com/microsoft/z3guide/tree/main/website/docs-smtlib/02 - theories/10 - Special Relations.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{title:"Special Relations",sidebar_position:10},sidebar:"smtlibSidebar",previous:{title:"Unicode Characters",permalink:"/z3guide/docs/theories/Characters"},next:{title:"Introduction",permalink:"/z3guide/docs/strategies/intro"}},u={},c=[{value:"Special Binary Relations",id:"special-binary-relations",level:2},{value:"Partial Order",id:"partial-order",level:3},{value:"Linear Order",id:"linear-order",level:3},{value:"Tree Order",id:"tree-order",level:3},{value:"Piece-wise Linear Order",id:"piece-wise-linear-order",level:3},{value:"Transitive Closures",id:"transitive-closures",level:2}],p={toc:c};function f(e){let{components:r,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,t,{components:r,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"special-binary-relations"},"Special Binary Relations"),(0,i.kt)("p",null,"Binary relations that are partial orders, linear orders, tree orders, and piece-wise linear orders\ncan be axiomatized using first order quantifiers. However, reasoning with these quantified axioms involves\nnon-linear overhead, up to a quadratic number of quantifier instantiations.\nThe decision procedures for partial, linear, tree and piece-wise linear orders in z3\nuse variants of Ford-Fulkerson push relabeling graphs."),(0,i.kt)("h3",{id:"partial-order"},"Partial Order"),(0,i.kt)(n(),{input:{lang:"z3",highlight:"lisp",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-sort A 0)\n(declare-fun R (A A) Bool)\n(assert (forall ((x A)) (R x x)))\n(assert (forall ((x A) (y A)) (=> (and (R x y) (R y x)) (= x y))))\n(assert (forall ((x A) (y A) (z A)) (=> (and (R x y) (R y z)) (R x z))))",result:{output:"",error:"",status:"z3-ran",hash:"a118aded699b606db9328a9a1dc67716ed829bd1"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.11.0",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,i.kt)("p",null,"Use instead"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(define-fun R ((x A) (y A)) Bool ((_ partial-order 0) x y))\n")),(0,i.kt)("p",null,"We are using the index 0 to identify the partial order relation ",(0,i.kt)("inlineCode",{parentName:"p"},"R"),". To create a different relation that is also a partial order use\na different index, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"(_ partial-order 1)"),"."),(0,i.kt)("h3",{id:"linear-order"},"Linear Order"),(0,i.kt)(n(),{input:{lang:"z3",highlight:"lisp",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-sort A 0)\n(declare-fun R (A A) Bool)\n(assert (forall ((x A)) (R x x)))\n(assert (forall ((x A) (y A)) (=> (and (R x y) (R y x)) (= x y))))\n(assert (forall ((x A) (y A) (z A)) (=> (and (R x y) (R y z)) (R x z))))\n(assert (forall ((x A) (y A)) (or (R x y) (R y x))))",result:{output:"",error:"",status:"z3-ran",hash:"55e3b1563911ab9a166d802d505d14bc13d06a55"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.11.0",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,i.kt)("p",null,"Use instead"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(define-fun R ((x A) (y A)) Bool ((_ linear-order 0) x y))\n")),(0,i.kt)("h3",{id:"tree-order"},"Tree Order"),(0,i.kt)(n(),{input:{lang:"z3",highlight:"lisp",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-sort A 0)\n(declare-fun R (A A) Bool)\n(assert (forall ((x A)) (R x x)))\n(assert (forall ((x A) (y A)) (=> (and (R x y) (R y x)) (= x y))))\n(assert (forall ((x A) (y A) (z A)) (=> (and (R x y) (R y z)) (R x z))))\n(assert (forall ((x A) (y A) (z A)) (=> (and (R x y) (R x z)) (or (R y z) (R z y)))))",result:{output:"",error:"",status:"z3-ran",hash:"a4612938bf110dcfbbc6539a561c82787f0bc33b"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.11.0",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,i.kt)("p",null,"Use instead"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(define-fun R ((x A) (y A)) Bool ((_ tree-order 0) x y))\n")),(0,i.kt)("h3",{id:"piece-wise-linear-order"},"Piece-wise Linear Order"),(0,i.kt)(n(),{input:{lang:"z3",highlight:"lisp",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-sort A 0)\n(declare-fun R (A A) Bool)\n(assert (forall ((x A)) (R x x)))\n(assert (forall ((x A) (y A)) (=> (and (R x y) (R y x)) (= x y))))\n(assert (forall ((x A) (y A) (z A)) (=> (and (R x y) (R y z)) (R x z))))\n(assert (forall ((x A) (y A) (z A)) (=> (and (R x y) (R x z)) (or (R y z) (R z y)))))\n(assert (forall ((x A) (y A) (z A)) (=> (and (R y x) (R z x)) (or (R y z) (R z y)))))",result:{output:"",error:"",status:"z3-ran",hash:"a4c0d130cd102a46ddc8707dc373090b86af4fa4"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.11.0",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,i.kt)("p",null,"Use instead"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(define-fun R ((x A) (y A)) Bool ((_ piecewise-linear-order 0) x y))\n")),(0,i.kt)("h2",{id:"transitive-closures"},"Transitive Closures"),(0,i.kt)("p",null,"The transitive closure of a relation is not first-order axiomatizable. However, the decision problem for ground formulas is decidable\nbecause for every binary relation ",(0,i.kt)("inlineCode",{parentName:"p"},"R")," over a finite domain, the transitive closure of it is defined over the finite graph of ",(0,i.kt)("inlineCode",{parentName:"p"},"R"),".\nThe small model property contrasts non-ground first-order formulas using transitive closure that are not first-order axiomatizable."),(0,i.kt)(n(),{input:{lang:"z3",highlight:"lisp",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-sort A 0)\n(declare-fun R (A A) Bool)\n(declare-fun b () A)\n(declare-fun a () A)\n(declare-fun c () A)\n(assert (R a b))\n(assert (R b c))\n(assert (not ((_ transitive-closure R) a c)))\n(check-sat)",result:{output:"unsat\n",error:"",status:"z3-ran",hash:"1d6c69b91c881a7d758e91bf17f2046e84421940"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.11.0",tool:"z3-solver"},mdxType:"CustomCodeBlock"}))}f.isMDXComponent=!0}}]);