"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[785],{2122:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>d,toc:()=>l});var n=t(3117),o=(t(7294),t(3905)),s=t(7689);const r={title:"Division"},a=void 0,d={unversionedId:"Arithmetic/division",id:"Arithmetic/division",title:"Division",description:"Z3 also has support for division, integer division, modulo and remainder operators. Internally, they are all mapped to multiplication.",source:"@site/docs/05 - Arithmetic/03 - division.md",sourceDirName:"05 - Arithmetic",slug:"/Arithmetic/division",permalink:"/rise4fun/docs/Arithmetic/division",draft:!1,editUrl:"https://github.com/microsoft/rise4fun/tree/main/website/docs/05 - Arithmetic/03 - division.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Division"},sidebar:"tutorialSidebar",previous:{title:"Arithmetic",permalink:"/rise4fun/docs/category/arithmetic"},next:{title:"Bitvectors",permalink:"/rise4fun/docs/Bitvectors"}},c={},l=[],m={toc:l};function u(e){let{components:i,...t}=e;return(0,o.kt)("wrapper",(0,n.Z)({},m,t,{components:i,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Z3 also has support for division, integer division, modulo and remainder operators. Internally, they are all mapped to multiplication."),(0,o.kt)(s.Z,{input:{code:"(declare-const a Int)\n(declare-const r1 Int)\n(declare-const r2 Int)\n(declare-const r3 Int)\n(declare-const r4 Int)\n(declare-const r5 Int)\n(declare-const r6 Int)\n(assert (= a 10))\n(assert (= r1 (div a 4))) ; integer division\n(assert (= r2 (mod a 4))) ; mod\n(assert (= r3 (rem a 4))) ; remainder\n(assert (= r4 (div a (- 4)))) ; integer division\n(assert (= r5 (mod a (- 4)))) ; mod\n(assert (= r6 (rem a (- 4)))) ; remainder\n(declare-const b Real)\n(declare-const c Real)\n(assert (= b ( c 3.0)))\n(assert (= c 20.0))\n(check-sat)\n(get-model)"},mdxType:"Z3CodeBlock"}),(0,o.kt)("p",null,"In Z3, division by zero is allowed, but the result is not specified. Division is not a partial function. Actually, in Z3 all functions are total, although the result may be underspecified in some cases like division by zero."),(0,o.kt)(s.Z,{input:{code:"(declare-const a Real)\n; The following formula is satisfiable since division by zero is not specified.\n(assert (= ( a 0.0) 10.0)) \n(check-sat)\n(get-model)\n\n; Although division by zero is not specified, division is still a function.\n; So, ( a 0.0) cannot evaluated to 10.0 and 2.0.\n(assert (= ( a 0.0) 2.0)) \n(check-sat)"},mdxType:"Z3CodeBlock"}),(0,o.kt)("p",null,"If you are not happy with this behavior, you may use ite (if-then-else) operator to guard every division, and assign whatever intepretation you like to the division by zero. This example uses define-fun constructor to create a new operator mydiv. This is essentially a macro, and Z3 will expand its definition for every application of mydiv."),(0,o.kt)(s.Z,{input:{code:"; defining my own division operator where x0.0 == 0.0 for every x.\n(define-fun mydiv ((x Real) (y Real)) Real\n  (if (not (= y 0.0))\n      ( x y)\n      0.0))\n(declare-const a Real)\n(declare-const b Real)\n(assert (= (mydiv a b) 1.0))\n(assert (= b 0.0))\n(check-sat)"},mdxType:"Z3CodeBlock"}))}u.isMDXComponent=!0}}]);