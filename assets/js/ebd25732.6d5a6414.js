"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[269],{9589:(t,e,i)=>{i.r(e),i.d(e,{assets:()=>d,contentTitle:()=>l,default:()=>u,frontMatter:()=>n,metadata:()=>r,toc:()=>c});var o=i(3117),a=(i(7294),i(3905)),s=i(7689);const n={title:"Propositional Logic",sidebar_position:3},l=void 0,r={unversionedId:"logic/propositional-logic",id:"logic/propositional-logic",title:"Propositional Logic",description:"The pre-defined sort Bool is the sort (type) of all Boolean propositional expressions. Z3 supports the usual Boolean operators and, or, xor, not, = (implication), ite (if-then-else). Bi-implications are represented using equality =. The following example shows how to prove that if p implies q and q implies r, then p implies r. We accomplish that by showing that the negation is unsatisfiable. The command define-fun is used to define a macro (aka alias). In this example, conjecture is an alias for the conjecture we want to prove.",source:"@site/docs/01 - logic/03 - propositional-logic.md",sourceDirName:"01 - logic",slug:"/logic/propositional-logic",permalink:"/z3guide/docs/logic/propositional-logic",draft:!1,editUrl:"https://github.com/microsoft/z3guide/tree/main/website/docs/01 - logic/03 - propositional-logic.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Propositional Logic",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Basic Commands",permalink:"/z3guide/docs/logic/basiccommands"},next:{title:"Uninterpreted Functions and Constants",permalink:"/z3guide/docs/logic/Uninterpreted-functions-and-constants"}},d={},c=[{value:"Satisfiability and Validity",id:"satisfiability-and-validity",level:3}],p={toc:c};function u(t){let{components:e,...i}=t;return(0,a.kt)("wrapper",(0,o.Z)({},p,i,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The pre-defined sort Bool is the sort (type) of all Boolean propositional expressions. Z3 supports the usual Boolean operators and, or, xor, not, = (implication), ite (if-then-else). Bi-implications are represented using equality =. The following example shows how to prove that if p implies q and q implies r, then p implies r. We accomplish that by showing that the negation is unsatisfiable. The command define-fun is used to define a macro (aka alias). In this example, conjecture is an alias for the conjecture we want to prove."),(0,a.kt)(s.Z,{input:{code:"(declare-const p Bool)\n(declare-const q Bool)\n(declare-const r Bool)\n(define-fun conjecture () Bool\n\t(= (and (= p q) (= q r))\n\t\t(= p r)))\n(assert (not conjecture))\n(check-sat)",result:{output:"sat\n",error:"",status:"z3-ran",hash:"9aea02143bfbe9fb6b45a5195cee9dc8783ef6c9"}},mdxType:"Z3CodeBlock"}),(0,a.kt)("h3",{id:"satisfiability-and-validity"},"Satisfiability and Validity"),(0,a.kt)("p",null,"A formula F is valid if F always evaluates to true for any assignment of appropriate values to its uninterpreted function and constant symbols. A formula F is satisfiable if there is some assignment of appropriate values to its uninterpreted function and constant symbols under which F evaluates to true. Validity is about finding a proof of a statement; satisfiability is about finding a solution to a set of constraints. Consider a formula F with some uninterpreted constants, say a and b. We can ask whether F is valid, that is whether it is always true for any combination of values for a and b. If F is always true, then not F is always false, and then not F will not have any satisfying assignment; that is, not F is unsatisfiable. That is, F is valid precisely when not F is not satisfiable (is unsatisfiable). Alternately, F is satisfiable if and only if not F is not valid (is invalid). Z3 finds satisfying assignments (or report that there are none). To determine whether a formula F is valid, we ask Z3 whether not F is satisfiable. Thus, to check the deMorgan's law is valid (i.e., to prove it), we show its negation to be unsatisfiable."),(0,a.kt)(s.Z,{input:{code:"(declare-const a Bool)\n(declare-const b Bool)\n(define-fun demorgan () Bool\n    (= (and a b) (not (or (not a) (not b)))))\n(assert (not demorgan))\n(check-sat)",result:{output:"unsat\n",error:"",status:"z3-ran",hash:"c878d07c5d386fd7da64190177edda4e6f674bce"}},mdxType:"Z3CodeBlock"}))}u.isMDXComponent=!0}}]);