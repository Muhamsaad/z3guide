"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6932],{3197:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>c,toc:()=>d});var n=s(7462),a=(s(7294),s(3905)),o=s(7634),i=s.n(o);const r={title:"Goals",sidebar_position:2},l=void 0,c={unversionedId:"strategies/goals",id:"strategies/goals",title:"Goals",description:'Z3 implements a methodology for orchestrating reasoning engines where "big" symbolic reasoning steps are represented as functions known as tactics, and tactics are composed using combinators known as tacticals. Tactics process sets of formulas called Goals.',source:"@site/docs-smtlib/03 - strategies/02 - goals.md",sourceDirName:"03 - strategies",slug:"/strategies/goals",permalink:"/z3guide/docs/strategies/goals",draft:!1,editUrl:"https://github.com/microsoft/z3guide/tree/main/website/docs-smtlib/03 - strategies/02 - goals.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Goals",sidebar_position:2},sidebar:"smtlibSidebar",previous:{title:"Introduction",permalink:"/z3guide/docs/strategies/intro"},next:{title:"Tactics",permalink:"/z3guide/docs/strategies/tactics"}},p={},d=[],u={toc:d};function m(e){let{components:t,...s}=e;return(0,a.kt)("wrapper",(0,n.Z)({},u,s,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,'Z3 implements a methodology for orchestrating reasoning engines where "big" symbolic reasoning steps are represented as functions known as ',(0,a.kt)("em",{parentName:"p"},"tactics"),", and tactics are composed using combinators known as ",(0,a.kt)("em",{parentName:"p"},"tacticals"),". Tactics process sets of formulas called Goals."),(0,a.kt)("p",null,"When a tactic is applied to some goal G, four different outcomes are possible. In SMT 2.0, the goal is the conjunction of all assertions. The tactic succeeds in showing G to be satisfiable (i.e., feasible); succeeds in showing G to be unsatisfiable (i.e., infeasible); produces a sequence of subgoals; or fails. When reducing a goal G to a sequence of subgoals G1, ..., Gn, we face the problem of model conversion. A model converter constructs a model for G using a model for some subgoal Gi."),(0,a.kt)("p",null,"In the following example, we use the command ",(0,a.kt)("inlineCode",{parentName:"p"},"apply")," to execute a tactic composed of two built-in tactics: ",(0,a.kt)("inlineCode",{parentName:"p"},"simplify")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"solve-eqs"),". The tactic ",(0,a.kt)("inlineCode",{parentName:"p"},"simplify")," applies transformations equivalent to the ones found in the ",(0,a.kt)("inlineCode",{parentName:"p"},"simplify")," command.\nThe tactic ",(0,a.kt)("inlineCode",{parentName:"p"},"solve-eqs")," eliminates variables using Gaussian elimination.\nActually, ",(0,a.kt)("inlineCode",{parentName:"p"},"solve-eqs")," is not restricted linear arithmetic, but can also eliminate arbitrary variables. The combinator ",(0,a.kt)("inlineCode",{parentName:"p"},"then")," applies ",(0,a.kt)("inlineCode",{parentName:"p"},"simplify")," to the input goal and ",(0,a.kt)("inlineCode",{parentName:"p"},"solve-eqs")," to each subgoal produced by ",(0,a.kt)("inlineCode",{parentName:"p"},"simplify"),". In this example, only one subgoal is produced."),(0,a.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Real)\n(declare-const y Real)\n\n(assert (> x 0.0))\n(assert (> y 0.0))\n(assert (= x (+ y 2.0)))\n\n(apply (then simplify solve-eqs))",result:{output:"(goals\n(goal\n  (not (<= x 0.0))\n  (not (<= x 2.0))\n  :precision precise :depth 2)\n)\n",error:"",status:"z3-ran",hash:"d94de1a33c72b81c3c42fdf04fa1429ff1918bb6"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,a.kt)("p",null,"In the example above, variable x is eliminated, and is not present in the resultant goal."),(0,a.kt)("p",null,"In Z3, a ",(0,a.kt)("em",{parentName:"p"},"clause")," is any constraint of the form ",(0,a.kt)("inlineCode",{parentName:"p"},"(or f_1 ... f_n)"),".\nThe tactic ",(0,a.kt)("inlineCode",{parentName:"p"},"split-clause")," will select a clause ",(0,a.kt)("inlineCode",{parentName:"p"},"(or f_1 ... f_n)")," in the input goal, and split it into n subgoals, one for each subformula ",(0,a.kt)("inlineCode",{parentName:"p"},"f_i"),"."),(0,a.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Real)\n(declare-const y Real)\n\n(assert (or (< x 0.0) (> x 0.0)))\n(assert (= x (+ y 1.0)))\n(assert (< y 0.0))\n\n(apply split-clause)",result:{output:"(goals\n(goal\n  (< x 0.0)\n  (= x (+ y 1.0))\n  (< y 0.0)\n  :precision precise :depth 1)\n(goal\n  (> x 0.0)\n  (= x (+ y 1.0))\n  (< y 0.0)\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"7b7f050452a357e0a6b2260a26a357d62c17c043"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}))}m.isMDXComponent=!0}}]);