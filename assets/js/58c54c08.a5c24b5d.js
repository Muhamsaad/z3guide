"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2030],{4672:(t,a,e)=>{e.r(a),e.d(a,{assets:()=>s,contentTitle:()=>o,default:()=>k,frontMatter:()=>m,metadata:()=>p,toc:()=>d});var n=e(7462),l=(e(7294),e(3905)),r=e(7634),i=e.n(r);const m={title:"Tactics Summary",sidebar_position:6},o=void 0,p={unversionedId:"strategies/summary",id:"strategies/summary",title:"Tactics Summary",description:"Tactic ackernannize_bv",source:"@site/docs-smtlib/03 - strategies/06 - summary.md",sourceDirName:"03 - strategies",slug:"/strategies/summary",permalink:"/z3guide/docs/strategies/summary",draft:!1,editUrl:"https://github.com/microsoft/z3guide/tree/main/website/docs-smtlib/03 - strategies/06 - summary.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{title:"Tactics Summary",sidebar_position:6},sidebar:"smtlibSidebar",previous:{title:"Probes",permalink:"/z3guide/docs/strategies/probes"},next:{title:"Simplifiers",permalink:"/z3guide/docs/strategies/simplifiers"}},s={},d=[{value:"Tactic ackernannize_bv",id:"tactic-ackernannize_bv",level:2},{value:"Short Description",id:"short-description",level:3},{value:"Long Description",id:"long-description",level:3},{value:"Example",id:"example",level:3},{value:"Notes",id:"notes",level:3},{value:"Tactic add-bounds",id:"tactic-add-bounds",level:2},{value:"Short Description",id:"short-description-1",level:3},{value:"Long Description",id:"long-description-1",level:3},{value:"Example",id:"example-1",level:3},{value:"Parameters",id:"parameters",level:3},{value:"Tactic aig",id:"tactic-aig",level:2},{value:"Short Description",id:"short-description-2",level:3},{value:"Long Description",id:"long-description-2",level:3},{value:"Example",id:"example-2",level:3},{value:"Parameters",id:"parameters-1",level:3},{value:"Tactic bit-blast",id:"tactic-bit-blast",level:2},{value:"Short Description",id:"short-description-3",level:3},{value:"Example",id:"example-3",level:3},{value:"Parameters",id:"parameters-2",level:3},{value:"Tactic blast-term-ite",id:"tactic-blast-term-ite",level:2},{value:"Short Description:",id:"short-description-4",level:3},{value:"Example",id:"example-4",level:3},{value:"Notes",id:"notes-1",level:3},{value:"Parameters",id:"parameters-3",level:3},{value:"Tactic bound-simplifier",id:"tactic-bound-simplifier",level:2},{value:"Short Description",id:"short-description-5",level:3},{value:"Long Description",id:"long-description-3",level:3},{value:"Tactic bv-slice",id:"tactic-bv-slice",level:2},{value:"Short Description",id:"short-description-6",level:3},{value:"Long Description",id:"long-description-4",level:3},{value:"Example",id:"example-5",level:3},{value:"Tactic bv1-blast",id:"tactic-bv1-blast",level:2},{value:"Short Description",id:"short-description-7",level:3},{value:"Long Description",id:"long-description-5",level:3},{value:"Example",id:"example-6",level:3},{value:"Parameters",id:"parameters-4",level:3},{value:"Tactic bv_bound_chk",id:"tactic-bv_bound_chk",level:2},{value:"Short Description",id:"short-description-8",level:3},{value:"Notes",id:"notes-2",level:3},{value:"Tactic bvarray2uf",id:"tactic-bvarray2uf",level:2},{value:"Short Description",id:"short-description-9",level:3},{value:"Example",id:"example-7",level:3},{value:"Parameters",id:"parameters-5",level:3},{value:"Tactic card2bv",id:"tactic-card2bv",level:2},{value:"Short Description",id:"short-description-10",level:3},{value:"Long Description",id:"long-description-6",level:3},{value:"Example",id:"example-8",level:3},{value:"Notes",id:"notes-3",level:3},{value:"Parameters",id:"parameters-6",level:3},{value:"Tactic cofactor-term-ite",id:"tactic-cofactor-term-ite",level:2},{value:"Short Description",id:"short-description-11",level:3},{value:"Notes",id:"notes-4",level:3},{value:"Parameters",id:"parameters-7",level:3},{value:"Tactic ctx-simplify",id:"tactic-ctx-simplify",level:2},{value:"Short Description:",id:"short-description-12",level:3},{value:"Example",id:"example-9",level:3},{value:"Notes",id:"notes-5",level:3},{value:"Parameters",id:"parameters-8",level:3},{value:"Tactic ctx-solver-simplify",id:"tactic-ctx-solver-simplify",level:2},{value:"Short Description",id:"short-description-13",level:3},{value:"Parameters",id:"parameters-9",level:3},{value:"Tactic degree-shift",id:"tactic-degree-shift",level:2},{value:"Short Description",id:"short-description-14",level:3},{value:"Long Description",id:"long-description-7",level:3},{value:"Example",id:"example-10",level:3},{value:"Notes",id:"notes-6",level:3},{value:"Parameters",id:"parameters-10",level:3},{value:"Tactic demodulator",id:"tactic-demodulator",level:2},{value:"Short Description:",id:"short-description-15",level:3},{value:"Long Description",id:"long-description-8",level:3},{value:"Example",id:"example-11",level:3},{value:"Notes",id:"notes-7",level:3},{value:"Tactic der",id:"tactic-der",level:2},{value:"Short Description:",id:"short-description-16",level:3},{value:"Long Description",id:"long-description-9",level:3},{value:"Example",id:"example-12",level:3},{value:"Notes",id:"notes-8",level:3},{value:"Tactic diff-neq",id:"tactic-diff-neq",level:2},{value:"Short Description",id:"short-description-17",level:3},{value:"Long Description",id:"long-description-10",level:3},{value:"Example",id:"example-13",level:3},{value:"Notes",id:"notes-9",level:3},{value:"Parameters",id:"parameters-11",level:3},{value:"Tactic distribute-forall",id:"tactic-distribute-forall",level:2},{value:"Short Description:",id:"short-description-18",level:3},{value:"Example",id:"example-14",level:3},{value:"Notes",id:"notes-10",level:3},{value:"Tactic dom-simplify",id:"tactic-dom-simplify",level:2},{value:"Short Description",id:"short-description-19",level:3},{value:"Long Description",id:"long-description-11",level:3},{value:"Example",id:"example-15",level:3},{value:"Tactic dt2bv",id:"tactic-dt2bv",level:2},{value:"Short Description",id:"short-description-20",level:3},{value:"Example",id:"example-16",level:3},{value:"Tactic elim-predicates",id:"tactic-elim-predicates",level:2},{value:"Short Description",id:"short-description-21",level:3},{value:"Long Description",id:"long-description-12",level:3},{value:"Example",id:"example-17",level:3},{value:"Notes",id:"notes-11",level:3},{value:"Tactic elim-small-bv",id:"tactic-elim-small-bv",level:2},{value:"Short Description",id:"short-description-22",level:3},{value:"Example",id:"example-18",level:3},{value:"Parameters",id:"parameters-12",level:3},{value:"Tactic elim-term-ite",id:"tactic-elim-term-ite",level:2},{value:"Short Description:",id:"short-description-23",level:3},{value:"Example",id:"example-19",level:3},{value:"Notes",id:"notes-12",level:3},{value:"Parameters",id:"parameters-13",level:3},{value:"Tactic elim-uncnstr",id:"tactic-elim-uncnstr",level:2},{value:"Short Description",id:"short-description-24",level:3},{value:"Long Description",id:"long-description-13",level:3},{value:"Boolean Connectives",id:"boolean-connectives",level:4},{value:"Arithmetic",id:"arithmetic",level:4},{value:"Bit-vectors",id:"bit-vectors",level:4},{value:"Arrays",id:"arrays",level:4},{value:"Algebraic Datatypes",id:"algebraic-datatypes",level:4},{value:"Example",id:"example-20",level:3},{value:"Notes",id:"notes-13",level:3},{value:"Parameters",id:"parameters-14",level:3},{value:"Tactic eq2bv",id:"tactic-eq2bv",level:2},{value:"Short Description",id:"short-description-25",level:3},{value:"Example",id:"example-21",level:3},{value:"Notes",id:"notes-14",level:3},{value:"Tactic euf-completion",id:"tactic-euf-completion",level:2},{value:"Short Description",id:"short-description-26",level:3},{value:"Long Description",id:"long-description-14",level:3},{value:"Tactic factor",id:"tactic-factor",level:2},{value:"Short Description",id:"short-description-27",level:3},{value:"Example",id:"example-22",level:3},{value:"Parameters",id:"parameters-15",level:3},{value:"Tactic fix-dl-var",id:"tactic-fix-dl-var",level:2},{value:"Short Description",id:"short-description-28",level:3},{value:"Example",id:"example-23",level:3},{value:"Parameters",id:"parameters-16",level:3},{value:"Tactic fm",id:"tactic-fm",level:2},{value:"Short Description",id:"short-description-29",level:3},{value:"Example",id:"example-24",level:3},{value:"Parameters",id:"parameters-17",level:3},{value:"Tactic fpa2bv",id:"tactic-fpa2bv",level:2},{value:"Short Description",id:"short-description-30",level:3},{value:"Tactic horn",id:"tactic-horn",level:2},{value:"Short Description",id:"short-description-31",level:3},{value:"Long Description",id:"long-description-15",level:3},{value:"Tactic horn-simplify",id:"tactic-horn-simplify",level:2},{value:"Short Description",id:"short-description-32",level:3},{value:"Long Description",id:"long-description-16",level:3},{value:"Parameters",id:"parameters-18",level:3},{value:"Tactic injectivity",id:"tactic-injectivity",level:2},{value:"Short Description:",id:"short-description-33",level:3},{value:"Example",id:"example-25",level:3},{value:"Notes",id:"notes-15",level:3},{value:"Parameters",id:"parameters-19",level:3},{value:"Tactic lia2card",id:"tactic-lia2card",level:2},{value:"Short Description",id:"short-description-34",level:3},{value:"Example",id:"example-26",level:3},{value:"Notes",id:"notes-16",level:3},{value:"Parameters",id:"parameters-20",level:3},{value:"Tactic lia2pb",id:"tactic-lia2pb",level:2},{value:"Short Description",id:"short-description-35",level:3},{value:"Example",id:"example-27",level:3},{value:"Parameters",id:"parameters-21",level:3},{value:"Tactic macro-finder",id:"tactic-macro-finder",level:2},{value:"Short Description",id:"short-description-36",level:3},{value:"Long Description",id:"long-description-17",level:3},{value:"Example",id:"example-28",level:3},{value:"Notes",id:"notes-17",level:3},{value:"Parameters",id:"parameters-22",level:3},{value:"Tactic max-bv-sharing",id:"tactic-max-bv-sharing",level:2},{value:"Short Description",id:"short-description-37",level:3},{value:"Long Description",id:"long-description-18",level:3},{value:"Tactic nla2bv",id:"tactic-nla2bv",level:2},{value:"Short Description",id:"short-description-38",level:3},{value:"Example",id:"example-29",level:3},{value:"Notes",id:"notes-18",level:3},{value:"Parameters",id:"parameters-23",level:3},{value:"Tactic nlsat",id:"tactic-nlsat",level:2},{value:"Short Description",id:"short-description-39",level:3},{value:"Example",id:"example-30",level:3},{value:"Parameters",id:"parameters-24",level:3},{value:"Tactic nnf",id:"tactic-nnf",level:2},{value:"Short Description:",id:"short-description-40",level:3},{value:"Long Description",id:"long-description-19",level:3},{value:"Example",id:"example-31",level:3},{value:"Notes",id:"notes-19",level:3},{value:"Parameters",id:"parameters-25",level:3},{value:"Tactic normalize-bounds",id:"tactic-normalize-bounds",level:2},{value:"Short Description",id:"short-description-41",level:3},{value:"Example",id:"example-32",level:3},{value:"Notes",id:"notes-20",level:3},{value:"Parameters",id:"parameters-26",level:3},{value:"Tactic occf",id:"tactic-occf",level:2},{value:"Short Description",id:"short-description-42",level:3},{value:"Long Description",id:"long-description-20",level:3},{value:"Example",id:"example-33",level:3},{value:"Notes",id:"notes-21",level:3},{value:"Tactic pb2bv",id:"tactic-pb2bv",level:2},{value:"Short Description",id:"short-description-43",level:3},{value:"Example",id:"example-34",level:3},{value:"Parameters",id:"parameters-27",level:3},{value:"Tactic propagate-bv-bounds",id:"tactic-propagate-bv-bounds",level:2},{value:"Short Description",id:"short-description-44",level:3},{value:"Example",id:"example-35",level:3},{value:"Notes",id:"notes-22",level:3},{value:"Parameters",id:"parameters-28",level:3},{value:"Tactic propagate-ineqs",id:"tactic-propagate-ineqs",level:2},{value:"Short Description",id:"short-description-45",level:3},{value:"Long Description",id:"long-description-21",level:3},{value:"Example",id:"example-36",level:3},{value:"Parameters",id:"parameters-29",level:3},{value:"Tactic propagate-values",id:"tactic-propagate-values",level:2},{value:"Short Description:",id:"short-description-46",level:3},{value:"Long Description",id:"long-description-22",level:3},{value:"Example",id:"example-37",level:3},{value:"Notes",id:"notes-23",level:3},{value:"Parameters",id:"parameters-30",level:3},{value:"Tactic purify-arith",id:"tactic-purify-arith",level:2},{value:"Short Description",id:"short-description-47",level:3},{value:"Example",id:"example-38",level:3},{value:"Parameters",id:"parameters-31",level:3},{value:"Tactic qe",id:"tactic-qe",level:2},{value:"Short Description",id:"short-description-48",level:3},{value:"Long Description",id:"long-description-23",level:3},{value:"Example",id:"example-39",level:3},{value:"Parameters",id:"parameters-32",level:3},{value:"Tactic qffp",id:"tactic-qffp",level:2},{value:"Short Description",id:"short-description-49",level:3},{value:"Tactic qffpbv",id:"tactic-qffpbv",level:2},{value:"Short Description",id:"short-description-50",level:3},{value:"Parameters",id:"parameters-33",level:3},{value:"Tactic qfnra-nlsat",id:"tactic-qfnra-nlsat",level:2},{value:"Short Description",id:"short-description-51",level:3},{value:"Example",id:"example-40",level:3},{value:"Parameters",id:"parameters-34",level:3},{value:"Tactic quasi-macro-finder",id:"tactic-quasi-macro-finder",level:2},{value:"Short Description",id:"short-description-52",level:3},{value:"Long Description",id:"long-description-24",level:3},{value:"Example",id:"example-41",level:3},{value:"Notes",id:"notes-24",level:3},{value:"Tactic recover-01",id:"tactic-recover-01",level:2},{value:"Short Description",id:"short-description-53",level:3},{value:"Long Description",id:"long-description-25",level:3},{value:"Example",id:"example-42",level:3},{value:"Notes",id:"notes-25",level:3},{value:"Parameters",id:"parameters-35",level:3},{value:"Tactic reduce-args",id:"tactic-reduce-args",level:2},{value:"Short Description:",id:"short-description-54",level:3},{value:"Long Description",id:"long-description-26",level:3},{value:"Example",id:"example-43",level:3},{value:"Notes",id:"notes-26",level:3},{value:"Tactic reduce-bv-size",id:"tactic-reduce-bv-size",level:2},{value:"Short Description",id:"short-description-55",level:3},{value:"Long Description",id:"long-description-27",level:3},{value:"Example",id:"example-44",level:3},{value:"Notes",id:"notes-27",level:3},{value:"Tactic sat",id:"tactic-sat",level:2},{value:"Short Description",id:"short-description-56",level:3},{value:"Tactic sat-preprocess",id:"tactic-sat-preprocess",level:2},{value:"Short Description",id:"short-description-57",level:3},{value:"Example",id:"example-45",level:3},{value:"Parameters",id:"parameters-36",level:3},{value:"Tactic simplify",id:"tactic-simplify",level:2},{value:"Short Description:",id:"short-description-58",level:3},{value:"Long Description",id:"long-description-28",level:3},{value:"Example",id:"example-46",level:3},{value:"Notes",id:"notes-28",level:3},{value:"Parameters",id:"parameters-37",level:3},{value:"Tactic solve-eqs",id:"tactic-solve-eqs",level:2},{value:"Short Description",id:"short-description-59",level:3},{value:"Long Description",id:"long-description-29",level:3},{value:"Example",id:"example-47",level:3},{value:"Notes",id:"notes-29",level:3},{value:"Parameters",id:"parameters-38",level:3},{value:"Tactic split-clause",id:"tactic-split-clause",level:2},{value:"Short Description",id:"short-description-60",level:3},{value:"Example",id:"example-48",level:3},{value:"Parameters",id:"parameters-39",level:3},{value:"Tactic symmetry-reduce",id:"tactic-symmetry-reduce",level:2},{value:"Short Description",id:"short-description-61",level:3},{value:"Long Description",id:"long-description-30",level:3},{value:"Tactic tseitin-cnf",id:"tactic-tseitin-cnf",level:2},{value:"Short Description",id:"short-description-62",level:3},{value:"Long Description",id:"long-description-31",level:3},{value:"Example",id:"example-49",level:3},{value:"Parameters",id:"parameters-40",level:3},{value:"Tactic unit-subsume-simplify",id:"tactic-unit-subsume-simplify",level:2},{value:"Short Description",id:"short-description-63",level:3},{value:"Long Description",id:"long-description-32",level:3}],u={toc:d};function k(t){let{components:a,...e}=t;return(0,l.kt)("wrapper",(0,n.Z)({},u,e,{components:a,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"tactic-ackernannize_bv"},"Tactic ackernannize_bv"),(0,l.kt)("h3",{id:"short-description"},"Short Description"),(0,l.kt)("p",null,"A tactic for performing Ackermann reduction for bit-vector formulas"),(0,l.kt)("h3",{id:"long-description"},"Long Description"),(0,l.kt)("p",null,"The Ackermann reduction replaces uninterpreted functions ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("mi",{parentName:"mrow"},"f"),(0,l.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,l.kt)("msub",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msub"},"t"),(0,l.kt)("mn",{parentName:"msub"},"1")),(0,l.kt)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,l.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,l.kt)("mi",{parentName:"mrow"},"f"),(0,l.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,l.kt)("msub",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msub"},"t"),(0,l.kt)("mn",{parentName:"msub"},"2")),(0,l.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"f(t_1), f(t_2)")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,l.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"f"),(0,l.kt)("span",{parentName:"span",className:"mopen"},"("),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},"1")))),(0,l.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,l.kt)("span",{parentName:"span"})))))),(0,l.kt)("span",{parentName:"span",className:"mclose"},")"),(0,l.kt)("span",{parentName:"span",className:"mpunct"},","),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,l.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"f"),(0,l.kt)("span",{parentName:"span",className:"mopen"},"("),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},"2")))),(0,l.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,l.kt)("span",{parentName:"span"})))))),(0,l.kt)("span",{parentName:"span",className:"mclose"},")"))))),"\nby fresh variables ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("msub",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msub"},"f"),(0,l.kt)("mn",{parentName:"msub"},"1")),(0,l.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,l.kt)("msub",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msub"},"f"),(0,l.kt)("mn",{parentName:"msub"},"2"))),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"f_1, f_2")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"f"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"-0.1076em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},"1")))),(0,l.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,l.kt)("span",{parentName:"span"})))))),(0,l.kt)("span",{parentName:"span",className:"mpunct"},","),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"f"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"-0.1076em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},"2")))),(0,l.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,l.kt)("span",{parentName:"span"}))))))))))," and addes axioms ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("msub",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msub"},"t"),(0,l.kt)("mn",{parentName:"msub"},"1")),(0,l.kt)("mo",{parentName:"mrow"},"\u2243"),(0,l.kt)("msub",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msub"},"t"),(0,l.kt)("mn",{parentName:"msub"},"2")),(0,l.kt)("mtext",{parentName:"mrow"},"\u2005\u200a"),(0,l.kt)("mo",{parentName:"mrow"},"\u27f9"),(0,l.kt)("mtext",{parentName:"mrow"},"\u2005\u200a"),(0,l.kt)("msub",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msub"},"f"),(0,l.kt)("mn",{parentName:"msub"},"1")),(0,l.kt)("mo",{parentName:"mrow"},"\u2243"),(0,l.kt)("msub",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msub"},"f"),(0,l.kt)("mn",{parentName:"msub"},"2"))),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"t_1 \\simeq t_2 \\implies f_1 \\simeq f_2")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.7651em",verticalAlign:"-0.15em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},"1")))),(0,l.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,l.kt)("span",{parentName:"span"})))))),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,l.kt)("span",{parentName:"span",className:"mrel"},"\u2243"),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.7651em",verticalAlign:"-0.15em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},"2")))),(0,l.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,l.kt)("span",{parentName:"span"})))))),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,l.kt)("span",{parentName:"span",className:"mrel"},"\u27f9"),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"f"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"-0.1076em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},"1")))),(0,l.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,l.kt)("span",{parentName:"span"})))))),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,l.kt)("span",{parentName:"span",className:"mrel"},"\u2243"),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"f"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"-0.1076em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},"2")))),(0,l.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,l.kt)("span",{parentName:"span"})))))))))),".\nThe reduction has the effect of eliminating uninterpreted functions. When the reduction\nproduces a pure bit-vector benchmark, it allows Z3 to use a specialized SAT solver."),(0,l.kt)("h3",{id:"example"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x (_ BitVec 32))\n(declare-const y (_ BitVec 32))\n(declare-fun f ((_ BitVec 32)) (_ BitVec 8))\n\n(assert (not (= (f x) (f y))))\n(apply ackermannize_bv)",result:{output:"(goals\n(goal\n  (not (= f!0 f!1))\n  (or (not (= x y)) (= f!0 f!1))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"74329301395f9554a829c87fb9230c36fce1b65f"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"notes"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"does not support proofs, does not support unsatisfiable cores")),(0,l.kt)("h2",{id:"tactic-add-bounds"},"Tactic add-bounds"),(0,l.kt)("h3",{id:"short-description-1"},"Short Description"),(0,l.kt)("p",null,"Tactic for bounding unbounded variables."),(0,l.kt)("h3",{id:"long-description-1"},"Long Description"),(0,l.kt)("p",null,"The tactic creates a stronger sub-goal by adding bounds to variables.\nThe new goal may not be satisfiable even if the original goal is."),(0,l.kt)("h3",{id:"example-1"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Int)\n(declare-const y Int)\n(assert (> (+ x y) 10))\n(apply add-bounds)",result:{output:"(goals\n(goal\n  (> (+ x y) 10)\n  (<= x 2)\n  (>= x (- 2))\n  (<= y 2)\n  (>= y (- 2))\n  :precision under :depth 1)\n)\n",error:"",status:"z3-ran",hash:"f50fdde1b17ebb3299038d69d818ba6b2a3b1010"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"parameters"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"add_bound_lower"),(0,l.kt)("td",{parentName:"tr",align:null},"rational"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: -2) lower bound to be added to unbounded variables."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"add_bound_upper"),(0,l.kt)("td",{parentName:"tr",align:null},"rational"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: 2) upper bound to be added to unbounded variables."),(0,l.kt)("td",{parentName:"tr",align:null})))),(0,l.kt)("h2",{id:"tactic-aig"},"Tactic aig"),(0,l.kt)("h3",{id:"short-description-2"},"Short Description"),(0,l.kt)("p",null,"Simplify Boolean structure using AIGs (And-inverter graphs)."),(0,l.kt)("h3",{id:"long-description-2"},"Long Description"),(0,l.kt)("p",null,"And-inverter graphs (AIGs) uses just the Boolean connectives ",(0,l.kt)("inlineCode",{parentName:"p"},"and")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"not")," to encode Boolean\nformulas. The circuit representation using AIGs first converts formulas using other connectives to this normal form,\nthen performs local simplification steps to minimize the circuit representation.\nNote that the simplification steps used by this tactic are heuristic, trading speed for power,\nand do not represent a high-quality circuit minimization approach."),(0,l.kt)("h3",{id:"example-2"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const a Bool)\n(declare-const b Bool)\n(declare-const c Bool)\n(assert (or (and a b) (and b a c)))\n(apply aig)",result:{output:"(goals\n(goal\n  true\n  b\n  a\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"43f15c9761cef8b466248ab67db94242035b176b"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"parameters-1"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum amount of memory in megabytes."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")))),(0,l.kt)("h2",{id:"tactic-bit-blast"},"Tactic bit-blast"),(0,l.kt)("h3",{id:"short-description-3"},"Short Description"),(0,l.kt)("p",null,"Apply bit-blasting to a given goal."),(0,l.kt)("h3",{id:"example-3"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x (_ BitVec 8))\n(declare-const y (_ BitVec 8))\n(assert (bvule x y))\n(apply bit-blast)",result:{output:"(goals\n(goal\n  (let ((a!1 (or k!1 (not (or k!8 (not k!0)))))\n        (a!2 (or (not k!9) (not (or k!8 (not k!0))))))\n  (let ((a!3 (or (not (or k!1 (not k!9))) (not a!1) (not a!2))))\n  (let ((a!4 (or (not (or k!2 (not k!10)))\n                 (not (or k!2 (not a!3)))\n                 (not (or (not k!10) (not a!3))))))\n  (let ((a!5 (or (not (or k!3 (not k!11)))\n                 (not (or k!3 (not a!4)))\n                 (not (or (not k!11) (not a!4))))))\n  (let ((a!6 (or (not (or k!4 (not k!12)))\n                 (not (or k!4 (not a!5)))\n                 (not (or (not k!12) (not a!5))))))\n  (let ((a!7 (or (not (or k!5 (not k!13)))\n                 (not (or k!5 (not a!6)))\n                 (not (or (not k!13) (not a!6))))))\n  (let ((a!8 (or (not (or k!6 (not k!14)))\n                 (not (or k!6 (not a!7)))\n                 (not (or (not k!14) (not a!7))))))\n    (or (not (or k!7 (not k!15)))\n        (not (or k!7 (not a!8)))\n        (not (or (not k!15) (not a!8)))))))))))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"f653d1af4607ee461f98419e8fa17e125c250fc3"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"parameters-2"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_add"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"bit-blast adders."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_full"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"bit-blast any term with bit-vector sort, this option will make E-matching ineffective in any pattern containing bit-vector terms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_mul"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"bit-blast multipliers (and dividers, remainders)."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_quant"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"bit-blast quantified variables."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum amount of memory in megabytes."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_steps"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum number of steps."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")))),(0,l.kt)("h2",{id:"tactic-blast-term-ite"},"Tactic blast-term-ite"),(0,l.kt)("h3",{id:"short-description-4"},"Short Description:"),(0,l.kt)("p",null,"Blast term if-then-else by hoisting them up.\nThis is expensive but useful in some cases, such as\nfor enforcing constraints being in difference logic.\nUse ",(0,l.kt)("inlineCode",{parentName:"p"},"elim-term-ite")," elsewhere when possible."),(0,l.kt)("h3",{id:"example-4"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-fun f (Int) Int)\n(declare-fun p (Int) Bool)\n(declare-const c1 Bool)\n(declare-const c2 Bool)\n(declare-const c3 Bool)\n(declare-const e1 Int) \n(declare-const e2 Int) \n(declare-const e3 Int)\n(declare-const e4 Int)\n(assert (p (f (if c1 (if c2 e1 (if c3 e2 e3)) e4))))\n(apply blast-term-ite) ",result:{output:"(goals\n(goal\n  (let ((a!1 (ite c2 (p (f e1)) (ite c3 (p (f e2)) (p (f e3))))))\n    (ite c1 a!1 (p (f e4))))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"3c18719d6b7d3fed728671347d6673e381f85e07"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"notes-1"},"Notes"),(0,l.kt)("h3",{id:"parameters-3"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_inflation"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infinity) multiplicative factor of initial term size."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum amount of memory in megabytes."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_steps"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum number of steps."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")))),(0,l.kt)("h2",{id:"tactic-bound-simplifier"},"Tactic bound-simplifier"),(0,l.kt)("h3",{id:"short-description-5"},"Short Description"),(0,l.kt)("p",null,"Tactic for simplifying arithmetical expressions modulo bounds"),(0,l.kt)("h3",{id:"long-description-3"},"Long Description"),(0,l.kt)("p",null,"The tactic is used to eliminate occurrences of modulus expressions when it is known that terms are within the bounds\nof the modulus."),(0,l.kt)("h2",{id:"tactic-bv-slice"},"Tactic bv-slice"),(0,l.kt)("h3",{id:"short-description-6"},"Short Description"),(0,l.kt)("p",null,"Slices bit-vectors into sub-ranges to allow simplifying sub-ranges."),(0,l.kt)("h3",{id:"long-description-4"},"Long Description"),(0,l.kt)("p",null,"It rewrites a state using bit-vector slices.\nSlices are extracted from bit-vector equality assertions.\nAn equality assertion may equate a sub-range of a bit-vector\nwith a constant. The tactic ensures that all occurrences of the\nsubrange are replaced by the constants to allow additional\nsimplification"),(0,l.kt)("h3",{id:"example-5"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x (_ BitVec 32))\n(declare-const y (_ BitVec 32))\n        (assert (= ((_ extract 31 16) x) (_ bv123 16)))\n(assert (= ((_ extract 15 0) x) ((_ extract 16 1) y)))\n(assert (= (bvadd x x) y))\n(apply bv-slice)",result:{output:"(goals\n(goal\n  (= ((_ extract 31 16) x) #x007b)\n  (= ((_ extract 15 0) x) ((_ extract 16 1) y))\n  (= (bvmul #x00000002 (concat ((_ extract 31 16) x) ((_ extract 15 0) x)))\n     (concat ((_ extract 31 17) y) ((_ extract 16 1) y) ((_ extract 0 0) y)))\n  :precision precise :depth 1)\n)\n",error:"(goals\n(goal\n  (= ((_ extract 31 16) x) #x007b)\n  (= ((_ extract 15 0) x) ((_ extract 16 1) y))\n  (= (bvmul #x00000002 (concat ((_ extract 31 16) x) ((_ extract 15 0) x)))\n     (concat ((_ extract 31 17) y) ((_ extract 16 1) y) ((_ extract 0 0) y)))\n  :precision precise :depth 1)\n)\n",status:"z3-runtime-error",hash:"50890fd88ba987beadecad7d62152c001abf494c"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h2",{id:"tactic-bv1-blast"},"Tactic bv1-blast"),(0,l.kt)("h3",{id:"short-description-7"},"Short Description"),(0,l.kt)("p",null,"Reduce bit-vector expressions into bit-vectors of size 1 (notes: only equality, extract and concat are supported)."),(0,l.kt)("h3",{id:"long-description-5"},"Long Description"),(0,l.kt)("p",null,'Rewriter for "blasting" bit-vectors of size n into bit-vectors of size 1.\nThis rewriter only supports concat and extract operators.\nThis transformation is useful for handling benchmarks that contain\nmany BV equalities. '),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Remark"),": other operators can be mapped into concat/extract by using\nthe simplifiers."),(0,l.kt)("h3",{id:"example-6"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x (_ BitVec 8))\n(declare-const y (_ BitVec 4))\n(declare-const z (_ BitVec 4))\n(assert (= (concat y z) x))\n    (apply bv1-blast)",result:{output:"(goals\n(goal\n  (= k!7 k!15)\n  (= k!6 k!14)\n  (= k!5 k!13)\n  (= k!4 k!12)\n  (= k!3 k!11)\n  (= k!2 k!10)\n  (= k!1 k!9)\n  (= k!0 k!8)\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"9982a82f17895b8cea5d13bbc18b9147387706ba"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"parameters-4"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum amount of memory in megabytes."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_steps"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum number of steps."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")))),(0,l.kt)("h2",{id:"tactic-bv_bound_chk"},"Tactic bv_bound_chk"),(0,l.kt)("h3",{id:"short-description-8"},"Short Description"),(0,l.kt)("p",null,"Attempts to detect inconsistencies of bounds on bv expressions."),(0,l.kt)("h3",{id:"notes-2"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"does not support proofs, does not support cores")),(0,l.kt)("h2",{id:"tactic-bvarray2uf"},"Tactic bvarray2uf"),(0,l.kt)("h3",{id:"short-description-9"},"Short Description"),(0,l.kt)("p",null,"Tactic that rewrites bit-vector arrays into bit-vector\n(uninterpreted) functions."),(0,l.kt)("h3",{id:"example-7"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const a (Array (_ BitVec 32) (_ BitVec 32)))\n(declare-const b (_ BitVec 32))\n(declare-const c (_ BitVec 32))\n(assert (= (select a b) c))\n(apply bvarray2uf)",result:{output:"(goals\n(goal\n  (= (f_t!!0 b) c)\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"7939d981c0757cf649a0691cbe5cfbc9c5ae16bc"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"parameters-5"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"produce_models"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"model generation."),(0,l.kt)("td",{parentName:"tr",align:null},"false")))),(0,l.kt)("h2",{id:"tactic-card2bv"},"Tactic card2bv"),(0,l.kt)("h3",{id:"short-description-10"},"Short Description"),(0,l.kt)("p",null,"Tactic for converting Pseudo-Boolean constraints to bit-vectors."),(0,l.kt)("h3",{id:"long-description-6"},"Long Description"),(0,l.kt)("p",null,"The tactic implements a set of standard methods for converting cardinality and Pseudo-Boolean constraints into bit-vector or propositional formulas\n(using basic logical connectives, conjunction, disjunction, negation). The conversions from cardinality constraints are controlled\nseparately from the conversions from Pseudo-Boolean constraints using different parameters."),(0,l.kt)("h3",{id:"example-8"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const a1 Bool)\n(declare-const a2 Bool)\n(declare-const a3 Bool)\n(declare-const a4 Bool)\n(declare-const a5 Bool)\n(declare-const a6 Bool)\n(push)\n(assert ((_ at-most 1) a1 a2 a3 a4 a5 a6))\n(assert ((_ at-most 2) a1 a2 a3 a4 a5 a6))\n(apply (with card2bv :cardinality.encoding unate))\n(apply (with card2bv :cardinality.encoding circuit))\n(apply (with card2bv :cardinality.encoding ordered))\n(apply (with card2bv :cardinality.encoding grouped))\n(apply (with card2bv :cardinality.encoding bimander))\n(pop)\n(assert ((_ pbge 5 2 3 4 4 3 5) a1 a2 a3 a4 a5 a6))\n(apply (with card2bv :pb.solver totalizer))\n(apply (with card2bv :pb.solver sorting))\n(apply (with card2bv :pb.solver binary_merge))\n(apply (with card2bv :pb.solver bv))\n(apply (with card2bv :pb.solver solver))",result:{output:"(goals\n(goal\n  at-most-1!0\n  (let ((a!1 (and a5 (or a4 (or a3 (or a2 a1))))))\n  (let ((a!2 (or a!1\n                 (and a4 (or a3 (or a2 a1)))\n                 (and a3 (or a2 a1))\n                 (and a2 a1))))\n    (not (and a6 a!2))))\n  (let ((a!1 (or (and a4 (or a3 (or a2 a1))) (and a3 (or a2 a1)) (and a2 a1))))\n    (not (and a5 a!1)))\n  (let ((a!1 (and a4 (or (and a3 (or a2 a1)) (and a2 a1)))))\n    (not a!1))\n  (not (and a3 a2 a1))\n  (or (not at-most-1!0) (not a1) (not a2))\n  (or (not at-most-1!0) (not a1) (not a3))\n  (or (not at-most-1!0) (not a1) (not a4))\n  (or (not at-most-1!0) (not a2) (not a3))\n  (or (not at-most-1!0) (not a2) (not a4))\n  (or (not at-most-1!0) (not a3) (not a4))\n  (or (not at-most-1!0) (not a5) (not a6))\n  (or (not at-most-1!0) (not (or a1 a2 a3 a4)) (not (or a5 a6)))\n  :precision precise :depth 1)\n)\n(goals\n(goal\n  at-most-1!1\n  (let ((a!1 (and a1 (or (and a2 (not a3)) (and a3 (not a2))) a2 a3)))\n    (not a!1))\n  (let ((a!1 (and a4 (or (and a5 (not a6)) (and a6 (not a5))) a5 a6)))\n    (not a!1))\n  (let ((a!1 (not (or (and a2 (not a3)) (and a3 (not a2)))))\n        (a!2 (and (or (and a2 (not a3)) (and a3 (not a2))) (not a1)))\n        (a!3 (not (or (and a5 (not a6)) (and a6 (not a5)))))\n        (a!4 (and (or (and a5 (not a6)) (and a6 (not a5))) (not a4)))\n        (a!5 (and a1 (or (and a2 (not a3)) (and a3 (not a2))))))\n  (let ((a!6 (or (and a!5 (not (and a2 a3))) (and (and a2 a3) (not a!5)))))\n    (not (and (or (and a1 a!1) a!2) (or (and a4 a!3) a!4) a!6))))\n  (let ((a!1 (not (or (and a2 (not a3)) (and a3 (not a2)))))\n        (a!2 (and (or (and a2 (not a3)) (and a3 (not a2))) (not a1)))\n        (a!3 (not (or (and a5 (not a6)) (and a6 (not a5)))))\n        (a!4 (and (or (and a5 (not a6)) (and a6 (not a5))) (not a4)))\n        (a!5 (and a4 (or (and a5 (not a6)) (and a6 (not a5))))))\n  (let ((a!6 (or (and a!5 (not (and a5 a6))) (and (and a5 a6) (not a!5)))))\n    (not (and (or (and a1 a!1) a!2) (or (and a4 a!3) a!4) a!6))))\n  (let ((a!1 (and a1 (or (and a2 (not a3)) (and a3 (not a2)))))\n        (a!3 (and a4 (or (and a5 (not a6)) (and a6 (not a5))))))\n  (let ((a!2 (or (and a!1 (not (and a2 a3))) (and (and a2 a3) (not a!1))))\n        (a!4 (or (and a!3 (not (and a5 a6))) (and (and a5 a6) (not a!3)))))\n    (not (and a!2 a!4))))\n  (let ((a!1 (not (or (and a2 (not a3)) (and a3 (not a2)))))\n        (a!2 (and (or (and a2 (not a3)) (and a3 (not a2))) (not a1)))\n        (a!3 (not (or (and a5 (not a6)) (and a6 (not a5)))))\n        (a!4 (and (or (and a5 (not a6)) (and a6 (not a5))) (not a4)))\n        (a!6 (and a1 (or (and a2 (not a3)) (and a3 (not a2)))))\n        (a!8 (and a4 (or (and a5 (not a6)) (and a6 (not a5))))))\n  (let ((a!5 (and (or (and a1 a!1) a!2) (or (and a4 a!3) a!4)))\n        (a!7 (or (and a!6 (not (and a2 a3))) (and (and a2 a3) (not a!6))))\n        (a!9 (or (and a!8 (not (and a5 a6))) (and (and a5 a6) (not a!8))))\n        (a!10 (and (or (and a1 a!1) a!2) (not (or (and a4 a!3) a!4))))\n        (a!11 (and (or (and a4 a!3) a!4) (not (or (and a1 a!1) a!2)))))\n  (let ((a!12 (and (or (and a!5 (not a!7) (not a!9))\n                       (and a!7 (not a!5) (not a!9))\n                       (and a!9 (not a!5) (not a!7))\n                       (and a!5 a!7 a!9))\n                   (or a!10 a!11))))\n    (not a!12))))\n  (or (not at-most-1!1) (not a1) (not a2))\n  (or (not at-most-1!1) (not a1) (not a3))\n  (or (not at-most-1!1) (not a1) (not a4))\n  (or (not at-most-1!1) (not a2) (not a3))\n  (or (not at-most-1!1) (not a2) (not a4))\n  (or (not at-most-1!1) (not a3) (not a4))\n  (or (not at-most-1!1) (not a5) (not a6))\n  (or (not at-most-1!1) (not (or a1 a2 a3 a4)) (not (or a5 a6)))\n  :precision precise :depth 1)\n)\n(goals\n(goal\n  ordered!2\n  (not dsort!10)\n  (or (not y!3) y!4)\n  (or (not y!4) y!5)\n  (or (not y!5) y!6)\n  (or (not y!6) y!7)\n  (or (not a1) y!3)\n  (or (not ordered!2) (not y!3) (not a2))\n  (or (not a2) y!4)\n  (or (not ordered!2) (not y!4) (not a3))\n  (or (not a3) y!5)\n  (or (not ordered!2) (not y!5) (not a4))\n  (or (not a4) y!6)\n  (or (not ordered!2) (not y!6) (not a5))\n  (or (not a5) y!7)\n  (or (not ordered!2) (not y!7) (not a6))\n  (or (not y!4) a2 y!3)\n  (or (not y!5) a3 y!4)\n  (or (not y!6) a4 y!5)\n  (or (not y!7) a5 y!6)\n  (or (not y!3) a1)\n  (or dsort!8 (not a1))\n  (or dsort!8 (not a2))\n  (or dsort!8 (not a3))\n  (or dsort!8 (not a4))\n  (or dsort!8 (not a5))\n  (or dsort!8 (not a6))\n  (or dsort!9 (not a1) (not a2))\n  (or dsort!9 (not a1) (not a3))\n  (or dsort!9 (not a1) (not a4))\n  (or dsort!9 (not a1) (not a5))\n  (or dsort!9 (not a1) (not a6))\n  (or dsort!9 (not a2) (not a3))\n  (or dsort!9 (not a2) (not a4))\n  (or dsort!9 (not a2) (not a5))\n  (or dsort!9 (not a2) (not a6))\n  (or dsort!9 (not a3) (not a4))\n  (or dsort!9 (not a3) (not a5))\n  (or dsort!9 (not a3) (not a6))\n  (or dsort!9 (not a4) (not a5))\n  (or dsort!9 (not a4) (not a6))\n  (or dsort!9 (not a5) (not a6))\n  (or dsort!10 (not a1) (not a2) (not a3))\n  (or dsort!10 (not a1) (not a2) (not a4))\n  (or dsort!10 (not a1) (not a2) (not a5))\n  (or dsort!10 (not a1) (not a2) (not a6))\n  (or dsort!10 (not a1) (not a3) (not a4))\n  (or dsort!10 (not a1) (not a3) (not a5))\n  (or dsort!10 (not a1) (not a3) (not a6))\n  (or dsort!10 (not a1) (not a4) (not a5))\n  (or dsort!10 (not a1) (not a4) (not a6))\n  (or dsort!10 (not a1) (not a5) (not a6))\n  (or dsort!10 (not a2) (not a3) (not a4))\n  (or dsort!10 (not a2) (not a3) (not a5))\n  (or dsort!10 (not a2) (not a3) (not a6))\n  (or dsort!10 (not a2) (not a4) (not a5))\n  (or dsort!10 (not a2) (not a4) (not a6))\n  (or dsort!10 (not a2) (not a5) (not a6))\n  (or dsort!10 (not a3) (not a4) (not a5))\n  (or dsort!10 (not a3) (not a4) (not a6))\n  (or dsort!10 (not a3) (not a5) (not a6))\n  (or dsort!10 (not a4) (not a5) (not a6))\n  :precision precise :depth 1)\n)\n(goals\n(goal\n  at-most-1!11\n  (not dsort!14)\n  (or (not at-most-1!11) (not a1) (not a2))\n  (or (not at-most-1!11) (not a1) (not a3))\n  (or (not at-most-1!11) (not a1) (not a4))\n  (or (not at-most-1!11) (not a2) (not a3))\n  (or (not at-most-1!11) (not a2) (not a4))\n  (or (not at-most-1!11) (not a3) (not a4))\n  (or (not at-most-1!11) (not a5) (not a6))\n  (or (not at-most-1!11) (not (or a1 a2 a3 a4)) (not (or a5 a6)))\n  (or dsort!12 (not a1))\n  (or dsort!12 (not a2))\n  (or dsort!12 (not a3))\n  (or dsort!12 (not a4))\n  (or dsort!12 (not a5))\n  (or dsort!12 (not a6))\n  (or dsort!13 (not a1) (not a2))\n  (or dsort!13 (not a1) (not a3))\n  (or dsort!13 (not a1) (not a4))\n  (or dsort!13 (not a1) (not a5))\n  (or dsort!13 (not a1) (not a6))\n  (or dsort!13 (not a2) (not a3))\n  (or dsort!13 (not a2) (not a4))\n  (or dsort!13 (not a2) (not a5))\n  (or dsort!13 (not a2) (not a6))\n  (or dsort!13 (not a3) (not a4))\n  (or dsort!13 (not a3) (not a5))\n  (or dsort!13 (not a3) (not a6))\n  (or dsort!13 (not a4) (not a5))\n  (or dsort!13 (not a4) (not a6))\n  (or dsort!13 (not a5) (not a6))\n  (or dsort!14 (not a1) (not a2) (not a3))\n  (or dsort!14 (not a1) (not a2) (not a4))\n  (or dsort!14 (not a1) (not a2) (not a5))\n  (or dsort!14 (not a1) (not a2) (not a6))\n  (or dsort!14 (not a1) (not a3) (not a4))\n  (or dsort!14 (not a1) (not a3) (not a5))\n  (or dsort!14 (not a1) (not a3) (not a6))\n  (or dsort!14 (not a1) (not a4) (not a5))\n  (or dsort!14 (not a1) (not a4) (not a6))\n  (or dsort!14 (not a1) (not a5) (not a6))\n  (or dsort!14 (not a2) (not a3) (not a4))\n  (or dsort!14 (not a2) (not a3) (not a5))\n  (or dsort!14 (not a2) (not a3) (not a6))\n  (or dsort!14 (not a2) (not a4) (not a5))\n  (or dsort!14 (not a2) (not a4) (not a6))\n  (or dsort!14 (not a2) (not a5) (not a6))\n  (or dsort!14 (not a3) (not a4) (not a5))\n  (or dsort!14 (not a3) (not a4) (not a6))\n  (or dsort!14 (not a3) (not a5) (not a6))\n  (or dsort!14 (not a4) (not a5) (not a6))\n  :precision precise :depth 1)\n)\n(goals\n(goal\n  bimander!15\n  (not dsort!20)\n  (or (not bimander!15) (not a1) (not a2))\n  (or (not bimander!15) (not a3) (not a4))\n  (or (not bimander!15) (not a5) (not a6))\n  (or (not bimander!15) (not (or a1 a2)) (not bit!16))\n  (or (not bimander!15) (not (or a1 a2)) (not bit!17))\n  (or (not bimander!15) (not (or a3 a4)) bit!16)\n  (or (not bimander!15) (not (or a3 a4)) (not bit!17))\n  (or (not bimander!15) (not (or a5 a6)) (not bit!16))\n  (or (not bimander!15) (not (or a5 a6)) bit!17)\n  (or dsort!18 (not a1))\n  (or dsort!18 (not a2))\n  (or dsort!18 (not a3))\n  (or dsort!18 (not a4))\n  (or dsort!18 (not a5))\n  (or dsort!18 (not a6))\n  (or dsort!19 (not a1) (not a2))\n  (or dsort!19 (not a1) (not a3))\n  (or dsort!19 (not a1) (not a4))\n  (or dsort!19 (not a1) (not a5))\n  (or dsort!19 (not a1) (not a6))\n  (or dsort!19 (not a2) (not a3))\n  (or dsort!19 (not a2) (not a4))\n  (or dsort!19 (not a2) (not a5))\n  (or dsort!19 (not a2) (not a6))\n  (or dsort!19 (not a3) (not a4))\n  (or dsort!19 (not a3) (not a5))\n  (or dsort!19 (not a3) (not a6))\n  (or dsort!19 (not a4) (not a5))\n  (or dsort!19 (not a4) (not a6))\n  (or dsort!19 (not a5) (not a6))\n  (or dsort!20 (not a1) (not a2) (not a3))\n  (or dsort!20 (not a1) (not a2) (not a4))\n  (or dsort!20 (not a1) (not a2) (not a5))\n  (or dsort!20 (not a1) (not a2) (not a6))\n  (or dsort!20 (not a1) (not a3) (not a4))\n  (or dsort!20 (not a1) (not a3) (not a5))\n  (or dsort!20 (not a1) (not a3) (not a6))\n  (or dsort!20 (not a1) (not a4) (not a5))\n  (or dsort!20 (not a1) (not a4) (not a6))\n  (or dsort!20 (not a1) (not a5) (not a6))\n  (or dsort!20 (not a2) (not a3) (not a4))\n  (or dsort!20 (not a2) (not a3) (not a5))\n  (or dsort!20 (not a2) (not a3) (not a6))\n  (or dsort!20 (not a2) (not a4) (not a5))\n  (or dsort!20 (not a2) (not a4) (not a6))\n  (or dsort!20 (not a2) (not a5) (not a6))\n  (or dsort!20 (not a3) (not a4) (not a5))\n  (or dsort!20 (not a3) (not a4) (not a6))\n  (or dsort!20 (not a3) (not a5) (not a6))\n  (or dsort!20 (not a4) (not a5) (not a6))\n  :precision precise :depth 1)\n)\n(goals\n(goal\n  (or a6\n      (and a1 a5)\n      (and a2 a5)\n      (and (or a4 a3) a5)\n      (and a3 a4)\n      (and a1 (or a4 a3))\n      (and a2 (or a4 a3))\n      (and a1 a2))\n  :precision precise :depth 1)\n)\n(goals\n(goal\n  (let ((a!1 (or (and dsort!21 (not dsort!22))\n                 (and dsort!23 (not dsort!24))\n                 (and (or a2 a5) (not (and a2 a5))))))\n  (let ((a!2 (and (or (and dsort!25 (not dsort!27)) dsort!28) a!1)))\n    (or a6 dsort!27 (and dsort!26 (not dsort!27)) a!2)))\n  (or (not a2) a2 a5)\n  (or (not a5) a2 a5)\n  (or (not a2) (not a5) (and a2 a5))\n  (or dsort!21 (not (and a2 a5)))\n  (or dsort!21 (not a1))\n  (or dsort!21 (not a2))\n  (or dsort!21 (not a5))\n  (or dsort!22 (not (and a2 a5)) (not a1))\n  (or dsort!22 (not (and a2 a5)) (not a2))\n  (or dsort!22 (not (and a2 a5)) (not a5))\n  (or dsort!22 (not a1) (not a2))\n  (or dsort!22 (not a1) (not a5))\n  (or dsort!22 (not a2) (not a5))\n  (or dsort!23 (not (and a2 a5)) (not a1) (not a2))\n  (or dsort!23 (not (and a2 a5)) (not a1) (not a5))\n  (or dsort!23 (not (and a2 a5)) (not a2) (not a5))\n  (or dsort!23 (not a1) (not a2) (not a5))\n  (or dsort!24 (not (and a2 a5)) (not a1) (not a2) (not a5))\n  (or dsort!25 (not dsort!22))\n  (or dsort!25 (not dsort!24))\n  (or dsort!25 (not a3))\n  (or dsort!25 (not a4))\n  (or dsort!26 (not dsort!22) (not dsort!24))\n  (or dsort!26 (not dsort!22) (not a3))\n  (or dsort!26 (not dsort!22) (not a4))\n  (or dsort!26 (not dsort!24) (not a3))\n  (or dsort!26 (not dsort!24) (not a4))\n  (or dsort!26 (not a3) (not a4))\n  (or dsort!27 (not dsort!22) (not dsort!24) (not a3))\n  (or dsort!27 (not dsort!22) (not dsort!24) (not a4))\n  (or dsort!27 (not dsort!22) (not a3) (not a4))\n  (or dsort!27 (not dsort!24) (not a3) (not a4))\n  (or dsort!28 (not dsort!22) (not dsort!24) (not a3) (not a4))\n  :precision precise :depth 1)\n)\n(goals\n(goal\n  (or a6 dsmerge!42)\n  (or dsort!29 (not a2))\n  (or dsort!29 (not a5))\n  (or dsort!29 false)\n  (or dsort!30 (not a2) (not a5))\n  (or dsort!30 (not a2) false)\n  (or dsort!30 (not a5) false)\n  (or dsort!31 (not a2) (not a5) false)\n  (or (not dsort!30) a2 a5)\n  (or (not dsort!31) a2)\n  (or (not dsort!31) a5)\n  (or dsort!32 (not a1))\n  (or dsort!32 (not a2))\n  (or dsort!32 (not a5))\n  (or dsort!32 false)\n  (or dsort!33 (not a1) (not a2))\n  (or dsort!33 (not a1) (not a5))\n  (or dsort!33 (not a1) false)\n  (or dsort!33 (not a2) (not a5))\n  (or dsort!33 (not a2) false)\n  (or dsort!33 (not a5) false)\n  (or dsort!34 (not a1) (not a2) (not a5))\n  (or dsort!34 (not a1) (not a2) false)\n  (or dsort!34 (not a1) (not a5) false)\n  (or dsort!34 (not a2) (not a5) false)\n  (or dsort!35 (not a1) (not a2) (not a5) false)\n  (or (not dsort!33) a1 a2 a5)\n  (or (not dsort!34) a1 a2)\n  (or (not dsort!34) a1 a5)\n  (or (not dsort!34) a2 a5)\n  (or (not dsort!35) a1)\n  (or (not dsort!35) a2)\n  (or (not dsort!35) a5)\n  (or (not dsort!32) dsmerge!36)\n  (or (not dsort!33) dsmerge!37)\n  (or (not dsort!34) dsmerge!38)\n  (or (not dsort!35) dsmerge!39)\n  (or (not dsort!30) dsmerge!36)\n  (or (not dsort!32) (not dsort!30) dsmerge!37)\n  (or (not dsort!33) (not dsort!30) dsmerge!38)\n  (or (not dsort!34) (not dsort!30) dsmerge!39)\n  (or (not dsort!35) (not dsort!30) dsmerge!40)\n  (or (not dsmerge!36) dsort!32 dsort!30)\n  (or (not dsmerge!37) dsort!32)\n  (or (not dsmerge!37) dsort!33 dsort!30)\n  (or (not dsmerge!38) dsort!33)\n  (or (not dsmerge!38) dsort!34 dsort!30)\n  (or (not dsmerge!39) dsort!34)\n  (or (not dsmerge!39) dsort!35 dsort!30)\n  (or (not dsmerge!40) dsort!30)\n  (or (not dsmerge!40) dsort!35)\n  (or (not (and a3 a4)) a3)\n  (or (not (and a3 a4)) a4)\n  (or (not (or a3 a4)) a3 a4)\n  (or (not (or a3 a4)) dsmerge!41)\n  (or (not (and a3 a4)) dsmerge!42)\n  (or (not dsmerge!37) dsmerge!41)\n  (or (not dsmerge!39) dsmerge!42)\n  (or (not (or a3 a4)) (not dsmerge!37) dsmerge!42)\n  (or (not (or a3 a4)) (not dsmerge!39) dsmerge!43)\n  (or (not (and a3 a4)) (not dsmerge!37) dsmerge!43)\n  (or (not (and a3 a4)) (not dsmerge!39) dsmerge!44)\n  (or (not dsmerge!41) a3 a4 dsmerge!37)\n  (or (not dsmerge!42) a3 a4 dsmerge!39)\n  (or (not dsmerge!42) (and a3 a4) dsmerge!37)\n  (or (not dsmerge!43) dsmerge!37)\n  (or (not dsmerge!43) a3 a4)\n  (or (not dsmerge!43) (and a3 a4) dsmerge!39)\n  (or (not dsmerge!44) dsmerge!39)\n  (or (not dsmerge!44) (and a3 a4))\n  :precision precise :depth 1)\n)\n(goals\n(goal\n  (let ((a!1 (bvadd ((_ zero_extend 1) (ite a1 #x0 #x2))\n                    ((_ zero_extend 1) (ite a2 #x0 #x3))))\n        (a!2 (bvadd ((_ zero_extend 1) (ite a3 #x0 #x4))\n                    ((_ zero_extend 1) (ite a4 #x0 #x4)))))\n  (let ((a!3 ((_ extract 4 4)\n               (bvadd ((_ zero_extend 1) ((_ extract 3 0) a!1))\n                      ((_ zero_extend 1) ((_ extract 3 0) a!2)))))\n        (a!4 ((_ extract 3 0)\n               (bvadd ((_ zero_extend 1) ((_ extract 3 0) a!1))\n                      ((_ zero_extend 1) ((_ extract 3 0) a!2))))))\n  (let ((a!5 ((_ extract 4 4)\n               (bvadd ((_ zero_extend 1) a!4)\n                      ((_ zero_extend 1) (ite a5 #x0 #x3)))))\n        (a!6 ((_ extract 3 0)\n               (bvadd ((_ zero_extend 1) a!4)\n                      ((_ zero_extend 1) (ite a5 #x0 #x3))))))\n    (or a6\n        (and (= ((_ extract 4 4) a!1) #b0)\n             (bvule ((_ extract 3 0) a!1) #xb)\n             (= ((_ extract 4 4) a!2) #b0)\n             (bvule ((_ extract 3 0) a!2) #xb)\n             (= a!3 #b0)\n             (bvule a!4 #xb)\n             (= a!5 #b0)\n             (bvule a!6 #xb))))))\n  :precision precise :depth 1)\n)\n(goals\n(goal\n  (or a6 ((_ pbge 5 2 3 4 4 3) a1 a2 a3 a4 a5))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"7d698c71768bd8b6eeac9dfb8d7e0ff536f5f3c9"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"notes-3"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"supports cores"),(0,l.kt)("li",{parentName:"ul"},"does not support proofs")),(0,l.kt)("h3",{id:"parameters-6"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cardinality.encoding"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"encoding used for cardinality constraints: grouped, bimander, ordered, unate, circuit"),(0,l.kt)("td",{parentName:"tr",align:null},"none")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"keep_cardinality_constraints"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"retain cardinality constraints for solver"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pb.solver"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"encoding used for Pseudo-Boolean constraints: totalizer, sorting, binary_merge, bv, solver. PB constraints are retained if set to 'solver'"),(0,l.kt)("td",{parentName:"tr",align:null},"solver")))),(0,l.kt)("h2",{id:"tactic-cofactor-term-ite"},"Tactic cofactor-term-ite"),(0,l.kt)("h3",{id:"short-description-11"},"Short Description"),(0,l.kt)("p",null,"Eliminate (ground) term if-then-else's using cofactors.\nIt hoists nested if-then-else expressions inside terms into the top level of the formula."),(0,l.kt)("h3",{id:"notes-4"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"does not support proofs, does not support cores")),(0,l.kt)("h3",{id:"parameters-7"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cofactor_equalities"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: true) use equalities to rewrite bodies of ite-expressions. This is potentially expensive."),(0,l.kt)("td",{parentName:"tr",align:null})))),(0,l.kt)("h2",{id:"tactic-ctx-simplify"},"Tactic ctx-simplify"),(0,l.kt)("h3",{id:"short-description-12"},"Short Description:"),(0,l.kt)("p",null,"The tactic performs simplifies sub-formulas using context built up by walking assertions and sub-formulas."),(0,l.kt)("h3",{id:"example-9"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"  (declare-const p Bool)\n  (declare-const q Bool)\n  (declare-const r Bool)\n  (declare-fun f (Bool) Bool)\n  (assert p)\n  (assert (or (f p) (and r (or (not r) q))))\n  (apply ctx-simplify)",result:{output:"(goals\n(goal\n  p\n  (or (f true) (and r q))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"5f4592d1ca04bd1dc388787e3f9225461d99920c"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"notes-5"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"supports proof terms with limited features")),(0,l.kt)("h3",{id:"parameters-8"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_depth"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum term depth."),(0,l.kt)("td",{parentName:"tr",align:null},"1024")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum amount of memory in megabytes."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_steps"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum number of steps."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"propagate_eq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable equality propagation from bounds."),(0,l.kt)("td",{parentName:"tr",align:null},"false")))),(0,l.kt)("h2",{id:"tactic-ctx-solver-simplify"},"Tactic ctx-solver-simplify"),(0,l.kt)("h3",{id:"short-description-13"},"Short Description"),(0,l.kt)("p",null,"A heavy handed version of ",(0,l.kt)("inlineCode",{parentName:"p"},"ctx-simplify"),". It applies SMT checks on sub-formulas to check\nif they can be simplified to ",(0,l.kt)("inlineCode",{parentName:"p"},"true")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"false")," within their context.\nNote that a sub-formula may occur within multiple contexts due to shared sub-terms.\nIn this case the tactic is partial and simplifies a limited number of context occurrences."),(0,l.kt)("h3",{id:"parameters-9"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.auto_config_simplex"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"force simplex solver in auto_config"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.bprop_on_pivoted_rows"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"propagate bounds on rows changed by the pivot operation"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.branch_cut_ratio"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"branch/cut ratio for linear integer arithmetic"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.dump_lemmas"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"dump arithmetic theory lemmas to files"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.eager_eq_axioms"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eager equality axioms"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.enable_hnf"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable hnf (Hermite Normal Form) cuts"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.greatest_error_pivot"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Pivoting strategy"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.ignore_int"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"treat integer variables as real"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.int_eq_branch"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"branching using derived integer equations"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.min"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"minimize cost"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"(incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.branching"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.delay"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of calls to final check before invoking bounded nlsat check"),(0,l.kt)("td",{parentName:"tr",align:null},"500")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.expp"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expensive patching"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.gr_q"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"grobner's quota"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.grobner"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"run grobner's basis heuristic"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.grobner_cnfl_to_report"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"grobner's maximum number of conflicts to report"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.grobner_eqs_growth"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"grobner's number of equalities growth"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.grobner_expr_degree_growth"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"grobner's maximum expr degree growth"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.grobner_expr_size_growth"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"grobner's maximum expr size growth"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.grobner_frequency"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"grobner's call frequency"),(0,l.kt)("td",{parentName:"tr",align:null},"4")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.grobner_max_simplified"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"grobner's maximum number of simplifications"),(0,l.kt)("td",{parentName:"tr",align:null},"10000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.grobner_subs_fixed"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"0 - no subs, 1 - substitute, 2 - substitute fixed zeros only"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.horner"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"run horner's heuristic"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.horner_frequency"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"horner's call frequency"),(0,l.kt)("td",{parentName:"tr",align:null},"4")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.horner_row_length_limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"row is disregarded by the heuristic if its length is longer than the value"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.horner_subs_fixed"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"0 - no subs, 1 - substitute, 2 - substitute fixed zeros only"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.nra"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.order"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"run order lemmas"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.rounds"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2"),(0,l.kt)("td",{parentName:"tr",align:null},"1024")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.tangents"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"run tangent lemmas"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.print_ext_var_names"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"print external variable names"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.print_stats"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"print statistic"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.propagate_eqs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"propagate (cheap) equalities"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.propagation_mode"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.random_initial_value"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use random initial values in the simplex-based procedure for linear arithmetic"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.rep_freq"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"the report frequency, in how many iterations print the cost and other info"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.simplex_strategy"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"simplex strategy for the solver"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.solver"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver"),(0,l.kt)("td",{parentName:"tr",align:null},"6")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"array.extensional"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extensional array theory"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"array.weak"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"weak array theory"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"auto_config"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"automatically configure solver"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv.delay"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"delay internalize expensive bit-vector operations"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv.enable_int2bv"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable support for int2bv and bv2int operators"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv.eq_axioms"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable redundant equality axioms for bit-vectors"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv.reflect"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"create enode for every bit-vector term"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv.size_reduce"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"pre-processing; turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv.watch_diseq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use watch lists instead of eager axioms for bit-vectors"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"candidate_models"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"create candidate models even when quantifier or theory reasoning is incomplete"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"case_split"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"clause_proof"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"record a clausal proof"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"core.extend_nonlocal_patterns"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"core.extend_patterns"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extend unsat core with literals that trigger (potential) quantifier instances"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"core.extend_patterns.max_distance"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"limits the distance of a pattern-extended unsat core"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"core.minimize"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"minimize unsat core produced by SMT context"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"core.validate"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"[internal]"," validate unsat core produced by SMT context. This option is intended for debugging"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cube_depth"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"cube depth."),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"dack"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"dack.eq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable dynamic ackermannization for transtivity of equalities"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"dack.factor"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"number of instance per conflict"),(0,l.kt)("td",{parentName:"tr",align:null},"0.1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"dack.gc"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"Dynamic ackermannization garbage collection frequency (per conflict)"),(0,l.kt)("td",{parentName:"tr",align:null},"2000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"dack.gc_inv_decay"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"Dynamic ackermannization garbage collection decay"),(0,l.kt)("td",{parentName:"tr",align:null},"0.8")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"dack.threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of times the congruence rule must be used before Leibniz's axiom is expanded"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"delay_units"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"if true then z3 will not restart when a unit clause is learned"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"delay_units_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum number of learned unit clauses before restarting, ignored if delay_units is false"),(0,l.kt)("td",{parentName:"tr",align:null},"32")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"dt_lazy_splits"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_unconstrained"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"pre-processing: eliminate unconstrained subterms"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ematching"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"E-Matching based quantifier instantiation"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"induction"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable generation of induction lemmas"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lemma_gc_strategy"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"logic"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"logic used to setup the SMT solver"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"macro_finder"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"try to find universally quantified formulas that can be viewed as macros"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_conflicts"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum number of conflicts before giving up."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mbqi"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"model based quantifier instantiation (MBQI)"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mbqi.force_template"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight ",">","= mbqi.force_template are forced to be used as a template"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mbqi.id"),(0,l.kt)("td",{parentName:"tr",align:null},"string"),(0,l.kt)("td",{parentName:"tr",align:null},"Only use model-based instantiation for quantifiers with id's beginning with string"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mbqi.max_cexs"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mbqi.max_cexs_incr"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mbqi.max_iterations"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum number of rounds of MBQI"),(0,l.kt)("td",{parentName:"tr",align:null},"1000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mbqi.trace"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pb.conflict_frequency"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"conflict frequency for Pseudo-Boolean theory"),(0,l.kt)("td",{parentName:"tr",align:null},"1000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pb.learn_complements"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"learn complement literals for Pseudo-Boolean theory"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"phase_caching_off"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of conflicts while phase caching is off"),(0,l.kt)("td",{parentName:"tr",align:null},"100")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"phase_caching_on"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of conflicts while phase caching is on"),(0,l.kt)("td",{parentName:"tr",align:null},"400")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"phase_selection"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory"),(0,l.kt)("td",{parentName:"tr",align:null},"3")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"propagate_values"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"pre-processing: propagate values"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pull_nested_quantifiers"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"pre-processing: pull nested quantifiers"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"q.lift_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"q.lite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Use cheap quantifier elimination during pre-processing"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"qi.cost"),(0,l.kt)("td",{parentName:"tr",align:null},"string"),(0,l.kt)("td",{parentName:"tr",align:null},"expression specifying what is the cost of a given quantifier instantiation"),(0,l.kt)("td",{parentName:"tr",align:null},"(+ weight generation)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"qi.eager_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"threshold for eager quantifier instantiation"),(0,l.kt)("td",{parentName:"tr",align:null},"10.0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"qi.lazy_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"threshold for lazy quantifier instantiation"),(0,l.kt)("td",{parentName:"tr",align:null},"20.0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"qi.max_instances"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum number of quantifier instantiations"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"qi.max_multi_patterns"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"specify the number of extra multi patterns"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"qi.profile"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"profile quantifier instantiation"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"qi.profile_freq"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"how frequent results are reported by qi.profile"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"qi.quick_checker"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"quasi_macros"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"try to find universally quantified formulas that are quasi-macros"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"random_seed"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"random seed for the smt solver"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"refine_inj_axioms"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"pre-processing: refine injectivity axioms"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"relevancy"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"restart.max"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximal number of restarts."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"restart_factor"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"1.1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"restart_strategy"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"restricted_quasi_macros"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"try to find universally quantified formulas that are restricted quasi-macros"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"seq.max_unfolding"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximal unfolding depth for checking string equations and regular expressions"),(0,l.kt)("td",{parentName:"tr",align:null},"1000000000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"seq.min_unfolding"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"seq.split_w_len"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable splitting guided by length constraints"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"seq.validate"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable self-validation of theory axioms created by seq theory"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"solve_eqs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"pre-processing: solve equalities"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.aggressive_length_testing"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"prioritize testing concrete length values over generating more options"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.aggressive_unroll_testing"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"prioritize testing concrete regex unroll counts over generating more options"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.aggressive_value_testing"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"prioritize testing concrete string constant values over generating more options"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.fast_length_tester_cache"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"cache length tester constants instead of regenerating them"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.fast_value_tester_cache"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"cache value tester constants instead of regenerating them"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.fixed_length_naive_cex"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only)"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.fixed_length_refinement"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use abstraction refinement in fixed-length equation solver (Z3str3 only)"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.overlap_priority"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true"),(0,l.kt)("td",{parentName:"tr",align:null},"-0.1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.regex_automata_difficulty_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"difficulty threshold for regex automata heuristics"),(0,l.kt)("td",{parentName:"tr",align:null},"1000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.regex_automata_failed_automaton_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of failed automaton construction attempts after which a full automaton is automatically built"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.regex_automata_failed_intersection_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of failed automaton intersection attempts after which intersection is always computed"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.regex_automata_intersection_difficulty_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"difficulty threshold for regex intersection heuristics"),(0,l.kt)("td",{parentName:"tr",align:null},"1000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.regex_automata_length_attempt_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of length/path constraint attempts before checking unsatisfiability of regex terms"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.string_constant_cache"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"cache all generated string constants generated from anywhere in theory_str"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.strong_arrangements"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"assert equivalences instead of implications when generating string arrangement axioms"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"string_solver"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver)"),(0,l.kt)("td",{parentName:"tr",align:null},"seq")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"theory_aware_branching"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Allow the context to use extra information from theory solvers regarding literal branching prioritization."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"theory_case_split"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"threads"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximal number of parallel threads."),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"threads.cube_frequency"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"frequency for using cubing"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"threads.max_conflicts"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximal number of conflicts between rounds of cubing for parallel SMT"),(0,l.kt)("td",{parentName:"tr",align:null},"400")))),(0,l.kt)("h2",{id:"tactic-degree-shift"},"Tactic degree-shift"),(0,l.kt)("h3",{id:"short-description-14"},"Short Description"),(0,l.kt)("p",null,"The procedure reduces the degrees of variables."),(0,l.kt)("h3",{id:"long-description-7"},"Long Description"),(0,l.kt)("p",null,"Basic idea: if goal ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("mi",{parentName:"mrow"},"G")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"G")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6833em"}}),(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"G")))))," contains a real variable ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("mi",{parentName:"mrow"},"x")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"x")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"))))),", ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("mi",{parentName:"mrow"},"x")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"x")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"x")))))," occurs with degrees\n",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("msub",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msub"},"d"),(0,l.kt)("mn",{parentName:"msub"},"1")),(0,l.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,l.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"."),(0,l.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"."),(0,l.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"."),(0,l.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,l.kt)("msub",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msub"},"d"),(0,l.kt)("mi",{parentName:"msub"},"k"))),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"d_1, ..., d_k")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"d"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},"1")))),(0,l.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,l.kt)("span",{parentName:"span"})))))),(0,l.kt)("span",{parentName:"span",className:"mpunct"},","),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},"..."),(0,l.kt)("span",{parentName:"span",className:"mpunct"},","),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"d"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3361em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal mtight",style:{marginRight:"0.03148em"}},"k")))),(0,l.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,l.kt)("span",{parentName:"span"}))))))))))," in ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("mi",{parentName:"mrow"},"G")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"G")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6833em"}}),(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"G"))))),", and ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("mi",{parentName:"mrow"},"n"),(0,l.kt)("mo",{parentName:"mrow"},"="),(0,l.kt)("mi",{parentName:"mrow"},"gcd"),(0,l.kt)("mo",{parentName:"mrow"},"\u2061"),(0,l.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,l.kt)("msub",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msub"},"d"),(0,l.kt)("mn",{parentName:"msub"},"1")),(0,l.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,l.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"."),(0,l.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"."),(0,l.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"."),(0,l.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,l.kt)("msub",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msub"},"d"),(0,l.kt)("mi",{parentName:"msub"},"k")),(0,l.kt)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,l.kt)("mo",{parentName:"mrow"},">"),(0,l.kt)("mn",{parentName:"mrow"},"1")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n = \\gcd(d_1, ..., d_k) > 1")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,l.kt)("span",{parentName:"span",className:"mrel"},"="),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,l.kt)("span",{parentName:"span",className:"mop"},(0,l.kt)("span",{parentName:"span",style:{marginRight:"0.01389em"}},"g"),"cd"),(0,l.kt)("span",{parentName:"span",className:"mopen"},"("),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"d"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},"1")))),(0,l.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,l.kt)("span",{parentName:"span"})))))),(0,l.kt)("span",{parentName:"span",className:"mpunct"},","),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},"..."),(0,l.kt)("span",{parentName:"span",className:"mpunct"},","),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"d"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3361em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal mtight",style:{marginRight:"0.03148em"}},"k")))),(0,l.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,l.kt)("span",{parentName:"span"})))))),(0,l.kt)("span",{parentName:"span",className:"mclose"},")"),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,l.kt)("span",{parentName:"span",className:"mrel"},">"),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},"1"))))),".\nThen, replace ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("msup",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msup"},"x"),(0,l.kt)("mi",{parentName:"msup"},"n"))),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"x^n")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6644em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.6644em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"n"))))))))))))," with a new fresh variable ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("mi",{parentName:"mrow"},"y")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"y")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,l.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"y"))))),"."),(0,l.kt)("h3",{id:"example-10"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Real)\n(declare-const y Real)\n(assert (> (+ (* x x x 4) (* x x 3)) 0))\n(assert (= (* x x) (* y y)))\n(apply degree-shift)",result:{output:"(goals\n(goal\n  (let ((a!1 (<= (+ (* 4.0 (^ x 3.0)) (* 3.0 (^ x 2.0))) 0.0)))\n    (not a!1))\n  (= (^ x 2.0) k!0)\n  (>= k!0 0.0)\n  :precision precise :depth 2)\n)\n",error:"",status:"z3-ran",hash:"5c0a3228296328f9ae93a27bfe24795a78cf6607"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"notes-6"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"supports proofs and cores")),(0,l.kt)("h3",{id:"parameters-10"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"algebraic_number_evaluator"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"simplify/evaluate expressions containing (algebraic) irrational numbers."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith_ineq_lhs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite inequalities so that right-hand-side is a constant."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith_lhs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"all monomials are moved to the left-hand-side, and the right-hand-side is just a constant."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bit2bool"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"try to convert bit-vector terms of size 1 into Boolean terms"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_distinct"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand a distinct predicate into a quadratic number of disequalities"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_distinct_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_eq_value"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"blast (some) Bit-vector equalities into bits"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_select_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eagerly replace all (select (store ..) ..) term by an if-then-else term"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_extract_prop"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"attempt to partially propagate extraction inwards"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_ineq_consistency_test_max"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"max size of conjunctions on which to perform consistency test based on inequalities on bitvectors."),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_ite2id"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite ite that can be simplified to identity"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_le2extract"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"disassemble bvule to extract"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_le_extra"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"additional bu_(u/s)le simplifications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_not_simpl"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"apply simplifications for bvnot"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_sort_ac"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort the arguments of all AC operators"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cache_all"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"cache all intermediate results."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_and"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"conjunctions are rewritten using negation and disjunctions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate ite in favor of and/or"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_rem"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace (rem x y) with (ite (",">","= y 0) (mod x y) (- (mod x y)))."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_sign_ext"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand sign-ext operator using concat and extract"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_to_real"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate to_real from arithmetic predicates that contain only integers."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"eq2ineq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand equalities into two inequalities"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_nested_stores"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace nested stores by a lambda expression"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_power"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand (^ t k) into (* t ... t) if  1 ","<"," k ","<","= max_degree."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_select_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand select over ite expressions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_select_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"conservatively replace a (select (store ...) ...) term by an if-then-else term"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_store_eq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"reduce (store ...) = (store ...) with a common base into selects"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_tan"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace (tan x) with (/ (sin x) (cos x))."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"flat"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"flat_and_or"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"create nary applications for and,or"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"gcd_rounding"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use gcd rounding on integer arithmetic atoms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hi_div0"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use the 'hardware interpretation' for division by zero (for bit-vector terms)"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hoist_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"hoist shared summands under ite expressions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hoist_mul"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"hoist multiplication over summation to minimize number of multiplications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ignore_patterns_on_ground_qbody"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"ignores patterns on quantifiers that don't mention their bound variables."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ite_extra_rules"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extra ite simplifications, these additional simplifications may reduce size locally but increase globally"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_ctx"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"perform local (i.e., cheap) context simplifications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_ctx_limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"limit for applying local context simplifier"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_degree"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"max degree of algebraic numbers (and power operators) processed by simplifier."),(0,l.kt)("td",{parentName:"tr",align:null},"64")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum amount of memory in megabytes"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_steps"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum number of steps"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mul2concat"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace multiplication by a power of two into a concatenation"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mul_to_power"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"collpase (* t ... t) into (^ t k), it is ignored if expand_power is true."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pull_cheap_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"pull if-then-else terms when cheap."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_ite_arith"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"push if-then-else over arithmetic terms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_ite_bv"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"push if-then-else over bit-vector terms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_to_real"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"distribute to_real over * and +."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"rewrite_patterns"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite patterns."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"som"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"put polynomials in sum-of-monomials form"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"som_blowup"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sort_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort nested stores when the indices are known to be different"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sort_sums"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort the arguments of + application."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"split_concat_eq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"split equalities of the form (= (concat t1 t2) t3)"),(0,l.kt)("td",{parentName:"tr",align:null},"false")))),(0,l.kt)("h2",{id:"tactic-demodulator"},"Tactic demodulator"),(0,l.kt)("h3",{id:"short-description-15"},"Short Description:"),(0,l.kt)("p",null,"Extracts equalities from quantifiers and applies them for simplification"),(0,l.kt)("h3",{id:"long-description-8"},"Long Description"),(0,l.kt)("p",null,"In first-order theorem proving (FOTP), a demodulator is a universally quantified formula of the form:"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"Forall X1, ..., Xn.  L[X1, ..., Xn] = R[X1, ..., Xn]"),"\nWhere ",(0,l.kt)("inlineCode",{parentName:"p"},"L[X1, ..., Xn]")," contains all variables in ",(0,l.kt)("inlineCode",{parentName:"p"},"R[X1, ..., Xn]"),", and\n",(0,l.kt)("inlineCode",{parentName:"p"},"L[X1, ..., Xn]"),' is "bigger" than ',(0,l.kt)("inlineCode",{parentName:"p"},"R[X1, ...,Xn]"),"."),(0,l.kt)("p",null,"The idea is to replace something big ",(0,l.kt)("inlineCode",{parentName:"p"},"L[X1, ..., Xn]")," with something smaller ",(0,l.kt)("inlineCode",{parentName:"p"},"R[X1, ..., Xn]"),"."),(0,l.kt)("p",null,"After selecting the demodulators, we traverse the rest of the formula looking for instances of ",(0,l.kt)("inlineCode",{parentName:"p"},"L[X1, ..., Xn]"),".\nWhenever we find an instance, we replace it with the associated instance of ",(0,l.kt)("inlineCode",{parentName:"p"},"R[X1, ..., Xn]"),"."),(0,l.kt)("p",null,"For example, suppose we have"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"Forall x, y.  f(x+y, y) = y\nand\nf(g(b) + h(c), h(c)) <= 0\n")),(0,l.kt)("p",null,"The term ",(0,l.kt)("inlineCode",{parentName:"p"},"f(g(b) + h(c), h(c))")," is an instance of ",(0,l.kt)("inlineCode",{parentName:"p"},"f(x+y, y)")," if we replace ",(0,l.kt)("inlineCode",{parentName:"p"},"x <- g(b)")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"y <- h(c)"),".\nSo, we can replace it with ",(0,l.kt)("inlineCode",{parentName:"p"},"y")," which is bound to ",(0,l.kt)("inlineCode",{parentName:"p"},"h(c)")," in this example. So, the result of the transformation is:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"Forall x, y.  f(x+y, y) = y\nand\nh(c) <= 0\n")),(0,l.kt)("h3",{id:"example-11"},"Example"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"  (declare-sort S 0)\n  (declare-sort S1 0)\n  (declare-sort S2 0)\n  (declare-fun f () S)\n  (declare-fun f1 () S)\n  (declare-fun f2 (S1 S) S)\n  (declare-fun f3 (S2 S) S1)\n  (declare-fun f4 () S)\n  (declare-fun f5 () S2)\n  (assert (not (= f1 (f2 (f3 f5 f4) f))))\n  (assert (forall ((q S) (v S)) (or (= q v) (= f1 (f2 (f3 f5 q) v)) (= (f2 (f3 f5 v) q) f1))))\n  (assert (forall ((q S) (x S)) (not (= (f2 (f3 f5 q) x) f1))))\n  (apply demodulator)\n")),(0,l.kt)("p",null,"It generates"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"  (goals\n  (goal\n    (forall ((q S) (v S)) (= q v))\n    (forall ((q S) (x S)) (not (= (f2 (f3 f5 q) x) f1)))\n    :precision precise :depth 1)\n  )\n")),(0,l.kt)("h3",{id:"notes-7"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"supports unsat cores"),(0,l.kt)("li",{parentName:"ul"},"does not support fine-grained proofs")),(0,l.kt)("h2",{id:"tactic-der"},"Tactic der"),(0,l.kt)("h3",{id:"short-description-16"},"Short Description:"),(0,l.kt)("p",null,"The tactic performs ",(0,l.kt)("em",{parentName:"p"},"destructive equality resolution"),"."),(0,l.kt)("h3",{id:"long-description-9"},"Long Description"),(0,l.kt)("p",null,"Destructive equality resolution replaces bound variables that are\n",(0,l.kt)("em",{parentName:"p"},"solved")," by their solutions in formulas. In short, the destructive\nequality resolution rule takes the form:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"   (forall (X Y) (or X /= s C[X])) --\x3e (forall (Y) C[Y])\n")),(0,l.kt)("h3",{id:"example-12"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"  (declare-fun f (Int) Int)\n  (declare-fun p (Int Int) Bool)\n  (assert (forall ((x Int) (y Int)) (or (not (= x (f y))) (p x y))))\n  (apply der)",result:{output:"(goals\n(goal\n  (forall ((y Int)) (p (f y) y))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"c7c91358a82b239bd2681eb6a2a2c7870c4bfd75"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"notes-8"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"supports unsat cores, proof terms")),(0,l.kt)("h2",{id:"tactic-diff-neq"},"Tactic diff-neq"),(0,l.kt)("h3",{id:"short-description-17"},"Short Description"),(0,l.kt)("p",null,"A specialized solver for integer problems using only constant bounds and differences to constants."),(0,l.kt)("h3",{id:"long-description-10"},"Long Description"),(0,l.kt)("p",null,"Solver for integer problems that contains literals of the form"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"       k <= x\n       x <= k\n       x - y != k\n")),(0,l.kt)("h3",{id:"example-13"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Int)\n(declare-const y Int)\n(assert (<= 0 x))\n(assert (<= x 1))\n(assert (<= 0 y))\n(assert (<= y 1))\n(assert (not (= (+ x (* -1 y)) -1)))\n(assert (not (= (+ x (* -1 y)) 1)))\n(assert (not (= (+ x (* -1 y)) 0)))\n(apply diff-neq)",result:{output:"(goals\n(goal\n  false\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"c6b895bf72e2b597460866a34d3309f2464cbd7d"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"notes-9"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The tactic works only when the lower bounds are 0 and disequalities use multiplication with -1. Use normalize-bounds to ensure all lower bounds are 0.")),(0,l.kt)("h3",{id:"parameters-11"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"diff_neq_max_k"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum variable upper bound for diff neq solver."),(0,l.kt)("td",{parentName:"tr",align:null},"1024")))),(0,l.kt)("h2",{id:"tactic-distribute-forall"},"Tactic distribute-forall"),(0,l.kt)("h3",{id:"short-description-18"},"Short Description:"),(0,l.kt)("p",null,"Distribute ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2200")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\forall")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},"\u2200")))))," over conjunctions (and distribute ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2203")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\exists")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},"\u2203")))))," over disjunctions)"),(0,l.kt)("h3",{id:"example-14"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"  (declare-const x Int)\n  (declare-fun p (Int) Bool)\n  (declare-fun q (Int) Bool)\n  (assert (forall ((x Int)) (and (p x) (q x))))\n  (apply distribute-forall)",result:{output:"(goals\n(goal\n  (forall ((x!1 Int)) (q x!1))\n  (forall ((x!1 Int)) (p x!1))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"30eb7583108bcfd0056b8eec85b0175fc226ad2b"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"notes-10"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"supports unsat cores, proof terms")),(0,l.kt)("h2",{id:"tactic-dom-simplify"},"Tactic dom-simplify"),(0,l.kt)("h3",{id:"short-description-19"},"Short Description"),(0,l.kt)("p",null,"Apply dominator simplification rules"),(0,l.kt)("h3",{id:"long-description-11"},"Long Description"),(0,l.kt)("p",null,"Dominator-based simplification is a context dependent simplification function that uses a dominator tree to control the number of paths it\nvisits during simplification. The expression DAG may have an exponential number of paths, but only paths corresponding to a dominator\ntree are visited. Since the paths selected by the dominator trees are limited, the simplifier may easily fail to simplify within a context. "),(0,l.kt)("h3",{id:"example-15"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const a Bool)\n(declare-const b Bool)\n(assert (and a (or a b)))\n(apply dom-simplify)",result:{output:"(goals\n(goal\n  a\n  true\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"e6c16ba675e985b81672e52d180b9e91456343fc"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h2",{id:"tactic-dt2bv"},"Tactic dt2bv"),(0,l.kt)("h3",{id:"short-description-20"},"Short Description"),(0,l.kt)("p",null,"Tactic that eliminates finite domain data-types."),(0,l.kt)("h3",{id:"example-16"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-datatypes ((Color 0)) (((Red) (Blue) (Green) (DarkBlue) (MetallicBlack) (MetallicSilver) (Silver) (Black))))\n(declare-const x Color)\n(declare-const y Color)\n(assert (not (= x y)))\n(assert (not (= x Red)))\n(apply dt2bv)",result:{output:"(goals\n(goal\n  (not (= x!0 y!1))\n  (not (= x!0 #b000))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"e7b28c9b101c88e0ddf5498625ac9a47205e7268"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h2",{id:"tactic-elim-predicates"},"Tactic elim-predicates"),(0,l.kt)("h3",{id:"short-description-21"},"Short Description"),(0,l.kt)("p",null,"Eliminates predicates and macros from a formula."),(0,l.kt)("h3",{id:"long-description-12"},"Long Description"),(0,l.kt)("p",null,"The tactic subsumes the functionality of ",(0,l.kt)("inlineCode",{parentName:"p"},"macro-finder")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"quasi-macros"),".\nBesides finding macros, it eliminates predicates using Davis-Putnam\nresolution."),(0,l.kt)("h3",{id:"example-17"},"Example"),(0,l.kt)("p",null,"the predicate ",(0,l.kt)("inlineCode",{parentName:"p"},"p")," occurs once positively. All negative occurrences of ",(0,l.kt)("inlineCode",{parentName:"p"},"p")," are resolved against this positive occurrence.\nThe result of resolution is a set of equalities between arguments to ",(0,l.kt)("inlineCode",{parentName:"p"},"p"),". The function ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," is replaced by a partial solution."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"(declare-fun f (Int Int Int) Int)\n(declare-fun p (Int) Bool)\n(declare-const a Int)\n(declare-const b Int)\n\n(assert (forall ((x Int) (y Int)) (= (f x y (+ x y)) (* 2 x y))))\n(assert (p (f 8 a (+ a 8))))\n(assert (not (p (f 0 a (+ a 8)))))\n(assert (not (p (f 2 a (+ a 8)))))\n(assert (not (p (f 1 a (+ a b)))))\n(apply elim-predicates)\n")),(0,l.kt)("h3",{id:"notes-11"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"support unsat cores"),(0,l.kt)("li",{parentName:"ul"},"does not support proofs")),(0,l.kt)("h2",{id:"tactic-elim-small-bv"},"Tactic elim-small-bv"),(0,l.kt)("h3",{id:"short-description-22"},"Short Description"),(0,l.kt)("p",null,"Eliminate small, quantified bit-vectors by expansion"),(0,l.kt)("h3",{id:"example-18"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-fun p ((_ BitVec 2)) Bool)\n(assert (forall ((x (_ BitVec 2))) (p x)))\n(apply elim-small-bv)",result:{output:"(goals\n(goal\n  (p #b00)\n  (p #b01)\n  (p #b10)\n  (p #b11)\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"149eb044c8efb7855d8b8b5c3da3766c29a35ae4"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"parameters-12"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_bits"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: 4) maximum bit-vector size of quantified bit-vectors to be eliminated."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum amount of memory in megabytes."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_steps"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum number of steps."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")))),(0,l.kt)("h2",{id:"tactic-elim-term-ite"},"Tactic elim-term-ite"),(0,l.kt)("h3",{id:"short-description-23"},"Short Description:"),(0,l.kt)("p",null,"Eliminate term if-then-else by adding\nnew fresh auxiliary variables."),(0,l.kt)("h3",{id:"example-19"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-fun f (Int) Int)\n(declare-fun p (Int) Bool)\n(declare-const c1 Bool)\n(declare-const c2 Bool)\n(declare-const c3 Bool)\n(declare-const e1 Int) \n(declare-const e2 Int) \n(declare-const e3 Int)\n(declare-const e4 Int)\n(assert (p (f (if c1 (if c2 e1 (if c3 e2 e3)) e4))))\n(apply elim-term-ite) ",result:{output:"(goals\n(goal\n  (p (f k!2))\n  (or (not c3) (= k!0 e2))\n  (or c3 (= k!0 e3))\n  (or (not c2) (= k!1 e1))\n  (or c2 (= k!1 k!0))\n  (or (not c1) (= k!2 k!1))\n  (or c1 (= k!2 e4))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"a2770dd3049d6f94a03e86ad29ae2a89d0eebda4"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"notes-12"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"supports proof terms and unsat cores")),(0,l.kt)("h3",{id:"parameters-13"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_args"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: 128) maximum number of arguments (per application) that will be considered by the greedy (quadratic) heuristic."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum amount of memory in megabytes."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_steps"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum number of steps."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")))),(0,l.kt)("h2",{id:"tactic-elim-uncnstr"},"Tactic elim-uncnstr"),(0,l.kt)("h3",{id:"short-description-24"},"Short Description"),(0,l.kt)("p",null,"Eliminate Unconstrained uninterpreted constants"),(0,l.kt)("h3",{id:"long-description-13"},"Long Description"),(0,l.kt)("p",null,"The tactic eliminates uninterpreted constants that occur only once in a goal and such that the immediate context\nwhere they occur can be replaced by a fresh constant. We call these occurrences invertible.\nIt relies on a series of theory specific invertibility transformations.\nIn the following assume ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"x'")," occur in a unique subterm and ",(0,l.kt)("inlineCode",{parentName:"p"},"y")," is a fresh uninterpreted constant."),(0,l.kt)("h4",{id:"boolean-connectives"},"Boolean Connectives"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Original Context"),(0,l.kt)("th",{parentName:"tr",align:null},"New Term"),(0,l.kt)("th",{parentName:"tr",align:null},"Updated solution"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(if c x x')")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"y")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"x = x' = y"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(if x x' e)")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"y")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"x = true, x' = y"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(if x t x')")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"y")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"x = false, x' = y"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(not x)")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"y")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"x = (not y)"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(and x x')")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"y")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"x = y, x' = true"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(or  x x')")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"y")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"x = y, x' = false"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(= x t)")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"y")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"x = (if y t (diff t))"))))),(0,l.kt)("p",null,"where diff is a diagnonalization function available in domains of size ",(0,l.kt)("inlineCode",{parentName:"p"},">")," 1."),(0,l.kt)("h4",{id:"arithmetic"},"Arithmetic"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Original Context"),(0,l.kt)("th",{parentName:"tr",align:null},"New Term"),(0,l.kt)("th",{parentName:"tr",align:null},"Updated solution"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(+ x t)")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"y")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"x = y - t"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(* x x')")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"y")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"x = y, x' = 1"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(* -1 x)")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"y")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"x = -y"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(<= x t)")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"y")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"x = (if y t (+ t 1))"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(<= t x)")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"y")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"x = (if y t (- t 1))"))))),(0,l.kt)("h4",{id:"bit-vectors"},"Bit-vectors"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Original Context"),(0,l.kt)("th",{parentName:"tr",align:null},"New Term"),(0,l.kt)("th",{parentName:"tr",align:null},"Updated solution"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(bvadd x t)")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"y")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"x = y - t"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(bvmul x x')")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"y")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"x = y, x' = 1"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(bvmul odd x)")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"y")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"x = inv(odd)*y"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"((extract sz-1 0) x)")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"y")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"x = y"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"((extract hi lo) x)")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"y")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"x = (concat y1 y y2)"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(udiv x x')")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"y")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"x = y, x' = 1"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(concat x x')")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"y")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"x = (extract hi1 lo1 y)"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(bvule x t)")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(or y (= t MAX))")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"x = (if y t (bvadd t 1))"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(bvule t x)")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(or y (= t MIN))")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"x = (if y t (bvsub t 1))"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(bvnot x)")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"y")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"x = (bvnot y)"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(bvand x x')")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"y")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"x = y, x' = MAX"))))),(0,l.kt)("p",null,"In addition there are conversions for shift and bit-wise or and signed comparison."),(0,l.kt)("h4",{id:"arrays"},"Arrays"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Original Context"),(0,l.kt)("th",{parentName:"tr",align:null},"New Term"),(0,l.kt)("th",{parentName:"tr",align:null},"Updated solution"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(select x t)")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"y")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"x = (const y)"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(store x x1 x2)")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"y")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"x2 = (select x x1), x = y, x1 = arb"))))),(0,l.kt)("h4",{id:"algebraic-datatypes"},"Algebraic Datatypes"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Original Context"),(0,l.kt)("th",{parentName:"tr",align:null},"New Term"),(0,l.kt)("th",{parentName:"tr",align:null},"Updated solution"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(head x)")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"y")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"x = (cons y arb)"))))),(0,l.kt)("h3",{id:"example-20"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Int)\n(declare-const y Int)\n(declare-fun p (Int) Bool)    \n(assert (>= (+ y (+ x y)) y))\n(assert (p y))\n(apply elim-uncnstr)\n(assert (p (+ x y)))\n(apply elim-uncnstr)",result:{output:"(goals\n(goal\n  k!2\n  (p y)\n  :precision precise :depth 1)\n)\n(goals\n(goal\n  (>= (+ y k!3) y)\n  (p y)\n  (p k!3)\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"80fd2cb482c05058950e17432a94e2765b783fa3"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"notes-13"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"supports unsat cores"),(0,l.kt)("li",{parentName:"ul"},"does not support fine-grained proofs")),(0,l.kt)("h3",{id:"parameters-14"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum amount of memory in megabytes."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_steps"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum number of steps."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")))),(0,l.kt)("h2",{id:"tactic-eq2bv"},"Tactic eq2bv"),(0,l.kt)("h3",{id:"short-description-25"},"Short Description"),(0,l.kt)("p",null,"Extract integer variables that are used as finite domain indicators.\nThe integer variables can only occur in equalities."),(0,l.kt)("h3",{id:"example-21"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Int)\n(declare-const y Int)\n(assert (or (= x 5) (> y 3)))\n(assert (or (= x 4) (= y 2)))\n(apply eq2bv)",result:{output:"(goals\n(goal\n  (or (= z!0 #b101) (> y 3))\n  (or (= z!0 #b100) (= y 2))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"f18f98e212cf37ef74b27bd65edec0ac18535d0f"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"notes-14"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"does not support proofs")),(0,l.kt)("h2",{id:"tactic-euf-completion"},"Tactic euf-completion"),(0,l.kt)("h3",{id:"short-description-26"},"Short Description"),(0,l.kt)("p",null,"Uses the ground equalities as a rewrite system. The formulas are simplified\nusing the rewrite system. "),(0,l.kt)("h3",{id:"long-description-14"},"Long Description"),(0,l.kt)("p",null,"The tactic uses congruence closure to represent and orient the rewrite system. Equalities from the formula\nare inserted in the an E-graph (congruence closure structure) and then a representative that is most shallow\nis extracted."),(0,l.kt)("h2",{id:"tactic-factor"},"Tactic factor"),(0,l.kt)("h3",{id:"short-description-27"},"Short Description"),(0,l.kt)("p",null,"Factor polynomials in equalities and inequalities."),(0,l.kt)("h3",{id:"example-22"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Real)\n(declare-const y Real)\n(assert (> (* x x) (* x y)))\n(apply factor)",result:{output:"(goals\n(goal\n  (> (* x (+ (* (- 1.0) y) x)) 0.0)\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"ad569e6217fadaeeb8009b97177c12ee0d3d9c48"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"parameters-15"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_prime"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_search_size"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"num_primes"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: 1) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"split_factors"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"apply simplifications such as (= (* p1 p2) 0) --",">"," (or (= p1 0) (= p2 0))."),(0,l.kt)("td",{parentName:"tr",align:null},"true")))),(0,l.kt)("h2",{id:"tactic-fix-dl-var"},"Tactic fix-dl-var"),(0,l.kt)("h3",{id:"short-description-28"},"Short Description"),(0,l.kt)("p",null,"Fix a difference logic variable to ",(0,l.kt)("inlineCode",{parentName:"p"},"0"),".\nIf the problem is in the difference logic fragment, that is, all arithmetic terms\nare of the form ",(0,l.kt)("inlineCode",{parentName:"p"},"(x + k)"),", and the arithmetic atoms are of the\nform ",(0,l.kt)("inlineCode",{parentName:"p"},"x - y <= k")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"x - y = k"),". Then, we can set one variable to ",(0,l.kt)("inlineCode",{parentName:"p"},"0"),"."),(0,l.kt)("p",null,"This is useful because, many bounds can be exposed after this operation is performed."),(0,l.kt)("h3",{id:"example-23"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Real)\n(declare-const y Real)\n(declare-const z Real)\n(assert (<= (+ x (* -1.0 y)) 3.0))\n(assert (<= (+ x (* -1.0 z)) 5.0))\n(apply fix-dl-var)",result:{output:"(goals\n(goal\n  (>= y (- 3.0))\n  (>= z (- 5.0))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"5784999bece4af2880bb125f6d5bf6caf2b2aa44"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"parameters-16"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"algebraic_number_evaluator"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"simplify/evaluate expressions containing (algebraic) irrational numbers."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith_ineq_lhs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite inequalities so that right-hand-side is a constant."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith_lhs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"all monomials are moved to the left-hand-side, and the right-hand-side is just a constant."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bit2bool"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"try to convert bit-vector terms of size 1 into Boolean terms"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_distinct"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand a distinct predicate into a quadratic number of disequalities"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_distinct_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_eq_value"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"blast (some) Bit-vector equalities into bits"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_select_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eagerly replace all (select (store ..) ..) term by an if-then-else term"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_extract_prop"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"attempt to partially propagate extraction inwards"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_ineq_consistency_test_max"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"max size of conjunctions on which to perform consistency test based on inequalities on bitvectors."),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_ite2id"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite ite that can be simplified to identity"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_le2extract"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"disassemble bvule to extract"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_le_extra"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"additional bu_(u/s)le simplifications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_not_simpl"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"apply simplifications for bvnot"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_sort_ac"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort the arguments of all AC operators"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cache_all"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"cache all intermediate results."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_and"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"conjunctions are rewritten using negation and disjunctions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate ite in favor of and/or"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_rem"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace (rem x y) with (ite (",">","= y 0) (mod x y) (- (mod x y)))."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_sign_ext"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand sign-ext operator using concat and extract"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_to_real"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate to_real from arithmetic predicates that contain only integers."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"eq2ineq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand equalities into two inequalities"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_nested_stores"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace nested stores by a lambda expression"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_power"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand (^ t k) into (* t ... t) if  1 ","<"," k ","<","= max_degree."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_select_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand select over ite expressions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_select_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"conservatively replace a (select (store ...) ...) term by an if-then-else term"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_store_eq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"reduce (store ...) = (store ...) with a common base into selects"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_tan"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace (tan x) with (/ (sin x) (cos x))."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"flat"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"flat_and_or"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"create nary applications for and,or"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"gcd_rounding"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use gcd rounding on integer arithmetic atoms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hi_div0"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use the 'hardware interpretation' for division by zero (for bit-vector terms)"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hoist_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"hoist shared summands under ite expressions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hoist_mul"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"hoist multiplication over summation to minimize number of multiplications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ignore_patterns_on_ground_qbody"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"ignores patterns on quantifiers that don't mention their bound variables."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ite_extra_rules"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extra ite simplifications, these additional simplifications may reduce size locally but increase globally"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_ctx"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"perform local (i.e., cheap) context simplifications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_ctx_limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"limit for applying local context simplifier"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_degree"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"max degree of algebraic numbers (and power operators) processed by simplifier."),(0,l.kt)("td",{parentName:"tr",align:null},"64")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum amount of memory in megabytes"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_steps"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum number of steps"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mul2concat"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace multiplication by a power of two into a concatenation"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mul_to_power"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"collpase (* t ... t) into (^ t k), it is ignored if expand_power is true."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pull_cheap_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"pull if-then-else terms when cheap."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_ite_arith"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"push if-then-else over arithmetic terms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_ite_bv"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"push if-then-else over bit-vector terms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_to_real"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"distribute to_real over * and +."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"rewrite_patterns"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite patterns."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"som"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"put polynomials in sum-of-monomials form"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"som_blowup"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sort_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort nested stores when the indices are known to be different"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sort_sums"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort the arguments of + application."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"split_concat_eq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"split equalities of the form (= (concat t1 t2) t3)"),(0,l.kt)("td",{parentName:"tr",align:null},"false")))),(0,l.kt)("h2",{id:"tactic-fm"},"Tactic fm"),(0,l.kt)("h3",{id:"short-description-29"},"Short Description"),(0,l.kt)("p",null,"Use Fourier-Motzkin to eliminate variables.\nThis strategy can handle conditional bounds\n(i.e., clauses with at most one constraint)."),(0,l.kt)("p",null,"The tactic occf can be used to put the\nformula in OCC form."),(0,l.kt)("h3",{id:"example-24"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Real)\n(declare-const y Real)\n(declare-const z Real)\n(declare-const u Real)\n(declare-const v Real)\n(declare-const w Real)\n(declare-fun P (Real) Bool)\n(assert (<= x (+ y (* 2.0 z))))\n(assert (>= x (- y z)))\n(assert (>= x (- y 3 (* 3 z))))\n(assert (>= x 5))\n(assert (<= x u))\n(assert (>= x v))\n(assert (P u))\n(assert (P v))\n(apply fm)",result:{output:"(goals\n(goal\n  (P u)\n  (P v)\n  (<= (* (- 1.0) u) (- 5.0))\n  (<= (+ v (* (- 1.0) u)) 0.0)\n  :precision precise :depth 2)\n)\n",error:"",status:"z3-ran",hash:"c376e3f493dadf114dced7e84319d445c0e3c1f4"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"parameters-17"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"algebraic_number_evaluator"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"simplify/evaluate expressions containing (algebraic) irrational numbers."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith_ineq_lhs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite inequalities so that right-hand-side is a constant."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith_lhs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"all monomials are moved to the left-hand-side, and the right-hand-side is just a constant."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bit2bool"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"try to convert bit-vector terms of size 1 into Boolean terms"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_distinct"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand a distinct predicate into a quadratic number of disequalities"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_distinct_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_eq_value"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"blast (some) Bit-vector equalities into bits"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_select_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eagerly replace all (select (store ..) ..) term by an if-then-else term"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_extract_prop"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"attempt to partially propagate extraction inwards"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_ineq_consistency_test_max"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"max size of conjunctions on which to perform consistency test based on inequalities on bitvectors."),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_ite2id"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite ite that can be simplified to identity"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_le2extract"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"disassemble bvule to extract"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_le_extra"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"additional bu_(u/s)le simplifications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_not_simpl"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"apply simplifications for bvnot"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_sort_ac"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort the arguments of all AC operators"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cache_all"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"cache all intermediate results."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_and"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"conjunctions are rewritten using negation and disjunctions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate ite in favor of and/or"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_rem"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace (rem x y) with (ite (",">","= y 0) (mod x y) (- (mod x y)))."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_sign_ext"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand sign-ext operator using concat and extract"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_to_real"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate to_real from arithmetic predicates that contain only integers."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"eq2ineq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand equalities into two inequalities"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_nested_stores"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace nested stores by a lambda expression"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_power"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand (^ t k) into (* t ... t) if  1 ","<"," k ","<","= max_degree."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_select_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand select over ite expressions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_select_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"conservatively replace a (select (store ...) ...) term by an if-then-else term"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_store_eq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"reduce (store ...) = (store ...) with a common base into selects"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_tan"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace (tan x) with (/ (sin x) (cos x))."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"flat"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"flat_and_or"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"create nary applications for and,or"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"fm_cutoff1"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"first cutoff for FM based on maximum number of lower/upper occurrences."),(0,l.kt)("td",{parentName:"tr",align:null},"8")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"fm_cutoff2"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"second cutoff for FM based on num_lower * num_upper occurrences."),(0,l.kt)("td",{parentName:"tr",align:null},"256")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"fm_extra"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"max. increase on the number of inequalities for each FM variable elimination step."),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"fm_limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum number of constraints, monomials, clauses visited during FM."),(0,l.kt)("td",{parentName:"tr",align:null},"5000000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"fm_occ"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"consider inequalities occurring in clauses for FM."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"fm_real_only"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"consider only real variables for fourier-motzkin elimination."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"gcd_rounding"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use gcd rounding on integer arithmetic atoms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hi_div0"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use the 'hardware interpretation' for division by zero (for bit-vector terms)"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hoist_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"hoist shared summands under ite expressions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hoist_mul"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"hoist multiplication over summation to minimize number of multiplications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ignore_patterns_on_ground_qbody"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"ignores patterns on quantifiers that don't mention their bound variables."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ite_extra_rules"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extra ite simplifications, these additional simplifications may reduce size locally but increase globally"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_ctx"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"perform local (i.e., cheap) context simplifications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_ctx_limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"limit for applying local context simplifier"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_degree"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"max degree of algebraic numbers (and power operators) processed by simplifier."),(0,l.kt)("td",{parentName:"tr",align:null},"64")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum amount of memory in megabytes"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_steps"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum number of steps"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mul2concat"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace multiplication by a power of two into a concatenation"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mul_to_power"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"collpase (* t ... t) into (^ t k), it is ignored if expand_power is true."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"produce_models"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"model generation."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pull_cheap_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"pull if-then-else terms when cheap."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_ite_arith"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"push if-then-else over arithmetic terms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_ite_bv"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"push if-then-else over bit-vector terms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_to_real"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"distribute to_real over * and +."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"rewrite_patterns"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite patterns."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"som"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"put polynomials in sum-of-monomials form"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"som_blowup"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sort_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort nested stores when the indices are known to be different"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sort_sums"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort the arguments of + application."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"split_concat_eq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"split equalities of the form (= (concat t1 t2) t3)"),(0,l.kt)("td",{parentName:"tr",align:null},"false")))),(0,l.kt)("h2",{id:"tactic-fpa2bv"},"Tactic fpa2bv"),(0,l.kt)("h3",{id:"short-description-30"},"Short Description"),(0,l.kt)("p",null,"Converts floating points to bit-vector representation."),(0,l.kt)("h2",{id:"tactic-horn"},"Tactic horn"),(0,l.kt)("h3",{id:"short-description-31"},"Short Description"),(0,l.kt)("p",null,"Solve a set of Horn clauses using the SPACER engine."),(0,l.kt)("h3",{id:"long-description-15"},"Long Description"),(0,l.kt)("p",null,"The SPACER engine is specialized to solving Constrained Horn Clauses.\nThis tactic instructs "),(0,l.kt)("h2",{id:"tactic-horn-simplify"},"Tactic horn-simplify"),(0,l.kt)("h3",{id:"short-description-32"},"Short Description"),(0,l.kt)("p",null,"Apply pre-processing simplification rules to a set of Horn clauses"),(0,l.kt)("h3",{id:"long-description-16"},"Long Description"),(0,l.kt)("p",null,"This tactic exposes pre-processing simplification rules for Constrained Horn Clauses.\nThey include a repertoire of simplification options that can be controlled by toggling\nthe ",(0,l.kt)("inlineCode",{parentName:"p"},"fp")," parameters."),(0,l.kt)("h3",{id:"parameters-18"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bmc.linear_unrolling_depth"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"Maximal level to explore"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ctrl_c"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable interrupts from ctrl-c"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"datalog.all_or_nothing_deltas"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"compile rules so that it is enough for the delta relation in union and widening operations to determine only whether the updated relation was modified or not"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"datalog.check_relation"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"name of default relation to check. operations on the default relation will be verified using SMT solving"),(0,l.kt)("td",{parentName:"tr",align:null},"null")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"datalog.compile_with_widening"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"widening will be used to compile recursive rules"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"datalog.dbg_fpr_nonempty_relation_signature"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"if true, finite_product_relation will attempt to avoid creating inner relation with empty signature by putting in half of the table columns, if it would have been empty otherwise"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"datalog.default_relation"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"default relation implementation: external_relation, pentagon"),(0,l.kt)("td",{parentName:"tr",align:null},"pentagon")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"datalog.default_table"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"default table implementation: sparse, hashtable, bitvector, interval"),(0,l.kt)("td",{parentName:"tr",align:null},"sparse")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"datalog.default_table_checked"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"if true, the default table will be default_table inside a wrapper that checks that its results are the same as of default_table_checker table"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"datalog.default_table_checker"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"see default_table_checked"),(0,l.kt)("td",{parentName:"tr",align:null},"null")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"datalog.explanations_on_relation_level"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"if true, explanations are generated as history of each relation, rather than per fact (generate_explanations must be set to true for this option to have any effect)"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"datalog.generate_explanations"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"produce explanations for produced facts when using the datalog engine"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"datalog.initial_restart_timeout"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"length of saturation run before the first restart (in ms), zero means no restarts"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"datalog.magic_sets_for_queries"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"magic set transformation will be used for queries"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"datalog.output_profile"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"determines whether profile information should be output when outputting Datalog rules or instructions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"datalog.print.tuples"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"determines whether tuples for output predicates should be output"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"datalog.profile_timeout_milliseconds"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"instructions and rules that took less than the threshold will not be printed when printed the instruction/rule list"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"datalog.similarity_compressor"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rules that differ only in values of constants will be merged into a single rule"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"datalog.similarity_compressor_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"if similarity_compressor is on, this value determines how many similar rules there must be in order for them to be merged"),(0,l.kt)("td",{parentName:"tr",align:null},"11")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"datalog.subsumption"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"if true, removes/filters predicates with total transitions"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"datalog.timeout"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"Time limit used for saturation"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"datalog.unbound_compressor"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"auxiliary relations will be introduced to avoid unbound variables in rule heads"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"datalog.use_map_names"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use names from map files when displaying tuples"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"engine"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"Select: auto-config, datalog, bmc, spacer"),(0,l.kt)("td",{parentName:"tr",align:null},"auto-config")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"generate_proof_trace"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"trace for 'sat' answer as proof object"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"print_aig"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"Dump clauses in AIG text format (AAG) to the given file name"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"print_answer"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"print answer instance(s) to query"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"print_boogie_certificate"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"print certificate for reachability or non-reachability using a format understood by Boogie"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"print_certificate"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"print certificate for reachability or non-reachability"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"print_fixedpoint_extensions"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use SMT-LIB2 fixedpoint extensions, instead of pure SMT2, when printing rules"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"print_low_level_smt2"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use (faster) low-level SMT2 printer (the printer is scalable but the result may not be as readable)"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"print_statistics"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"print statistics"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"print_with_variable_declarations"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use variable declarations when displaying rules (instead of attempting to use original names)"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.arith.solver"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.blast_term_ite_inflation"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"Maximum inflation for non-Boolean ite-terms expansion: 0 (none), k (multiplicative)"),(0,l.kt)("td",{parentName:"tr",align:null},"3")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.ctp"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Enable counterexample-to-pushing"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.dump_benchmarks"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Dump SMT queries as benchmarks"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.dump_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"Threshold in seconds on dumping benchmarks"),(0,l.kt)("td",{parentName:"tr",align:null},"5.0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.elim_aux"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Eliminate auxiliary variables in reachability facts"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.eq_prop"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Enable equality and bound propagation in arithmetic"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.expand_bnd"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Enable expand-bound lemma generalization"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.gg.concretize"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Enable global guidance concretize"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.gg.conjecture"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Enable global guidance conjecture"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.gg.subsume"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Enable global guidance subsume"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.global"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Enable global guidance"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.gpdr"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Use GPDR solving strategy for non-linear CHC"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.gpdr.bfs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Use BFS exploration strategy for expanding model search"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.ground_pobs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Ground pobs by using values from a model"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.iuc"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"0 = use old implementation of unsat-core-generation, 1 = use new implementation of IUC generation, 2 = use new implementation of IUC + min-cut optimization"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.iuc.arith"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"0 = use simple Farkas plugin, 1 = use simple Farkas plugin with constant from other partition (like old unsat-core-generation),2 = use Gaussian elimination optimization (broken), 3 = use additive IUC plugin"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.iuc.debug_proof"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"prints proof used by unsat-core-learner for debugging purposes (debugging)"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.iuc.old_hyp_reducer"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use old hyp reducer instead of new implementation, for debugging only"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.iuc.print_farkas_stats"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"prints for each proof how many Farkas lemmas it contains and how many of these participate in the cut (for debugging)"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.iuc.split_farkas_literals"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Split Farkas literals"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.keep_proxy"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"keep proxy variables (internal parameter)"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.logic"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"SMT-LIB logic to configure internal SMT solvers"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.max_level"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"Maximum level to explore"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.max_num_contexts"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximal number of contexts to create"),(0,l.kt)("td",{parentName:"tr",align:null},"500")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.mbqi"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Enable mbqi"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.min_level"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"Minimal level to explore"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.native_mbp"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Use native mbp of Z3"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.order_children"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"SPACER: order of enqueuing children in non-linear rules : 0 (original), 1 (reverse), 2 (random)"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.p3.share_invariants"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Share invariants lemmas"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.p3.share_lemmas"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Share frame lemmas"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.propagate"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Enable propagate/pushing phase"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.push_pob"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"push blocked pobs to higher level"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.push_pob_max_depth"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"Maximum depth at which push_pob is enabled"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.q3"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Allow quantified lemmas in frames"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.q3.instantiate"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Instantiate quantified lemmas"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.q3.qgen.normalize"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"normalize cube before quantified generalization"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.q3.use_qgen"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use quantified lemma generalizer"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.random_seed"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"Random seed to be used by SMT solver"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.reach_dnf"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Restrict reachability facts to DNF"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.reset_pob_queue"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"SPACER: reset pob obligation queue when entering a new level"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.restart_initial_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"Initial threshold for restarts"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.restarts"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Enable resetting obligation queue"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.simplify_lemmas_post"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"simplify derived lemmas after inductive propagation"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.simplify_lemmas_pre"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"simplify derived lemmas before inductive propagation"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.simplify_pob"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"simplify pobs by removing redundant constraints"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.trace_file"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"Log file for progress events"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.use_array_eq_generalizer"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"SPACER: attempt to generalize lemmas with array equalities"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.use_bg_invs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Enable external background invariants"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.use_derivations"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"SPACER: using derivation mechanism to cache intermediate results for non-linear rules"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.use_euf_gen"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Generalize lemmas and pobs using implied equalities"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.use_inc_clause"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Use incremental clause to represent trans"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.use_inductive_generalizer"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"generalize lemmas using induction strengthening"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.use_iuc"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Enable Interpolating Unsat Core(IUC) for lemma generalization"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.use_lemma_as_cti"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"SPACER: use a lemma instead of a CTI in flexible_trace"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.use_lim_num_gen"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Enable limit numbers generalizer to get smaller numbers"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.validate_lemmas"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Validate each lemma after generalization"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spacer.weak_abs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Weak abstraction"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"tab.selection"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"selection method for tabular strategy: weight (default), first, var-use"),(0,l.kt)("td",{parentName:"tr",align:null},"weight")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"timeout"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) timeout in milliseconds."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"validate"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"validate result (by proof checking or model checking)"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xform.array_blast"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"try to eliminate local array terms using Ackermannization -- some array terms may remain"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xform.array_blast_full"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate all local array variables by QE"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xform.bit_blast"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"bit-blast bit-vectors"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xform.coalesce_rules"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"coalesce rules"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xform.coi"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use cone of influence simplification"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xform.compress_unbound"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"compress tails with unbound variables"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xform.elim_term_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Eliminate term-ite expressions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xform.elim_term_ite.inflation"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"Maximum inflation for non-Boolean ite-terms blasting: 0 (none), k (multiplicative)"),(0,l.kt)("td",{parentName:"tr",align:null},"3")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xform.fix_unbound_vars"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"fix unbound variables in tail"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xform.inline_eager"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"try eager inlining of rules"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xform.inline_linear"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"try linear inlining method"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xform.inline_linear_branch"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"try linear inlining method with potential expansion"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xform.instantiate_arrays"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Transforms P(a) into P(i, a","[i]"," a)"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xform.instantiate_arrays.enforce"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Transforms P(a) into P(i, a","[i]","), discards a from predicate"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xform.instantiate_arrays.nb_quantifier"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"Gives the number of quantifiers per array"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xform.instantiate_arrays.slice_technique"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"<","no-slicing",">","=",">"," GetId(i) = i, ","<","smash",">"," =",">"," GetId(i) = true"),(0,l.kt)("td",{parentName:"tr",align:null},"no-slicing")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xform.instantiate_quantifiers"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"instantiate quantified Horn clauses using E-matching heuristic"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xform.magic"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"perform symbolic magic set transformation"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xform.quantify_arrays"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"create quantified Horn clauses from clauses with arrays"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xform.scale"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"add scaling variable to linear real arithmetic clauses"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xform.slice"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"simplify clause set using slicing"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xform.subsumption_checker"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Enable subsumption checker (no support for model conversion)"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xform.tail_simplifier_pve"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"propagate_variable_equivalences"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xform.transform_arrays"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Rewrites arrays equalities and applies select over store"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xform.unfold_rules"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"unfold rules statically using iterative squaring"),(0,l.kt)("td",{parentName:"tr",align:null},"0")))),(0,l.kt)("h2",{id:"tactic-injectivity"},"Tactic injectivity"),(0,l.kt)("h3",{id:"short-description-33"},"Short Description:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Discover axioms of the form ",(0,l.kt)("inlineCode",{parentName:"p"},"forall x. (= (g (f x)) x"),"\nMark ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," as injective")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Rewrite (sub)terms of the form ",(0,l.kt)("inlineCode",{parentName:"p"},"(= (f x) (f y))")," to ",(0,l.kt)("inlineCode",{parentName:"p"},"(= x y)")," whenever ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," is injective."))),(0,l.kt)("h3",{id:"example-25"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"  (declare-fun f (Int) Int)\n  (declare-fun g (Int) Int)\n  (declare-const x Int)\n  (declare-const y Int)\n  (assert (forall ((x Int)) (= (g (f x)) x)))\n  (assert (not (= (f x) (f (f y)))))\n  (apply injectivity)",result:{output:"(goals\n(goal\n  (forall ((x!1 Int)) (= (g (f x!1)) x!1))\n  (not (= x (f y)))\n  :precision precise :depth 0)\n)\n",error:"",status:"z3-ran",hash:"0a8fbe4d1d580af501ad7353d9b05fb3ef283a97"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"notes-15"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"does not support cores nor proofs")),(0,l.kt)("h3",{id:"parameters-19"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum amount of memory in megabytes."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"produce_models"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"model generation."),(0,l.kt)("td",{parentName:"tr",align:null},"false")))),(0,l.kt)("h2",{id:"tactic-lia2card"},"Tactic lia2card"),(0,l.kt)("h3",{id:"short-description-34"},"Short Description"),(0,l.kt)("p",null,"Extract 0-1 integer variables used in\ncardinality and pseudo-Boolean constraints and replace them by Booleans."),(0,l.kt)("h3",{id:"example-26"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Int)\n(declare-const y Int)\n(declare-const z Int)\n(assert (<= 0 x))\n(assert (<= 0 y))\n(assert (<= 0 z))\n(assert (>= 1 x))\n(assert (>= 1 y))\n(assert (>= 1 z))\n(assert (>= (+ (* 5 x) (* -2 z) (* 3 y) 1) 4))\n(apply lia2card)",result:{output:"(goals\n(goal\n  true\n  true\n  true\n  true\n  true\n  true\n  ((_ pble 5 5 2 3) (not x!0) z!2 (not y!1))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"26719e371c901bad2b75bf3520b195925fe4077c"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"notes-16"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The tactic does not (properly) support proofs or cores.")),(0,l.kt)("h3",{id:"parameters-20"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"compile_equality"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"(default:false) compile equalities into pseudo-Boolean equality"),(0,l.kt)("td",{parentName:"tr",align:null})))),(0,l.kt)("h2",{id:"tactic-lia2pb"},"Tactic lia2pb"),(0,l.kt)("h3",{id:"short-description-35"},"Short Description"),(0,l.kt)("p",null,"Reduce bounded LIA benchmark into 0-1 LIA benchmark."),(0,l.kt)("h3",{id:"example-27"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Int)\n(declare-const y Int)\n(assert (<= 0 x))\n(assert (<= x 5))\n(assert (<= 0 y))\n(assert (<= y 5))\n(assert (>= (+ (* 2 x) y) 5))\n(apply lia2pb)",result:{output:"(goals\n(goal\n  (<= 0 (+ k!0 (* 2 k!1) (* 4 k!2)))\n  (<= (+ k!0 (* 2 k!1) (* 4 k!2)) 5)\n  (<= 0 (+ k!3 (* 2 k!4) (* 4 k!5)))\n  (<= (+ k!3 (* 2 k!4) (* 4 k!5)) 5)\n  (>= (+ (* 2 k!0) (* 4 k!1) (* 8 k!2) k!3 (* 2 k!4) (* 4 k!5)) 5)\n  (<= 0 k!0)\n  (<= k!0 1)\n  (<= 0 k!1)\n  (<= k!1 1)\n  (<= 0 k!2)\n  (<= k!2 1)\n  (<= 0 k!3)\n  (<= k!3 1)\n  (<= 0 k!4)\n  (<= k!4 1)\n  (<= 0 k!5)\n  (<= k!5 1)\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"3390acf0013c5925d53e6321d00c941df197df3c"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"parameters-21"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lia2pb_max_bits"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: 32) maximum number of bits to be used (per variable) in lia2pb."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lia2pb_partial"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: false) partial lia2pb conversion."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lia2pb_total_bits"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: 2048) total number of bits to be used (per problem) in lia2pb."),(0,l.kt)("td",{parentName:"tr",align:null})))),(0,l.kt)("h2",{id:"tactic-macro-finder"},"Tactic macro-finder"),(0,l.kt)("h3",{id:"short-description-36"},"Short Description"),(0,l.kt)("p",null,"Identifies and applies macros."),(0,l.kt)("h3",{id:"long-description-17"},"Long Description"),(0,l.kt)("p",null,"It finds implicit macro definitions in quantifiers.\nA main instance of a macro an equality that defines a function ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," using some term ",(0,l.kt)("inlineCode",{parentName:"p"},"t")," that does not contain ",(0,l.kt)("inlineCode",{parentName:"p"},"f"),".\nOther instances of macros are also recognized by the macro finder."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"(forall (x) (= (f x) t))"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"not (= (p x) t)")," is recognized as ",(0,l.kt)("inlineCode",{parentName:"p"},"(p x) = (not t)"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"(iff (= (f x) t) cond)"),"  rewrites to ",(0,l.kt)("inlineCode",{parentName:"p"},"(f x) = (if cond t else (k x))")),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"add clause ",(0,l.kt)("inlineCode",{parentName:"li"},"(not (= (k x) t))")))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"(= (+ (f x) s) t)")," becomes ",(0,l.kt)("inlineCode",{parentName:"p"},"(= (f x) (- t s))"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"(= (+ (* -1 (f x)) x) t)"),"  becomes ",(0,l.kt)("inlineCode",{parentName:"p"},"(= (f x) (- (- t s)))")))),(0,l.kt)("h3",{id:"example-28"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-fun f (Int) Int)\n(declare-fun p (Int) Bool)\n\n(assert (forall ((x Int)) (= (+ (f x) x) 3)))\n(assert (p (f 8)))\n(apply macro-finder)",result:{output:"(goals\n(goal\n  (p (- 5))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"67491fabe3eacf1eb160f5a49145d1ad3ae525e2"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"notes-17"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Supports proofs, unsat cores, but not goals with recursive function definitions.")),(0,l.kt)("h3",{id:"parameters-22"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_and"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: false) eliminate conjunctions during (internal) calls to the simplifier."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum amount of memory in megabytes."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"produce_models"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"model generation."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"produce_proofs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"proof generation."),(0,l.kt)("td",{parentName:"tr",align:null},"false")))),(0,l.kt)("h2",{id:"tactic-max-bv-sharing"},"Tactic max-bv-sharing"),(0,l.kt)("h3",{id:"short-description-37"},"Short Description"),(0,l.kt)("p",null,"Use heuristics to maximize the sharing of bit-vector expressions such as adders and multipliers"),(0,l.kt)("h3",{id:"long-description-18"},"Long Description"),(0,l.kt)("p",null,'Rewriter for "maximing" the number of shared terms.\nThe idea is to rewrite AC terms to maximize sharing.\nThis rewriter is particularly useful for reducing\nthe number of Adders and Multipliers before "bit-blasting".'),(0,l.kt)("h2",{id:"tactic-nla2bv"},"Tactic nla2bv"),(0,l.kt)("h3",{id:"short-description-38"},"Short Description"),(0,l.kt)("p",null,"Convert quantified NIA problems to bounded bit-vector arithmetic problems."),(0,l.kt)("h3",{id:"example-29"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Int)\n(declare-const y Int)\n(declare-const z Int)\n(assert (= (* x x y) (*  2 z y y)))\n(apply nla2bv)",result:{output:"(goals\n(goal\n  (let ((a!1 (bvmul ((_ sign_extend 5) (bvsub ((_ zero_extend 1) x!2) #b01000))\n                    ((_ sign_extend 5) (bvsub ((_ zero_extend 1) x!2) #b01000))))\n        (a!2 ((_ sign_extend 10)\n               ((_ sign_extend 5) (bvsub ((_ zero_extend 1) y!3) #b01000))))\n        (a!3 (bvsub ((_ zero_extend 1) (bvmul #x02 ((_ zero_extend 4) z!4)))\n                    ((_ zero_extend 1) (bvmul #x02 #x08))))\n        (a!4 ((_ sign_extend 9)\n               ((_ sign_extend 4) (bvsub ((_ zero_extend 1) y!3) #b01000))))\n        (a!5 ((_ sign_extend 18)\n               ((_ sign_extend 13) (bvsub ((_ zero_extend 1) y!3) #b01000)))))\n  (let ((a!6 (bvmul ((_ sign_extend 18) (bvmul ((_ sign_extend 9) a!3) a!4))\n                    a!5)))\n    (= ((_ sign_extend 16) (bvmul ((_ sign_extend 10) a!1) a!2)) a!6)))\n  :precision under :depth 1)\n)\n",error:"",status:"z3-ran",hash:"137f86f15443977a4001bb6b240eca6a0e71b995"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"notes-18"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The tactic creates an under-approximation (a stronger set of formulas)")),(0,l.kt)("h3",{id:"parameters-23"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"nla2bv_bv_size"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"default bit-vector size used by nla2bv tactic."),(0,l.kt)("td",{parentName:"tr",align:null},"4")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"nla2bv_divisor"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"nla2bv tactic parameter."),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"nla2bv_max_bv_size"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: inf) maximum bit-vector size used by nla2bv tactic"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"nla2bv_root"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"nla2bv tactic encodes reals into bit-vectors using expressions of the form a+b*sqrt(c), this parameter sets the value of c used in the encoding."),(0,l.kt)("td",{parentName:"tr",align:null},"2")))),(0,l.kt)("h2",{id:"tactic-nlsat"},"Tactic nlsat"),(0,l.kt)("h3",{id:"short-description-39"},"Short Description"),(0,l.kt)("p",null,"(try to) solve goal using a nonlinear arithmetic solver"),(0,l.kt)("h3",{id:"example-30"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Real)\n(declare-const y Real)\n(assert (> (* x x) (* y x)))\n(assert (> x 0))\n(assert (< y 1))\n(apply (then simplify purify-arith nlsat))",result:{output:"(goals\n(goal\n  :precision precise :depth 6)\n)\n",error:"",status:"z3-ran",hash:"4956adce421b06b34c3e89606dc6d71d1619d6c4"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"parameters-24"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"check_lemmas"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"check lemmas on the fly using an independent nlsat solver"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"factor"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: true) factor polynomials."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"factor_max_prime"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step"),(0,l.kt)("td",{parentName:"tr",align:null},"31")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"factor_num_primes"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"factor_search_size"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space"),(0,l.kt)("td",{parentName:"tr",align:null},"5000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"inline_vars"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"inline variables that can be isolated from equations (not supported in incremental mode)"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lazy"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"how lazy the solver is."),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"log_lemmas"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"display lemmas as self-contained SMT formulas"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_conflicts"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum number of conflicts."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum amount of memory in megabytes."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_prime"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_search_size"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"min_mag"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"Z3 represents algebraic numbers using a (square-free) polynomial p and an isolating interval (which contains one and only one root of p). This interval may be refined during the computations. This parameter specifies whether to cache the value of a refined interval or not. It says the minimal size of an interval for caching purposes is 1/2^16"),(0,l.kt)("td",{parentName:"tr",align:null},"16")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"minimize_conflicts"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"minimize conflicts"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"num_primes"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: 1) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"randomize"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"randomize selection of a witness in nlsat."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"reorder"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"reorder variables."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"seed"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"random seed."),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"shuffle_vars"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use a random variable order."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"simplify_conflicts"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"simplify conflicts using equalities before resolving them in nlsat solver."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"zero_accuracy"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"one of the most time-consuming operations in the real algebraic number module is determining the sign of a polynomial evaluated at a sample point with non-rational algebraic number values. Let k be the value of this option. If k is 0, Z3 uses precise computation. Otherwise, the result of a polynomial evaluation is considered to be 0 if Z3 can show it is inside the interval (-1/2^k, 1/2^k)"),(0,l.kt)("td",{parentName:"tr",align:null},"0")))),(0,l.kt)("h2",{id:"tactic-nnf"},"Tactic nnf"),(0,l.kt)("h3",{id:"short-description-40"},"Short Description:"),(0,l.kt)("p",null,"The tactic converts formulas to negation normal form (NNF)"),(0,l.kt)("h3",{id:"long-description-19"},"Long Description"),(0,l.kt)("p",null,"In NNF, negations only appear in front of atomic formulas. "),(0,l.kt)("p",null,"Standard rules for conversion into negation normal form are:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"(not (and p q))")," is converted to ",(0,l.kt)("inlineCode",{parentName:"li"},"(or (not p) (not q))")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"(not (or p q))")," is converted to ",(0,l.kt)("inlineCode",{parentName:"li"},"(and (not p) (not q))")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"(not (not p))")," is converted to ",(0,l.kt)("inlineCode",{parentName:"li"},"p")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"(not (exists x. p))")," is converted to ",(0,l.kt)("inlineCode",{parentName:"li"},"(forall x. (not p))")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"(not (forall x. p))")," is converted to ",(0,l.kt)("inlineCode",{parentName:"li"},"(exists x. (not p))"))),(0,l.kt)("p",null,"Once all negations are pushed inside, the resulting formula is in NNF."),(0,l.kt)("h3",{id:"example-31"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"  (declare-const x Int)\n  (assert (not (or (> x 0) (< x 0))))\n  (apply nnf)",result:{output:"(goals\n(goal\n  (not (> x 0))\n  (not (< x 0))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"4879f45e416fbc85265e96d40497f385e8cac8ae"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"notes-19"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"supports unsat cores, proof terms")),(0,l.kt)("h3",{id:"parameters-25"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ignore_labels"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"remove/ignore labels in the input formula, this option is ignored if proofs are enabled"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum amount of memory in megabytes"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mode"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full"),(0,l.kt)("td",{parentName:"tr",align:null},"skolem")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sk_hack"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"hack for VCC"),(0,l.kt)("td",{parentName:"tr",align:null},"false")))),(0,l.kt)("h2",{id:"tactic-normalize-bounds"},"Tactic normalize-bounds"),(0,l.kt)("h3",{id:"short-description-41"},"Short Description"),(0,l.kt)("p",null,"Replace ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("mi",{parentName:"mrow"},"x")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"x")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"x")))))," with ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("msup",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msup"},"x"),(0,l.kt)("mo",{parentName:"msup",mathvariant:"normal",lspace:"0em",rspace:"0em"},"\u2032")),(0,l.kt)("mo",{parentName:"mrow"},"+"),(0,l.kt)("mi",{parentName:"mrow"},"l")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"x' + l")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8352em",verticalAlign:"-0.0833em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.7519em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},"\u2032"))))))))),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,l.kt)("span",{parentName:"span",className:"mbin"},"+"),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}})),(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,l.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.01968em"}},"l"))))),", when ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("mi",{parentName:"mrow"},"l"),(0,l.kt)("mo",{parentName:"mrow"},"\u2264"),(0,l.kt)("mi",{parentName:"mrow"},"x")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"l \\leq x")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8304em",verticalAlign:"-0.136em"}}),(0,l.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.01968em"}},"l"),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,l.kt)("span",{parentName:"span",className:"mrel"},"\u2264"),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"))))),"\nwhere ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("msup",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msup"},"x"),(0,l.kt)("mo",{parentName:"msup",mathvariant:"normal",lspace:"0em",rspace:"0em"},"\u2032"))),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"x'")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.7519em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.7519em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},"\u2032")))))))))))))," is a fresh variable.\nNote that, after the transformation ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("mn",{parentName:"mrow"},"0"),(0,l.kt)("mo",{parentName:"mrow"},"\u2264"),(0,l.kt)("msup",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msup"},"x"),(0,l.kt)("mo",{parentName:"msup",mathvariant:"normal",lspace:"0em",rspace:"0em"},"\u2032"))),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"0 \\leq x'")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.7804em",verticalAlign:"-0.136em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},"0"),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,l.kt)("span",{parentName:"span",className:"mrel"},"\u2264"),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.7519em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.7519em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},"\u2032"))))))))))))),"."),(0,l.kt)("h3",{id:"example-32"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Int)\n(declare-const y Int)\n(declare-const z Int)\n(assert (<= 3 x))\n(assert (<= (+ x y) z))\n(apply normalize-bounds)",result:{output:"(goals\n(goal\n  (<= 0 k!0)\n  (<= (+ k!0 y) (+ (- 3) z))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"240d52032e6160d76ddf3a65bcee051283517a91"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"notes-20"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"supports proofs and cores")),(0,l.kt)("h3",{id:"parameters-26"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"norm_int_only"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"normalize only the bounds of integer constants."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"produce_models"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"model generation."),(0,l.kt)("td",{parentName:"tr",align:null},"false")))),(0,l.kt)("h2",{id:"tactic-occf"},"Tactic occf"),(0,l.kt)("h3",{id:"short-description-42"},"Short Description"),(0,l.kt)("p",null,"Put goal in one constraint per clause normal form "),(0,l.kt)("h3",{id:"long-description-20"},"Long Description"),(0,l.kt)("p",null,"Put clauses in the assertion set in\nOOC (one constraint per clause) form.\nConstraints occurring in formulas that\nare not clauses are ignored.\nThe formula can be put into CNF by\nusing ",(0,l.kt)("inlineCode",{parentName:"p"},"mk_sat_preprocessor")," strategy."),(0,l.kt)("h3",{id:"example-33"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Int)\n(declare-const y Int)\n\n(assert (or (= x y) (> x (- y))))\n(assert (or (= x y) (< x (- y))))\n(apply occf)",result:{output:"(goals\n(goal\n  (or k!0 (= x y))\n  (or k!1 (= x y))\n  (or (not k!0) (> x (- y)))\n  (or (not k!1) (< x (- y)))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"992434fae73048d2ca5c31afe5c1ba32519e149f"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"notes-21"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Does not support proofs"),(0,l.kt)("li",{parentName:"ul"},"only clauses are considered")),(0,l.kt)("h2",{id:"tactic-pb2bv"},"Tactic pb2bv"),(0,l.kt)("h3",{id:"short-description-43"},"Short Description"),(0,l.kt)("p",null,"Convert pseudo-boolean constraints to bit-vectors"),(0,l.kt)("h3",{id:"example-34"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Int)\n(declare-const y Int)\n(declare-const z Int)\n(declare-const u Int)\n(assert (<= 0 x))\n(assert (<= 0 y))\n(assert (<= 0 z))\n(assert (<= 0 u))\n(assert (<= x 1))\n(assert (<= y 1))\n(assert (<= z 1))\n(assert (<= u 1))\n(assert (>= (+ (* 3 x) (* 2 y) (* 2 z) (* 2 u)) 4))\n(apply pb2bv)",result:{output:"(goals\n(goal\n  true\n  true\n  true\n  true\n  true\n  true\n  true\n  true\n  (or k!0 k!1 k!2)\n  (or k!0 k!1 k!3)\n  (or k!0 k!2 k!3)\n  (or k!1 k!2 k!3)\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"9895f02eb9e1c3f7064e036e5c4fa10a0b98f6a2"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"parameters-27"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_distinct"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand a distinct predicate into a quadratic number of disequalities"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_distinct_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cardinality.encoding"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"encoding used for cardinality constraints: grouped, bimander, ordered, unate, circuit"),(0,l.kt)("td",{parentName:"tr",align:null},"none")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate ite in favor of and/or"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"flat_and_or"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"create nary applications for and,or"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ite_extra_rules"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extra ite simplifications, these additional simplifications may reduce size locally but increase globally"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"keep_cardinality_constraints"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"retain cardinality constraints (don't bit-blast them) and use built-in cardinality solver"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_ctx"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"perform local (i.e., cheap) context simplifications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_ctx_limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"limit for applying local context simplifier"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum amount of memory in megabytes."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pb.solver"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"encoding used for Pseudo-Boolean constraints: totalizer, sorting, binary_merge, bv, solver. PB constraints are retained if set to 'solver'"),(0,l.kt)("td",{parentName:"tr",align:null},"solver")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pb2bv_all_clauses_limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: 8) maximum number of literals for using equivalent CNF encoding of PB constraint."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pb2bv_cardinality_limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: inf) limit for using arc-consistent cardinality constraint encoding."),(0,l.kt)("td",{parentName:"tr",align:null})))),(0,l.kt)("h2",{id:"tactic-propagate-bv-bounds"},"Tactic propagate-bv-bounds"),(0,l.kt)("h3",{id:"short-description-44"},"Short Description"),(0,l.kt)("p",null,"Contextual bounds simplification tactic."),(0,l.kt)("h3",{id:"example-35"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x (_ BitVec 32))\n(declare-const y (_ BitVec 32))\n(declare-const z (_ BitVec 32))\n(assert (bvule (_ bv4 32) x))\n(assert (bvule x (_ bv24 32)))\n(assert (or (bvule x (_ bv100 32)) (bvule (_ bv32 32) x)))\n(apply propagate-bv-bounds)",result:{output:"(goals\n(goal\n  (bvule #x00000004 x)\n  (bvule x #x00000018)\n  true\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"3541f65fcb47a59a959841c6c4b8a503dcc0c24f"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"notes-22"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"assumes that bit-vector inequalities have been simplified to use bvule/bvsle")),(0,l.kt)("h3",{id:"parameters-28"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_depth"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum term depth."),(0,l.kt)("td",{parentName:"tr",align:null},"1024")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum amount of memory in megabytes."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_steps"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum number of steps."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"propagate_eq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable equality propagation from bounds."),(0,l.kt)("td",{parentName:"tr",align:null},"false")))),(0,l.kt)("h2",{id:"tactic-propagate-ineqs"},"Tactic propagate-ineqs"),(0,l.kt)("h3",{id:"short-description-45"},"Short Description"),(0,l.kt)("p",null,"Propagate ineqs/bounds, remove subsumed inequalities"),(0,l.kt)("h3",{id:"long-description-21"},"Long Description"),(0,l.kt)("p",null,"This tactic performs the following tasks:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Propagate bounds using the bound_propagator.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Eliminate subsumed inequalities."),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"For example:\n",(0,l.kt)("inlineCode",{parentName:"li"},"x - y >= 3")," can be replaced with true if we know that ",(0,l.kt)("inlineCode",{parentName:"li"},"x >= 3")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"y <= 0")))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Convert inequalities of the form ",(0,l.kt)("inlineCode",{parentName:"p"},"p <= k")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"p >= k")," into ",(0,l.kt)("inlineCode",{parentName:"p"},"p = k"),",\nwhere ",(0,l.kt)("inlineCode",{parentName:"p"},"p")," is a polynomial and ",(0,l.kt)("inlineCode",{parentName:"p"},"k")," is a constant."))),(0,l.kt)("p",null,"This strategy assumes the input is in arith LHS mode.\nThis can be achieved by using option :arith-lhs true in the simplifier."),(0,l.kt)("h3",{id:"example-36"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Int)\n(declare-const y Int)\n(declare-const z Int)\n(declare-const u Int)\n(declare-const v Int)\n(declare-const w Int)\n(assert (>= x 3))\n(assert (<= y 0))\n(assert (>= (- x y) 3))\n(assert (>= (* u v w) 2))\n(assert (<= (* v u w) 2))\n(apply (and-then simplify propagate-ineqs))",result:{output:"(goals\n(goal\n  (>= x 3)\n  (<= y 0)\n  (= (* u v w) 2)\n  :precision precise :depth 2)\n)\n",error:"",status:"z3-ran",hash:"2c3e3e1b8e7390376ddc6238efc992ff1415fab1"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"parameters-29"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bound_max_refinements"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: 16) maximum number of bound refinements (per round) for unbounded variables."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bound_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: 0.05) bound propagation improvement threshold ratio."),(0,l.kt)("td",{parentName:"tr",align:null})))),(0,l.kt)("h2",{id:"tactic-propagate-values"},"Tactic propagate-values"),(0,l.kt)("h3",{id:"short-description-46"},"Short Description:"),(0,l.kt)("p",null,"Tactic for propagating equalities ",(0,l.kt)("inlineCode",{parentName:"p"},"(= t v)")," where ",(0,l.kt)("inlineCode",{parentName:"p"},"v")," is a value"),(0,l.kt)("h3",{id:"long-description-22"},"Long Description"),(0,l.kt)("p",null,"In a context where terms are equated to constants it is invariably beneficial to\nreplace terms, that can be compound, with the constants and then simplify the resulting formulas.\nThe propagate-values tactic accomplishes the task of replacing such terms."),(0,l.kt)("h3",{id:"example-37"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Int)\n(declare-const y Int)\n(declare-fun f (Int) Int)\n(assert (= 1 (f (+ x y))))\n(assert (= 2 x))\n(assert (> (f (+ 2 y)) y))\n(apply propagate-values)",result:{output:"(goals\n(goal\n  (= 1 (f (+ 2 y)))\n  (= 2 x)\n  (not (<= 1 y))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"fc182fd848b4644a47b4d5b414ad422fe2ad062d"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"notes-23"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"supports unsat cores")),(0,l.kt)("h3",{id:"parameters-30"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"algebraic_number_evaluator"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"simplify/evaluate expressions containing (algebraic) irrational numbers."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith_ineq_lhs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite inequalities so that right-hand-side is a constant."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith_lhs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"all monomials are moved to the left-hand-side, and the right-hand-side is just a constant."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bit2bool"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"try to convert bit-vector terms of size 1 into Boolean terms"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_distinct"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand a distinct predicate into a quadratic number of disequalities"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_distinct_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_eq_value"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"blast (some) Bit-vector equalities into bits"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_select_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eagerly replace all (select (store ..) ..) term by an if-then-else term"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_extract_prop"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"attempt to partially propagate extraction inwards"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_ineq_consistency_test_max"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"max size of conjunctions on which to perform consistency test based on inequalities on bitvectors."),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_ite2id"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite ite that can be simplified to identity"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_le2extract"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"disassemble bvule to extract"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_le_extra"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"additional bu_(u/s)le simplifications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_not_simpl"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"apply simplifications for bvnot"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_sort_ac"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort the arguments of all AC operators"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cache_all"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"cache all intermediate results."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_and"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"conjunctions are rewritten using negation and disjunctions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate ite in favor of and/or"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_rem"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace (rem x y) with (ite (",">","= y 0) (mod x y) (- (mod x y)))."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_sign_ext"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand sign-ext operator using concat and extract"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_to_real"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate to_real from arithmetic predicates that contain only integers."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"eq2ineq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand equalities into two inequalities"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_nested_stores"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace nested stores by a lambda expression"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_power"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand (^ t k) into (* t ... t) if  1 ","<"," k ","<","= max_degree."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_select_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand select over ite expressions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_select_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"conservatively replace a (select (store ...) ...) term by an if-then-else term"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_store_eq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"reduce (store ...) = (store ...) with a common base into selects"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_tan"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace (tan x) with (/ (sin x) (cos x))."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"flat"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"flat_and_or"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"create nary applications for and,or"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"gcd_rounding"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use gcd rounding on integer arithmetic atoms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hi_div0"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use the 'hardware interpretation' for division by zero (for bit-vector terms)"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hoist_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"hoist shared summands under ite expressions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hoist_mul"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"hoist multiplication over summation to minimize number of multiplications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ignore_patterns_on_ground_qbody"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"ignores patterns on quantifiers that don't mention their bound variables."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ite_extra_rules"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extra ite simplifications, these additional simplifications may reduce size locally but increase globally"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_ctx"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"perform local (i.e., cheap) context simplifications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_ctx_limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"limit for applying local context simplifier"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_degree"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"max degree of algebraic numbers (and power operators) processed by simplifier."),(0,l.kt)("td",{parentName:"tr",align:null},"64")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum amount of memory in megabytes"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_rounds"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum number of rounds."),(0,l.kt)("td",{parentName:"tr",align:null},"4")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_steps"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum number of steps"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mul2concat"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace multiplication by a power of two into a concatenation"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mul_to_power"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"collpase (* t ... t) into (^ t k), it is ignored if expand_power is true."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pull_cheap_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"pull if-then-else terms when cheap."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_ite_arith"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"push if-then-else over arithmetic terms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_ite_bv"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"push if-then-else over bit-vector terms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_to_real"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"distribute to_real over * and +."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"rewrite_patterns"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite patterns."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"som"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"put polynomials in sum-of-monomials form"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"som_blowup"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sort_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort nested stores when the indices are known to be different"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sort_sums"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort the arguments of + application."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"split_concat_eq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"split equalities of the form (= (concat t1 t2) t3)"),(0,l.kt)("td",{parentName:"tr",align:null},"false")))),(0,l.kt)("h2",{id:"tactic-purify-arith"},"Tactic purify-arith"),(0,l.kt)("h3",{id:"short-description-47"},"Short Description"),(0,l.kt)("p",null,"Eliminate unnecessary operators: -, /, div, mod, rem, is-int, to-int, ^, root-objects.\nThese operators can be replaced by introcing fresh variables and using multiplication and addition."),(0,l.kt)("h3",{id:"example-38"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Int)\n(declare-const y Int)\n(declare-const z Int)\n(declare-const u Int)\n(declare-const v Int)\n(declare-const w Int)\n(assert (= (div x 3) y))\n(assert (= (mod z 4) u))\n(assert (> (mod v w) u))\n(apply purify-arith)",result:{output:"(goals\n(goal\n  (= k!0 y)\n  (= k!3 u)\n  (not (<= k!5 u))\n  (= x (+ (* 3 k!0) k!1))\n  (<= 0 k!1)\n  (not (<= 3 k!1))\n  (= z (+ (* 4 k!2) k!3))\n  (<= 0 k!3)\n  (not (<= 4 k!3))\n  (or (= w 0) (= v (+ (* k!4 w) k!5)))\n  (or (= w 0) (<= 0 k!5))\n  (or (not (<= w k!5)) (<= w 0))\n  (or (not (<= (* (- 1) w) k!5)) (>= w 0))\n  (or (not (= w 0)) (= k!4 (div v 0)))\n  (or (not (= w 0)) (= k!5 (mod v 0)))\n  (or (not (and (= x v) (= 3 w))) (= k!1 k!5))\n  (or (not (and (= z v) (= 4 w))) (= k!3 k!5))\n  (or (not (and (= x v) (= 3 w))) (= k!0 k!4))\n  (or (not (and (= z v) (= 4 w))) (= k!2 k!4))\n  :precision precise :depth 4)\n)\n",error:"",status:"z3-ran",hash:"89202982b8bb2dd1a5dac18682c023a2e53c02e7"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"parameters-31"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"algebraic_number_evaluator"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"simplify/evaluate expressions containing (algebraic) irrational numbers."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith_ineq_lhs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite inequalities so that right-hand-side is a constant."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith_lhs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"all monomials are moved to the left-hand-side, and the right-hand-side is just a constant."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bit2bool"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"try to convert bit-vector terms of size 1 into Boolean terms"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_distinct"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand a distinct predicate into a quadratic number of disequalities"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_distinct_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_eq_value"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"blast (some) Bit-vector equalities into bits"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_select_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eagerly replace all (select (store ..) ..) term by an if-then-else term"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_extract_prop"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"attempt to partially propagate extraction inwards"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_ineq_consistency_test_max"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"max size of conjunctions on which to perform consistency test based on inequalities on bitvectors."),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_ite2id"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite ite that can be simplified to identity"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_le2extract"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"disassemble bvule to extract"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_le_extra"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"additional bu_(u/s)le simplifications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_not_simpl"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"apply simplifications for bvnot"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_sort_ac"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort the arguments of all AC operators"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cache_all"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"cache all intermediate results."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"complete"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"add constraints to make sure that any interpretation of a underspecified arithmetic operators is a function. The result will include additional uninterpreted functions/constants: /0, div0, mod0, 0^0, neg-root"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_and"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"conjunctions are rewritten using negation and disjunctions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_inverses"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate inverse trigonometric functions (asin, acos, atan)."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate ite in favor of and/or"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_rem"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace (rem x y) with (ite (",">","= y 0) (mod x y) (- (mod x y)))."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_root_objects"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate root objects."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_sign_ext"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand sign-ext operator using concat and extract"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_to_real"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate to_real from arithmetic predicates that contain only integers."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"eq2ineq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand equalities into two inequalities"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_nested_stores"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace nested stores by a lambda expression"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_power"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand (^ t k) into (* t ... t) if  1 ","<"," k ","<","= max_degree."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_select_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand select over ite expressions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_select_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"conservatively replace a (select (store ...) ...) term by an if-then-else term"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_store_eq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"reduce (store ...) = (store ...) with a common base into selects"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_tan"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace (tan x) with (/ (sin x) (cos x))."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"flat"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"flat_and_or"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"create nary applications for and,or"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"gcd_rounding"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use gcd rounding on integer arithmetic atoms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hi_div0"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use the 'hardware interpretation' for division by zero (for bit-vector terms)"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hoist_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"hoist shared summands under ite expressions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hoist_mul"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"hoist multiplication over summation to minimize number of multiplications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ignore_labels"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"remove/ignore labels in the input formula, this option is ignored if proofs are enabled"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ignore_patterns_on_ground_qbody"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"ignores patterns on quantifiers that don't mention their bound variables."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ite_extra_rules"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extra ite simplifications, these additional simplifications may reduce size locally but increase globally"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_ctx"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"perform local (i.e., cheap) context simplifications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_ctx_limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"limit for applying local context simplifier"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_degree"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"max degree of algebraic numbers (and power operators) processed by simplifier."),(0,l.kt)("td",{parentName:"tr",align:null},"64")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum amount of memory in megabytes"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_steps"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum number of steps"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mode"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full"),(0,l.kt)("td",{parentName:"tr",align:null},"skolem")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mul2concat"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace multiplication by a power of two into a concatenation"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mul_to_power"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"collpase (* t ... t) into (^ t k), it is ignored if expand_power is true."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pull_cheap_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"pull if-then-else terms when cheap."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_ite_arith"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"push if-then-else over arithmetic terms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_ite_bv"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"push if-then-else over bit-vector terms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_to_real"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"distribute to_real over * and +."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"rewrite_patterns"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite patterns."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sk_hack"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"hack for VCC"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"som"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"put polynomials in sum-of-monomials form"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"som_blowup"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sort_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort nested stores when the indices are known to be different"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sort_sums"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort the arguments of + application."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"split_concat_eq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"split equalities of the form (= (concat t1 t2) t3)"),(0,l.kt)("td",{parentName:"tr",align:null},"false")))),(0,l.kt)("h2",{id:"tactic-qe"},"Tactic qe"),(0,l.kt)("h3",{id:"short-description-48"},"Short Description"),(0,l.kt)("p",null,"Apply quantifier elimination on quantified sub-formulas."),(0,l.kt)("h3",{id:"long-description-23"},"Long Description"),(0,l.kt)("p",null,"The tactic applies quantifier elimination procedures on quantified sub-formulas.\nIt relies on theory plugins that can perform quanifier elimination for selected theories.\nThese plugins include Booleans, bit-vectors, arithmetic (linear), arrays, and data-types (term algebra).\nIt performs feasibility checks on cases to throttle the set of sub-formulas where quantifier elimination\nis applied."),(0,l.kt)("h3",{id:"example-39"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Int)\n(declare-const y Int)\n(assert (exists ((z Int)) (and (<= x (* 2 z)) (<= (* 3 z) y))))\n(apply qe)",result:{output:"(goals\n(goal\n  (let ((a!1 (and (<= (+ (* 3 x) (* (- 2) y)) 0) (= 0 (mod x 2)))))\n    (or (<= (+ (* 3 x) (* (- 2) y)) (- 2)) a!1))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"1edf47b6d6390ba6e127b9e19391b5b3111e31c7"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"parameters-32"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"eliminate_variables_as_block"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: true) eliminate variables as a block (true) or one at a time (false)"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"qe_nonlinear"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: false) enable virtual term substitution."),(0,l.kt)("td",{parentName:"tr",align:null})))),(0,l.kt)("h2",{id:"tactic-qffp"},"Tactic qffp"),(0,l.kt)("h3",{id:"short-description-49"},"Short Description"),(0,l.kt)("p",null,"Tactic for QF_FP formulas"),(0,l.kt)("h2",{id:"tactic-qffpbv"},"Tactic qffpbv"),(0,l.kt)("h3",{id:"short-description-50"},"Short Description"),(0,l.kt)("p",null,"Tactic for QF_FPBV formulas"),(0,l.kt)("h3",{id:"parameters-33"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"abce"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate blocked clauses using asymmetric literals"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"acce"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate covered clauses using asymmetric added literals"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"algebraic_number_evaluator"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"simplify/evaluate expressions containing (algebraic) irrational numbers."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"anf"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable ANF based simplification in-processing"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"anf.delay"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"delay ANF simplification by in-processing round"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"anf.exlin"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable extended linear simplification"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.auto_config_simplex"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"force simplex solver in auto_config"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.bprop_on_pivoted_rows"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"propagate bounds on rows changed by the pivot operation"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.branch_cut_ratio"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"branch/cut ratio for linear integer arithmetic"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.dump_lemmas"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"dump arithmetic theory lemmas to files"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.eager_eq_axioms"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eager equality axioms"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.enable_hnf"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable hnf (Hermite Normal Form) cuts"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.greatest_error_pivot"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Pivoting strategy"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.ignore_int"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"treat integer variables as real"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.int_eq_branch"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"branching using derived integer equations"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.min"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"minimize cost"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"(incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.branching"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.delay"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of calls to final check before invoking bounded nlsat check"),(0,l.kt)("td",{parentName:"tr",align:null},"500")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.expp"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expensive patching"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.gr_q"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"grobner's quota"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.grobner"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"run grobner's basis heuristic"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.grobner_cnfl_to_report"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"grobner's maximum number of conflicts to report"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.grobner_eqs_growth"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"grobner's number of equalities growth"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.grobner_expr_degree_growth"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"grobner's maximum expr degree growth"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.grobner_expr_size_growth"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"grobner's maximum expr size growth"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.grobner_frequency"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"grobner's call frequency"),(0,l.kt)("td",{parentName:"tr",align:null},"4")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.grobner_max_simplified"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"grobner's maximum number of simplifications"),(0,l.kt)("td",{parentName:"tr",align:null},"10000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.grobner_subs_fixed"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"0 - no subs, 1 - substitute, 2 - substitute fixed zeros only"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.horner"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"run horner's heuristic"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.horner_frequency"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"horner's call frequency"),(0,l.kt)("td",{parentName:"tr",align:null},"4")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.horner_row_length_limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"row is disregarded by the heuristic if its length is longer than the value"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.horner_subs_fixed"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"0 - no subs, 1 - substitute, 2 - substitute fixed zeros only"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.nra"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.order"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"run order lemmas"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.rounds"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2"),(0,l.kt)("td",{parentName:"tr",align:null},"1024")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.nl.tangents"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"run tangent lemmas"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.print_ext_var_names"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"print external variable names"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.print_stats"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"print statistic"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.propagate_eqs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"propagate (cheap) equalities"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.propagation_mode"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.random_initial_value"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use random initial values in the simplex-based procedure for linear arithmetic"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.rep_freq"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"the report frequency, in how many iterations print the cost and other info"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.simplex_strategy"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"simplex strategy for the solver"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith.solver"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver"),(0,l.kt)("td",{parentName:"tr",align:null},"6")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith_ineq_lhs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite inequalities so that right-hand-side is a constant."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith_lhs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"all monomials are moved to the left-hand-side, and the right-hand-side is just a constant."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"array.extensional"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extensional array theory"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"array.weak"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"weak array theory"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"asymm_branch"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"asymmetric branching"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"asymm_branch.all"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"asymmetric branching on all literals per clause"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"asymm_branch.delay"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of simplification rounds to wait until invoking asymmetric branch simplification"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"asymm_branch.limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"approx. maximum number of literals visited during asymmetric branching"),(0,l.kt)("td",{parentName:"tr",align:null},"100000000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"asymm_branch.rounds"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximal number of rounds to run asymmetric branch simplifications if progress is made"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"asymm_branch.sampled"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use sampling based asymmetric branching based on binary implication graph"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ate"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"asymmetric tautology elimination"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"auto_config"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"automatically configure solver"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"backtrack.conflicts"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of conflicts before enabling chronological backtracking"),(0,l.kt)("td",{parentName:"tr",align:null},"4000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"backtrack.scopes"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of scopes to enable chronological backtracking"),(0,l.kt)("td",{parentName:"tr",align:null},"100")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bca"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"blocked clause addition - add blocked binary clauses"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bce"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate blocked clauses"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bce_at"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate blocked clauses only once at the given simplification round"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bce_delay"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"delay eliminate blocked clauses until simplification round"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"binspr"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable SPR inferences of binary propagation redundant clauses. This inprocessing step eliminates models"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bit2bool"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"try to convert bit-vector terms of size 1 into Boolean terms"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_add"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"bit-blast adders."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_distinct"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand a distinct predicate into a quadratic number of disequalities"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_distinct_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_eq_value"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"blast (some) Bit-vector equalities into bits"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_full"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"bit-blast any term with bit-vector sort, this option will make E-matching ineffective in any pattern containing bit-vector terms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_mul"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"bit-blast multipliers (and dividers, remainders)."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_quant"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"bit-blast quantified variables."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_select_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eagerly replace all (select (store ..) ..) term by an if-then-else term"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blocked_clause_limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum number of literals visited during blocked clause elimination"),(0,l.kt)("td",{parentName:"tr",align:null},"100000000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"branching.anti_exploration"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"apply anti-exploration heuristic for branch selection"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"branching.heuristic"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"branching heuristic vsids, chb"),(0,l.kt)("td",{parentName:"tr",align:null},"vsids")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"burst_search"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of conflicts before first global simplification"),(0,l.kt)("td",{parentName:"tr",align:null},"100")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv.delay"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"delay internalize expensive bit-vector operations"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv.enable_int2bv"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable support for int2bv and bv2int operators"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv.eq_axioms"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable redundant equality axioms for bit-vectors"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv.reflect"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"create enode for every bit-vector term"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv.size_reduce"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"pre-processing; turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv.watch_diseq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use watch lists instead of eager axioms for bit-vectors"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_extract_prop"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"attempt to partially propagate extraction inwards"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_ineq_consistency_test_max"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"max size of conjunctions on which to perform consistency test based on inequalities on bitvectors."),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_ite2id"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite ite that can be simplified to identity"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_le2extract"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"disassemble bvule to extract"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_le_extra"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"additional bu_(u/s)le simplifications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_not_simpl"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"apply simplifications for bvnot"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_sort_ac"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort the arguments of all AC operators"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cache_all"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"cache all intermediate results."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"candidate_models"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"create candidate models even when quantifier or theory reasoning is incomplete"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cardinality.encoding"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit"),(0,l.kt)("td",{parentName:"tr",align:null},"grouped")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cardinality.solver"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use cardinality solver"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"case_split"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cce"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate covered clauses"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"check_lemmas"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"check lemmas on the fly using an independent nlsat solver"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"clause_proof"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"record a clausal proof"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"common_patterns"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"minimize the number of auxiliary variables during CNF encoding by identifing commonly used patterns"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"complete"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"add constraints to make sure that any interpretation of a underspecified arithmetic operators is a function. The result will include additional uninterpreted functions/constants: /0, div0, mod0, 0^0, neg-root"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"context_solve"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"solve equalities under disjunctions."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"core.extend_nonlocal_patterns"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"core.extend_patterns"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extend unsat core with literals that trigger (potential) quantifier instances"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"core.extend_patterns.max_distance"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"limits the distance of a pattern-extended unsat core"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"core.minimize"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"minimize unsat core produced by SMT context"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"core.minimize_partial"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"apply partial (cheap) core minimization"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"core.validate"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"[internal]"," validate unsat core produced by SMT context. This option is intended for debugging"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cube_depth"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"cube depth."),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cut"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable AIG based simplification in-processing"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cut.aig"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extract aigs (and ites) from cluases for cut simplification"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cut.delay"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"delay cut simplification by in-processing round"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cut.dont_cares"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"integrate dont cares with cuts"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cut.force"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"force redoing cut-enumeration until a fixed-point"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cut.lut"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extract luts from clauses for cut simplification"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cut.npn3"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extract 3 input functions from clauses for cut simplification"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cut.redundancies"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"integrate redundancy checking of cuts"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cut.xor"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extract xors from clauses for cut simplification"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"dack"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"dack.eq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable dynamic ackermannization for transtivity of equalities"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"dack.factor"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"number of instance per conflict"),(0,l.kt)("td",{parentName:"tr",align:null},"0.1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"dack.gc"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"Dynamic ackermannization garbage collection frequency (per conflict)"),(0,l.kt)("td",{parentName:"tr",align:null},"2000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"dack.gc_inv_decay"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"Dynamic ackermannization garbage collection decay"),(0,l.kt)("td",{parentName:"tr",align:null},"0.8")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"dack.threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of times the congruence rule must be used before Leibniz's axiom is expanded"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ddfw.init_clause_weight"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"initial clause weight for DDFW local search"),(0,l.kt)("td",{parentName:"tr",align:null},"8")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ddfw.reinit_base"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"increment basis for geometric backoff scheme of re-initialization of weights"),(0,l.kt)("td",{parentName:"tr",align:null},"10000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ddfw.restart_base"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of flips used a starting point for hessitant restart backoff"),(0,l.kt)("td",{parentName:"tr",align:null},"100000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ddfw.threads"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of ddfw threads to run in parallel with sat solver"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ddfw.use_reward_pct"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"percentage to pick highest reward variable when it has reward 0"),(0,l.kt)("td",{parentName:"tr",align:null},"15")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ddfw_search"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use ddfw local search instead of CDCL"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"delay_units"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"if true then z3 will not restart when a unit clause is learned"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"delay_units_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum number of learned unit clauses before restarting, ignored if delay_units is false"),(0,l.kt)("td",{parentName:"tr",align:null},"32")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"dimacs.core"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extract core from DIMACS benchmarks"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"distributivity"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"minimize the number of auxiliary variables during CNF encoding by applying distributivity over unshared subformulas"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"distributivity_blowup"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum overhead for applying distributivity during CNF encoding"),(0,l.kt)("td",{parentName:"tr",align:null},"32")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"div0_ackermann_limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"a bound for number of congruence Ackermann lemmas for div0 modelling"),(0,l.kt)("td",{parentName:"tr",align:null},"1000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"drat.activity"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"dump variable activities"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"drat.binary"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use Binary DRAT output format"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"drat.check_sat"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"build up internal trace, check satisfying model"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"drat.check_unsat"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"build up internal proof and check"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"drat.disable"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"override anything that enables DRAT"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"drat.file"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"file to dump DRAT proofs"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"dt_lazy_splits"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"dyn_sub_res"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"dynamic subsumption resolution for minimizing learned clauses"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_and"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"conjunctions are rewritten using negation and disjunctions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_inverses"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate inverse trigonometric functions (asin, acos, atan)."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate ite in favor of and/or"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_rem"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace (rem x y) with (ite (",">","= y 0) (mod x y) (- (mod x y)))."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_root_objects"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate root objects."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_sign_ext"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand sign-ext operator using concat and extract"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_to_real"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate to_real from arithmetic predicates that contain only integers."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_unconstrained"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"pre-processing: eliminate unconstrained subterms"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_vars"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable variable elimination using resolution during simplification"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_vars_bdd"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable variable elimination using BDD recompilation during simplification"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_vars_bdd_delay"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"delay elimination of variables using BDDs until after simplification round"),(0,l.kt)("td",{parentName:"tr",align:null},"3")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"eliminate_mod"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate modulus from equations"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ematching"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"E-Matching based quantifier instantiation"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"enable_pre_simplify"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable pre simplifications before the bounded search"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"eq2ineq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand equalities into two inequalities"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"euf"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable euf solver (this feature is preliminary and not ready for general consumption)"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_nested_stores"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace nested stores by a lambda expression"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_power"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand (^ t k) into (* t ... t) if  1 ","<"," k ","<","= max_degree."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_select_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand select over ite expressions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_select_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"conservatively replace a (select (store ...) ...) term by an if-then-else term"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_store_eq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"reduce (store ...) = (store ...) with a common base into selects"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_tan"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace (tan x) with (/ (sin x) (cos x))."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"factor"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: true) factor polynomials."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"factor_max_prime"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step"),(0,l.kt)("td",{parentName:"tr",align:null},"31")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"factor_num_primes"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"factor_search_size"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space"),(0,l.kt)("td",{parentName:"tr",align:null},"5000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"fail_if_inconclusive"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: true) fail if found unsat (sat) for under (over) approximated goal."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"flat"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"flat_and_or"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"create nary applications for and,or"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"force_cleanup"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"force cleanup to remove tautologies and simplify clauses"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"gc"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"garbage collection strategy: psm, glue, glue_psm, dyn_psm"),(0,l.kt)("td",{parentName:"tr",align:null},"glue_psm")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"gc.burst"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"perform eager garbage collection during initialization"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"gc.defrag"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"defragment clauses when garbage collecting"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"gc.increment"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"increment to the garbage collection threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"500")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"gc.initial"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"learned clauses garbage collection frequency"),(0,l.kt)("td",{parentName:"tr",align:null},"20000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"gc.k"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm)"),(0,l.kt)("td",{parentName:"tr",align:null},"7")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"gc.small_lbd"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"learned clauses with small LBD are never deleted (only used in dyn_psm)"),(0,l.kt)("td",{parentName:"tr",align:null},"3")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"gcd_rounding"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use gcd rounding on integer arithmetic atoms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hi_div0"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use the 'hardware interpretation' for division by zero (for bit-vector terms)"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hoist_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"hoist shared summands under ite expressions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hoist_mul"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"hoist multiplication over summation to minimize number of multiplications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ignore_labels"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"remove/ignore labels in the input formula, this option is ignored if proofs are enabled"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ignore_patterns_on_ground_qbody"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"ignores patterns on quantifiers that don't mention their bound variables."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"induction"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable generation of induction lemmas"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"inline_vars"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"inline variables that can be isolated from equations (not supported in incremental mode)"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"inprocess.max"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximal number of inprocessing passes"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"inprocess.out"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"file to dump result of the first inprocessing step and exit"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ite_chaing"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"minimize the number of auxiliary variables during CNF encoding by identifing if-then-else chains"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ite_extra"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ite_extra_rules"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extra ite simplifications, these additional simplifications may reduce size locally but increase globally"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ite_solver"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use if-then-else solver."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lazy"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"how lazy the solver is."),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"learned"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: false) collect also learned clauses."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lemma_gc_strategy"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_ctx"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"perform local (i.e., cheap) context simplifications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_ctx_limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"limit for applying local context simplifier"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_search"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use local search instead of CDCL"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_search_dbg_flips"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"write debug information for number of flips"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_search_mode"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"local search algorithm, either default wsat or qsat"),(0,l.kt)("td",{parentName:"tr",align:null},"wsat")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_search_threads"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of local search threads to find satisfiable solution"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"log_lemmas"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"display lemmas as self-contained SMT formulas"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"logic"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"logic used to setup the SMT solver"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead.cube.cutoff"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat"),(0,l.kt)("td",{parentName:"tr",align:null},"depth")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead.cube.depth"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth."),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead.cube.fraction"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat"),(0,l.kt)("td",{parentName:"tr",align:null},"0.4")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead.cube.freevars"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"cube free variable fraction. Used when lookahead.cube.cutoff is freevars"),(0,l.kt)("td",{parentName:"tr",align:null},"0.8")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead.cube.psat.clause_base"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"clause base for PSAT cutoff"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead.cube.psat.trigger"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat"),(0,l.kt)("td",{parentName:"tr",align:null},"5")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead.cube.psat.var_exp"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"free variable exponent for PSAT cutoff"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead.delta_fraction"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"number between 0 and 1, the smaller the more literals are selected for double lookahead"),(0,l.kt)("td",{parentName:"tr",align:null},"1.0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead.double"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable doubld lookahead"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead.global_autarky"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"prefer to branch on variables that occur in clauses that are reduced"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead.preselect"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use pre-selection of subset of variables for branching"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead.reward"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu"),(0,l.kt)("td",{parentName:"tr",align:null},"march_cu")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead.use_learned"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use learned clauses when selecting lookahead literal"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead_scores"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extract lookahead scores. A utility that can only be used from the DIMACS front-end"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead_simplify"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use lookahead solver during simplification"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead_simplify.bca"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"add learned binary clauses as part of lookahead simplification"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"macro_finder"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"try to find universally quantified formulas that can be viewed as macros"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_args"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: 128) maximum number of arguments (per application) that will be considered by the greedy (quadratic) heuristic."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_conflicts"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum number of conflicts before giving up."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_degree"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"max degree of algebraic numbers (and power operators) processed by simplifier."),(0,l.kt)("td",{parentName:"tr",align:null},"64")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum amount of memory in megabytes"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_prime"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_rounds"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum number of rounds."),(0,l.kt)("td",{parentName:"tr",align:null},"4")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_search_size"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_steps"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum number of steps"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mbqi"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"model based quantifier instantiation (MBQI)"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mbqi.force_template"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight ",">","= mbqi.force_template are forced to be used as a template"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mbqi.id"),(0,l.kt)("td",{parentName:"tr",align:null},"string"),(0,l.kt)("td",{parentName:"tr",align:null},"Only use model-based instantiation for quantifiers with id's beginning with string"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mbqi.max_cexs"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mbqi.max_cexs_incr"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mbqi.max_iterations"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum number of rounds of MBQI"),(0,l.kt)("td",{parentName:"tr",align:null},"1000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mbqi.trace"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"min_mag"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"Z3 represents algebraic numbers using a (square-free) polynomial p and an isolating interval (which contains one and only one root of p). This interval may be refined during the computations. This parameter specifies whether to cache the value of a refined interval or not. It says the minimal size of an interval for caching purposes is 1/2^16"),(0,l.kt)("td",{parentName:"tr",align:null},"16")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"minimize_conflicts"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"minimize conflicts"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"minimize_lemmas"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"minimize learned clauses"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mode"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full"),(0,l.kt)("td",{parentName:"tr",align:null},"skolem")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mul2concat"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace multiplication by a power of two into a concatenation"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mul_to_power"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"collpase (* t ... t) into (^ t k), it is ignored if expand_power is true."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"nla2bv_bv_size"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"default bit-vector size used by nla2bv tactic."),(0,l.kt)("td",{parentName:"tr",align:null},"4")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"nla2bv_divisor"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"nla2bv tactic parameter."),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"nla2bv_max_bv_size"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: inf) maximum bit-vector size used by nla2bv tactic"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"nla2bv_root"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"nla2bv tactic encodes reals into bit-vectors using expressions of the form a+b*sqrt(c), this parameter sets the value of c used in the encoding."),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"num_primes"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: 1) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"override_incremental"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pb.conflict_frequency"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"conflict frequency for Pseudo-Boolean theory"),(0,l.kt)("td",{parentName:"tr",align:null},"1000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pb.learn_complements"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"learn complement literals for Pseudo-Boolean theory"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pb.lemma_format"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"generate either cardinality or pb lemmas"),(0,l.kt)("td",{parentName:"tr",align:null},"cardinality")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pb.min_arity"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"minimal arity to compile pb/cardinality constraints to CNF"),(0,l.kt)("td",{parentName:"tr",align:null},"9")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pb.resolve"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"resolution strategy for boolean algebra solver: cardinality, rounding"),(0,l.kt)("td",{parentName:"tr",align:null},"cardinality")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pb.solver"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver)"),(0,l.kt)("td",{parentName:"tr",align:null},"solver")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"phase"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"phase selection strategy: always_false, always_true, basic_caching, random, caching"),(0,l.kt)("td",{parentName:"tr",align:null},"caching")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"phase.sticky"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use sticky phase caching"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"phase_caching_off"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of conflicts while phase caching is off"),(0,l.kt)("td",{parentName:"tr",align:null},"100")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"phase_caching_on"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of conflicts while phase caching is on"),(0,l.kt)("td",{parentName:"tr",align:null},"400")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"phase_selection"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory"),(0,l.kt)("td",{parentName:"tr",align:null},"3")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"prob_search"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use probsat local search instead of CDCL"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"probing"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"apply failed literal detection during simplification"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"probing_binary"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"probe binary clauses"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"probing_cache"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"add binary literals as lemmas"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"probing_cache_limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"cache binaries unless overall memory usage exceeds cache limit"),(0,l.kt)("td",{parentName:"tr",align:null},"1024")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"probing_limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"limit to the number of probe calls"),(0,l.kt)("td",{parentName:"tr",align:null},"5000000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"propagate.prefetch"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"prefetch watch lists for assigned literals"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"propagate_values"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"pre-processing: propagate values"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pull_cheap_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"pull if-then-else terms when cheap."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pull_nested_quantifiers"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"pre-processing: pull nested quantifiers"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_ite_arith"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"push if-then-else over arithmetic terms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_ite_bv"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"push if-then-else over bit-vector terms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_to_real"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"distribute to_real over * and +."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"q.lift_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"q.lite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Use cheap quantifier elimination during pre-processing"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"qi.cost"),(0,l.kt)("td",{parentName:"tr",align:null},"string"),(0,l.kt)("td",{parentName:"tr",align:null},"expression specifying what is the cost of a given quantifier instantiation"),(0,l.kt)("td",{parentName:"tr",align:null},"(+ weight generation)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"qi.eager_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"threshold for eager quantifier instantiation"),(0,l.kt)("td",{parentName:"tr",align:null},"10.0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"qi.lazy_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"threshold for lazy quantifier instantiation"),(0,l.kt)("td",{parentName:"tr",align:null},"20.0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"qi.max_instances"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum number of quantifier instantiations"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"qi.max_multi_patterns"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"specify the number of extra multi patterns"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"qi.profile"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"profile quantifier instantiation"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"qi.profile_freq"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"how frequent results are reported by qi.profile"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"qi.quick_checker"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"quasi_macros"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"try to find universally quantified formulas that are quasi-macros"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"random_freq"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"frequency of random case splits"),(0,l.kt)("td",{parentName:"tr",align:null},"0.01")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"random_seed"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"random seed for the smt solver"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"randomize"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"randomize selection of a witness in nlsat."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"refine_inj_axioms"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"pre-processing: refine injectivity axioms"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"relevancy"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"reorder"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"reorder variables."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"reorder.activity_scale"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"scaling factor for activity update"),(0,l.kt)("td",{parentName:"tr",align:null},"100")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"reorder.base"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of conflicts per random reorder"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"reorder.itau"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"inverse temperature for softmax"),(0,l.kt)("td",{parentName:"tr",align:null},"4.0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"rephase.base"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of conflicts per rephase"),(0,l.kt)("td",{parentName:"tr",align:null},"1000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"resolution.cls_cutoff1"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination"),(0,l.kt)("td",{parentName:"tr",align:null},"100000000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"resolution.cls_cutoff2"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination"),(0,l.kt)("td",{parentName:"tr",align:null},"700000000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"resolution.limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"approx. maximum number of literals visited during variable elimination"),(0,l.kt)("td",{parentName:"tr",align:null},"500000000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"resolution.lit_cutoff_range1"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses"),(0,l.kt)("td",{parentName:"tr",align:null},"700")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"resolution.lit_cutoff_range2"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2"),(0,l.kt)("td",{parentName:"tr",align:null},"400")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"resolution.lit_cutoff_range3"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2"),(0,l.kt)("td",{parentName:"tr",align:null},"300")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"resolution.occ_cutoff"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"first cutoff (on number of positive/negative occurrences) for Boolean variable elimination"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"resolution.occ_cutoff_range1"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses"),(0,l.kt)("td",{parentName:"tr",align:null},"8")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"resolution.occ_cutoff_range2"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2"),(0,l.kt)("td",{parentName:"tr",align:null},"5")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"resolution.occ_cutoff_range3"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2"),(0,l.kt)("td",{parentName:"tr",align:null},"3")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"restart"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"restart strategy: static, luby, ema or geometric"),(0,l.kt)("td",{parentName:"tr",align:null},"ema")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"restart.emafastglue"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"ema alpha factor for fast moving average"),(0,l.kt)("td",{parentName:"tr",align:null},"0.03")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"restart.emaslowglue"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"ema alpha factor for slow moving average"),(0,l.kt)("td",{parentName:"tr",align:null},"1e-05")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"restart.factor"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"restart increment factor for geometric strategy"),(0,l.kt)("td",{parentName:"tr",align:null},"1.5")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"restart.fast"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use fast restart approach only removing less active literals."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"restart.initial"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"initial restart (number of conflicts)"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"restart.margin"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"margin between fast and slow restart factors. For ema"),(0,l.kt)("td",{parentName:"tr",align:null},"1.1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"restart.max"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximal number of restarts."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"restart_factor"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"1.1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"restart_strategy"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"restricted_quasi_macros"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"try to find universally quantified formulas that are restricted quasi-macros"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"retain_blocked_clauses"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"retain blocked clauses as lemmas"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"rewrite_patterns"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite patterns."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"scc"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate Boolean variables by computing strongly connected components"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"scc.tr"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"apply transitive reduction, eliminate redundant binary clauses"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"search.sat.conflicts"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"period for solving for sat (in number of conflicts)"),(0,l.kt)("td",{parentName:"tr",align:null},"400")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"search.unsat.conflicts"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"period for solving for unsat (in number of conflicts)"),(0,l.kt)("td",{parentName:"tr",align:null},"400")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"seed"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"random seed."),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"seq.max_unfolding"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximal unfolding depth for checking string equations and regular expressions"),(0,l.kt)("td",{parentName:"tr",align:null},"1000000000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"seq.min_unfolding"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"seq.split_w_len"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable splitting guided by length constraints"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"seq.validate"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable self-validation of theory axioms created by seq theory"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"shuffle_vars"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use a random variable order."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"simplify.delay"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"set initial delay of simplification by a conflict count"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"simplify_conflicts"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"simplify conflicts using equalities before resolving them in nlsat solver."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sk_hack"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"hack for VCC"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"smt"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use the SAT solver based incremental SMT core"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"smt.proof.check"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"check SMT proof while it is created"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"smt.proof.check_rup"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"apply forward RUP proof checking"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"solve_eqs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"pre-processing: solve equalities"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"solve_eqs_max_occs"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum number of occurrences for considering a variable for gaussian eliminations."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"som"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"put polynomials in sum-of-monomials form"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"som_blowup"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sort_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort nested stores when the indices are known to be different"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sort_sums"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort the arguments of + application."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"split_concat_eq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"split equalities of the form (= (concat t1 t2) t3)"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"split_factors"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"apply simplifications such as (= (* p1 p2) 0) --",">"," (or (= p1 0) (= p2 0))."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.aggressive_length_testing"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"prioritize testing concrete length values over generating more options"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.aggressive_unroll_testing"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"prioritize testing concrete regex unroll counts over generating more options"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.aggressive_value_testing"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"prioritize testing concrete string constant values over generating more options"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.fast_length_tester_cache"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"cache length tester constants instead of regenerating them"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.fast_value_tester_cache"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"cache value tester constants instead of regenerating them"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.fixed_length_naive_cex"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only)"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.fixed_length_refinement"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use abstraction refinement in fixed-length equation solver (Z3str3 only)"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.overlap_priority"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true"),(0,l.kt)("td",{parentName:"tr",align:null},"-0.1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.regex_automata_difficulty_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"difficulty threshold for regex automata heuristics"),(0,l.kt)("td",{parentName:"tr",align:null},"1000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.regex_automata_failed_automaton_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of failed automaton construction attempts after which a full automaton is automatically built"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.regex_automata_failed_intersection_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of failed automaton intersection attempts after which intersection is always computed"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.regex_automata_intersection_difficulty_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"difficulty threshold for regex intersection heuristics"),(0,l.kt)("td",{parentName:"tr",align:null},"1000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.regex_automata_length_attempt_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of length/path constraint attempts before checking unsatisfiability of regex terms"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.string_constant_cache"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"cache all generated string constants generated from anywhere in theory_str"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"str.strong_arrangements"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"assert equivalences instead of implications when generating string arrangement axioms"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"string_solver"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver)"),(0,l.kt)("td",{parentName:"tr",align:null},"seq")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"subsumption"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate subsumed clauses"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"subsumption.limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"approx. maximum number of literals visited during subsumption (and subsumption resolution)"),(0,l.kt)("td",{parentName:"tr",align:null},"100000000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"theory_aware_branching"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Allow the context to use extra information from theory solvers regarding literal branching prioritization."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"theory_case_split"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"theory_solver"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"theory solvers."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"threads"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximal number of parallel threads."),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"threads.cube_frequency"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"frequency for using cubing"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"threads.max_conflicts"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximal number of conflicts between rounds of cubing for parallel SMT"),(0,l.kt)("td",{parentName:"tr",align:null},"400")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"variable_decay"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"multiplier (divided by 100) for the VSIDS activity increment"),(0,l.kt)("td",{parentName:"tr",align:null},"110")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"zero_accuracy"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"one of the most time-consuming operations in the real algebraic number module is determining the sign of a polynomial evaluated at a sample point with non-rational algebraic number values. Let k be the value of this option. If k is 0, Z3 uses precise computation. Otherwise, the result of a polynomial evaluation is considered to be 0 if Z3 can show it is inside the interval (-1/2^k, 1/2^k)"),(0,l.kt)("td",{parentName:"tr",align:null},"0")))),(0,l.kt)("h2",{id:"tactic-qfnra-nlsat"},"Tactic qfnra-nlsat"),(0,l.kt)("h3",{id:"short-description-51"},"Short Description"),(0,l.kt)("p",null,"Self-contained tactic that attempts to solve goal using a nonlinear arithmetic solver.\nIt first applies tactics, such as ",(0,l.kt)("inlineCode",{parentName:"p"},"purify-arith")," to convert the goal into a format\nwhere the ",(0,l.kt)("inlineCode",{parentName:"p"},"nlsat")," tactic applies."),(0,l.kt)("h3",{id:"example-40"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Real)\n(declare-const y Real)\n(assert (> (* x x) (* y x)))\n(assert (> x 0))\n(assert (< y 1))\n(apply qfnra-nlsat)",result:{output:"(goals\n(goal\n  :precision precise :depth 22)\n)\n",error:"",status:"z3-ran",hash:"025cdb74e188fd696dfba22351cf5db25150d589"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"parameters-34"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"algebraic_number_evaluator"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"simplify/evaluate expressions containing (algebraic) irrational numbers."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith_ineq_lhs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite inequalities so that right-hand-side is a constant."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith_lhs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"all monomials are moved to the left-hand-side, and the right-hand-side is just a constant."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bit2bool"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"try to convert bit-vector terms of size 1 into Boolean terms"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_distinct"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand a distinct predicate into a quadratic number of disequalities"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_distinct_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_eq_value"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"blast (some) Bit-vector equalities into bits"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_select_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eagerly replace all (select (store ..) ..) term by an if-then-else term"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_extract_prop"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"attempt to partially propagate extraction inwards"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_ineq_consistency_test_max"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"max size of conjunctions on which to perform consistency test based on inequalities on bitvectors."),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_ite2id"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite ite that can be simplified to identity"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_le2extract"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"disassemble bvule to extract"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_le_extra"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"additional bu_(u/s)le simplifications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_not_simpl"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"apply simplifications for bvnot"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_sort_ac"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort the arguments of all AC operators"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cache_all"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"cache all intermediate results."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"check_lemmas"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"check lemmas on the fly using an independent nlsat solver"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"common_patterns"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"minimize the number of auxiliary variables during CNF encoding by identifing commonly used patterns"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"complete"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"add constraints to make sure that any interpretation of a underspecified arithmetic operators is a function. The result will include additional uninterpreted functions/constants: /0, div0, mod0, 0^0, neg-root"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"context_solve"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"solve equalities under disjunctions."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"distributivity"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"minimize the number of auxiliary variables during CNF encoding by applying distributivity over unshared subformulas"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"distributivity_blowup"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum overhead for applying distributivity during CNF encoding"),(0,l.kt)("td",{parentName:"tr",align:null},"32")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_and"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"conjunctions are rewritten using negation and disjunctions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_inverses"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate inverse trigonometric functions (asin, acos, atan)."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate ite in favor of and/or"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_rem"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace (rem x y) with (ite (",">","= y 0) (mod x y) (- (mod x y)))."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_root_objects"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate root objects."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_sign_ext"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand sign-ext operator using concat and extract"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_to_real"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate to_real from arithmetic predicates that contain only integers."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"eliminate_mod"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate modulus from equations"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"eq2ineq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand equalities into two inequalities"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_nested_stores"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace nested stores by a lambda expression"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_power"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand (^ t k) into (* t ... t) if  1 ","<"," k ","<","= max_degree."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_select_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand select over ite expressions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_select_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"conservatively replace a (select (store ...) ...) term by an if-then-else term"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_store_eq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"reduce (store ...) = (store ...) with a common base into selects"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_tan"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace (tan x) with (/ (sin x) (cos x))."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"factor"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: true) factor polynomials."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"factor_max_prime"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step"),(0,l.kt)("td",{parentName:"tr",align:null},"31")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"factor_num_primes"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"factor_search_size"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space"),(0,l.kt)("td",{parentName:"tr",align:null},"5000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"flat"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"flat_and_or"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"create nary applications for and,or"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"gcd_rounding"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use gcd rounding on integer arithmetic atoms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hi_div0"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use the 'hardware interpretation' for division by zero (for bit-vector terms)"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hoist_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"hoist shared summands under ite expressions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hoist_mul"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"hoist multiplication over summation to minimize number of multiplications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ignore_labels"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"remove/ignore labels in the input formula, this option is ignored if proofs are enabled"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ignore_patterns_on_ground_qbody"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"ignores patterns on quantifiers that don't mention their bound variables."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"inline_vars"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"inline variables that can be isolated from equations (not supported in incremental mode)"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ite_chaing"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"minimize the number of auxiliary variables during CNF encoding by identifing if-then-else chains"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ite_extra"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"add redundant clauses (that improve unit propagation) when encoding if-then-else formulas"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ite_extra_rules"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extra ite simplifications, these additional simplifications may reduce size locally but increase globally"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ite_solver"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use if-then-else solver."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lazy"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"how lazy the solver is."),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_ctx"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"perform local (i.e., cheap) context simplifications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_ctx_limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"limit for applying local context simplifier"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"log_lemmas"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"display lemmas as self-contained SMT formulas"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_args"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: 128) maximum number of arguments (per application) that will be considered by the greedy (quadratic) heuristic."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_conflicts"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum number of conflicts."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_degree"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"max degree of algebraic numbers (and power operators) processed by simplifier."),(0,l.kt)("td",{parentName:"tr",align:null},"64")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum amount of memory in megabytes"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_prime"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_rounds"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum number of rounds."),(0,l.kt)("td",{parentName:"tr",align:null},"4")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_search_size"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_steps"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum number of steps"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"min_mag"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"Z3 represents algebraic numbers using a (square-free) polynomial p and an isolating interval (which contains one and only one root of p). This interval may be refined during the computations. This parameter specifies whether to cache the value of a refined interval or not. It says the minimal size of an interval for caching purposes is 1/2^16"),(0,l.kt)("td",{parentName:"tr",align:null},"16")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"minimize_conflicts"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"minimize conflicts"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mode"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full"),(0,l.kt)("td",{parentName:"tr",align:null},"skolem")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mul2concat"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace multiplication by a power of two into a concatenation"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mul_to_power"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"collpase (* t ... t) into (^ t k), it is ignored if expand_power is true."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"num_primes"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: 1) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pull_cheap_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"pull if-then-else terms when cheap."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_ite_arith"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"push if-then-else over arithmetic terms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_ite_bv"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"push if-then-else over bit-vector terms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_to_real"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"distribute to_real over * and +."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"randomize"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"randomize selection of a witness in nlsat."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"reorder"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"reorder variables."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"rewrite_patterns"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite patterns."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"seed"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"random seed."),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"shuffle_vars"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use a random variable order."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"simplify_conflicts"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"simplify conflicts using equalities before resolving them in nlsat solver."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sk_hack"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"hack for VCC"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"solve_eqs_max_occs"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum number of occurrences for considering a variable for gaussian eliminations."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"som"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"put polynomials in sum-of-monomials form"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"som_blowup"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sort_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort nested stores when the indices are known to be different"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sort_sums"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort the arguments of + application."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"split_concat_eq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"split equalities of the form (= (concat t1 t2) t3)"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"split_factors"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"apply simplifications such as (= (* p1 p2) 0) --",">"," (or (= p1 0) (= p2 0))."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"theory_solver"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"theory solvers."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"zero_accuracy"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"one of the most time-consuming operations in the real algebraic number module is determining the sign of a polynomial evaluated at a sample point with non-rational algebraic number values. Let k be the value of this option. If k is 0, Z3 uses precise computation. Otherwise, the result of a polynomial evaluation is considered to be 0 if Z3 can show it is inside the interval (-1/2^k, 1/2^k)"),(0,l.kt)("td",{parentName:"tr",align:null},"0")))),(0,l.kt)("h2",{id:"tactic-quasi-macro-finder"},"Tactic quasi-macro-finder"),(0,l.kt)("h3",{id:"short-description-52"},"Short Description"),(0,l.kt)("p",null,"dentifies and applies quasi-macros."),(0,l.kt)("h3",{id:"long-description-24"},"Long Description"),(0,l.kt)("p",null,"A quasi macro defines a function symbol that contains more arguments than the number of bound variables it defines.\nThe additional arguments are functions of the bound variables."),(0,l.kt)("h3",{id:"example-41"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-fun f (Int Int Int) Int)\n(declare-fun p (Int) Bool)\n(declare-const a Int)\n\n(assert (forall ((x Int) (y Int)) (= (f x y 1) (* 2 x y))))\n(assert (p (f 8 a (+ a 8))))\n(apply quasi-macros)",result:{output:"(goals\n(goal\n  (p (ite (= a (- 7)) (* 16 a) (f!else!0 8 a (+ 8 a))))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"a5d1093e1b1d81ed75992b125cd973e16c53e6d6"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"notes-24"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Supports proofs and cores")),(0,l.kt)("h2",{id:"tactic-recover-01"},"Tactic recover-01"),(0,l.kt)("h3",{id:"short-description-53"},"Short Description"),(0,l.kt)("p",null,"Recover 01 variables from propositional constants."),(0,l.kt)("h3",{id:"long-description-25"},"Long Description"),(0,l.kt)("p",null,"Search for clauses of the form"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"    p  or q or  x = 0\n    ~p or q or  x = k1\n    p  or ~q or x = k2\n    ~p or ~q or x = k1+k2\n")),(0,l.kt)("p",null,"Then, replaces "),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"x")," with ",(0,l.kt)("inlineCode",{parentName:"li"},"k1*y1 + k2*y2")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"p")," with ",(0,l.kt)("inlineCode",{parentName:"li"},"y1 = 1")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"q")," with ",(0,l.kt)("inlineCode",{parentName:"li"},"y2 = 1"))),(0,l.kt)("p",null,"where ",(0,l.kt)("inlineCode",{parentName:"p"},"y1")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"y2")," are fresh 01 variables."),(0,l.kt)("p",null,"The clauses are also removed."),(0,l.kt)("h3",{id:"example-42"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const p Bool)\n(declare-const q Bool)\n(declare-const x Int)\n(assert (or p q (= x 0)))\n(assert (or (not p) q (= x 3)))\n(assert (or p (not q) (= x 6)))\n(assert (or (not p) (not q) (= x 9)))\n(apply recover-01)",result:{output:"(goals\n(goal\n  (or (= k!0 1) (= k!1 1) (= (+ (* 3 k!0) (* 6 k!1)) 0))\n  (or (not (= k!0 1)) (= k!1 1) (= (+ (* 3 k!0) (* 6 k!1)) 3))\n  (or (= k!0 1) (not (= k!1 1)) (= (+ (* 3 k!0) (* 6 k!1)) 6))\n  (or (not (= k!0 1)) (not (= k!1 1)) (= (+ (* 3 k!0) (* 6 k!1)) 9))\n  (<= 0 k!0)\n  (<= k!0 1)\n  (<= 0 k!1)\n  (<= k!1 1)\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"1b9bd17db7b4d010a1b9060aa7d709f093fd11ee"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"notes-25"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"does not support proofs, does not support cores")),(0,l.kt)("h3",{id:"parameters-35"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"algebraic_number_evaluator"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"simplify/evaluate expressions containing (algebraic) irrational numbers."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith_ineq_lhs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite inequalities so that right-hand-side is a constant."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith_lhs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"all monomials are moved to the left-hand-side, and the right-hand-side is just a constant."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bit2bool"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"try to convert bit-vector terms of size 1 into Boolean terms"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_distinct"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand a distinct predicate into a quadratic number of disequalities"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_distinct_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_eq_value"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"blast (some) Bit-vector equalities into bits"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_select_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eagerly replace all (select (store ..) ..) term by an if-then-else term"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_extract_prop"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"attempt to partially propagate extraction inwards"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_ineq_consistency_test_max"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"max size of conjunctions on which to perform consistency test based on inequalities on bitvectors."),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_ite2id"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite ite that can be simplified to identity"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_le2extract"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"disassemble bvule to extract"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_le_extra"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"additional bu_(u/s)le simplifications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_not_simpl"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"apply simplifications for bvnot"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_sort_ac"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort the arguments of all AC operators"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cache_all"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"cache all intermediate results."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_and"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"conjunctions are rewritten using negation and disjunctions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate ite in favor of and/or"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_rem"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace (rem x y) with (ite (",">","= y 0) (mod x y) (- (mod x y)))."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_sign_ext"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand sign-ext operator using concat and extract"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_to_real"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate to_real from arithmetic predicates that contain only integers."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"eq2ineq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand equalities into two inequalities"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_nested_stores"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace nested stores by a lambda expression"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_power"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand (^ t k) into (* t ... t) if  1 ","<"," k ","<","= max_degree."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_select_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand select over ite expressions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_select_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"conservatively replace a (select (store ...) ...) term by an if-then-else term"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_store_eq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"reduce (store ...) = (store ...) with a common base into selects"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_tan"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace (tan x) with (/ (sin x) (cos x))."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"flat"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"flat_and_or"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"create nary applications for and,or"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"gcd_rounding"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use gcd rounding on integer arithmetic atoms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hi_div0"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use the 'hardware interpretation' for division by zero (for bit-vector terms)"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hoist_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"hoist shared summands under ite expressions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hoist_mul"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"hoist multiplication over summation to minimize number of multiplications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ignore_patterns_on_ground_qbody"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"ignores patterns on quantifiers that don't mention their bound variables."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ite_extra_rules"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extra ite simplifications, these additional simplifications may reduce size locally but increase globally"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_ctx"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"perform local (i.e., cheap) context simplifications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_ctx_limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"limit for applying local context simplifier"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_degree"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"max degree of algebraic numbers (and power operators) processed by simplifier."),(0,l.kt)("td",{parentName:"tr",align:null},"64")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum amount of memory in megabytes"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_steps"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum number of steps"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mul2concat"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace multiplication by a power of two into a concatenation"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mul_to_power"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"collpase (* t ... t) into (^ t k), it is ignored if expand_power is true."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pull_cheap_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"pull if-then-else terms when cheap."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_ite_arith"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"push if-then-else over arithmetic terms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_ite_bv"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"push if-then-else over bit-vector terms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_to_real"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"distribute to_real over * and +."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"recover_01_max_bits"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum number of bits to consider in a clause."),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"rewrite_patterns"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite patterns."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"som"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"put polynomials in sum-of-monomials form"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"som_blowup"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sort_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort nested stores when the indices are known to be different"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sort_sums"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort the arguments of + application."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"split_concat_eq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"split equalities of the form (= (concat t1 t2) t3)"),(0,l.kt)("td",{parentName:"tr",align:null},"false")))),(0,l.kt)("h2",{id:"tactic-reduce-args"},"Tactic reduce-args"),(0,l.kt)("h3",{id:"short-description-54"},"Short Description:"),(0,l.kt)("p",null,"Reduce the number of arguments of function applications, when for all occurrences of a function f the i-th is a value."),(0,l.kt)("h3",{id:"long-description-26"},"Long Description"),(0,l.kt)("p",null,"Example, suppose we have a function ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("mi",{parentName:"mrow"},"f")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"f")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,l.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"f")))))," with 2 arguments.\nThere are 1000 applications of this function, but the first argument is always ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("mi",{parentName:"mrow"},"a")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"a")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"a"))))),", ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("mi",{parentName:"mrow"},"b")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"b")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"b")))))," or ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("mi",{parentName:"mrow"},"c")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"c")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"c"))))),".\nThus, we replace the ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("mi",{parentName:"mrow"},"f"),(0,l.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,l.kt)("msub",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msub"},"t"),(0,l.kt)("mn",{parentName:"msub"},"1")),(0,l.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,l.kt)("msub",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msub"},"t"),(0,l.kt)("mn",{parentName:"msub"},"2")),(0,l.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"f(t_1, t_2)")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,l.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"f"),(0,l.kt)("span",{parentName:"span",className:"mopen"},"("),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},"1")))),(0,l.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,l.kt)("span",{parentName:"span"})))))),(0,l.kt)("span",{parentName:"span",className:"mpunct"},","),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},"2")))),(0,l.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,l.kt)("span",{parentName:"span"})))))),(0,l.kt)("span",{parentName:"span",className:"mclose"},")")))))," with "),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("span",{parentName:"li",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("msub",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msub"},"f"),(0,l.kt)("mi",{parentName:"msub"},"a")),(0,l.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,l.kt)("msub",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msub"},"t"),(0,l.kt)("mn",{parentName:"msub"},"2")),(0,l.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"f_a(t_2)")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"f"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.1514em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"-0.1076em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"a")))),(0,l.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,l.kt)("span",{parentName:"span"})))))),(0,l.kt)("span",{parentName:"span",className:"mopen"},"("),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},"2")))),(0,l.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,l.kt)("span",{parentName:"span"})))))),(0,l.kt)("span",{parentName:"span",className:"mclose"},")"))))),"   if   ",(0,l.kt)("span",{parentName:"li",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("msub",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msub"},"t"),(0,l.kt)("mn",{parentName:"msub"},"1")),(0,l.kt)("mo",{parentName:"mrow"},"="),(0,l.kt)("mi",{parentName:"mrow"},"a")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"t_1 = a")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.7651em",verticalAlign:"-0.15em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},"1")))),(0,l.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,l.kt)("span",{parentName:"span"})))))),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,l.kt)("span",{parentName:"span",className:"mrel"},"="),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"a")))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("span",{parentName:"li",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("msub",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msub"},"f"),(0,l.kt)("mi",{parentName:"msub"},"b")),(0,l.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,l.kt)("msub",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msub"},"t"),(0,l.kt)("mn",{parentName:"msub"},"2")),(0,l.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"f_b(t_2)")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"f"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3361em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"-0.1076em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"b")))),(0,l.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,l.kt)("span",{parentName:"span"})))))),(0,l.kt)("span",{parentName:"span",className:"mopen"},"("),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},"2")))),(0,l.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,l.kt)("span",{parentName:"span"})))))),(0,l.kt)("span",{parentName:"span",className:"mclose"},")"))))),"   if   ",(0,l.kt)("span",{parentName:"li",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("msub",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msub"},"t"),(0,l.kt)("mn",{parentName:"msub"},"2")),(0,l.kt)("mo",{parentName:"mrow"},"="),(0,l.kt)("mi",{parentName:"mrow"},"b")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"t_2 = b")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.7651em",verticalAlign:"-0.15em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},"2")))),(0,l.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,l.kt)("span",{parentName:"span"})))))),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,l.kt)("span",{parentName:"span",className:"mrel"},"="),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"b")))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("span",{parentName:"li",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("msub",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msub"},"f"),(0,l.kt)("mi",{parentName:"msub"},"c")),(0,l.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,l.kt)("msub",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msub"},"t"),(0,l.kt)("mn",{parentName:"msub"},"2")),(0,l.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"f_c(t_2)")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"f"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.1514em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"-0.1076em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"c")))),(0,l.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,l.kt)("span",{parentName:"span"})))))),(0,l.kt)("span",{parentName:"span",className:"mopen"},"("),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},"2")))),(0,l.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,l.kt)("span",{parentName:"span"})))))),(0,l.kt)("span",{parentName:"span",className:"mclose"},")"))))),"   if   ",(0,l.kt)("span",{parentName:"li",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("msub",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msub"},"t"),(0,l.kt)("mn",{parentName:"msub"},"2")),(0,l.kt)("mo",{parentName:"mrow"},"="),(0,l.kt)("mi",{parentName:"mrow"},"c")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"t_2 = c")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.7651em",verticalAlign:"-0.15em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},"2")))),(0,l.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,l.kt)("span",{parentName:"span"})))))),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,l.kt)("span",{parentName:"span",className:"mrel"},"="),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"c"))))))),(0,l.kt)("p",null,"Since ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("msub",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msub"},"f"),(0,l.kt)("mi",{parentName:"msub"},"a"))),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"f_a")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"f"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.1514em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"-0.1076em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"a")))),(0,l.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,l.kt)("span",{parentName:"span"})))))))))),", ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("msub",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msub"},"f"),(0,l.kt)("mi",{parentName:"msub"},"b"))),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"f_b")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"f"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3361em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"-0.1076em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"b")))),(0,l.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,l.kt)("span",{parentName:"span"})))))))))),", ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("msub",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msub"},"f"),(0,l.kt)("mi",{parentName:"msub"},"c"))),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"f_c")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"f"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.1514em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"-0.1076em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"c")))),(0,l.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,l.kt)("span",{parentName:"span"}))))))))))," are new symbols, satisfiability is preserved."),(0,l.kt)("p",null,"This transformation is very similar in spirit to the Ackermman's reduction.\nFor each function ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," and argument position of ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," it checks if all occurrences of ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," uses a value at position ",(0,l.kt)("inlineCode",{parentName:"p"},"i"),".\nThe values may be different, but all occurrences have to be values for the reduction to be applicable.\nIt creates a fresh function for each of the different values at position ",(0,l.kt)("inlineCode",{parentName:"p"},"i"),"."),(0,l.kt)("h3",{id:"example-43"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-fun f (Int Int) Bool)\n(declare-const x Int)\n(assert (f 1 2))\n(assert (f 1 3))\n(assert (f 2 4))\n(assert (f 2 5))\n(assert (f 1 6))\n(assert (f 1 7))\n(assert (f 1 x))\n(apply reduce-args)",result:{output:"(goals\n(goal\n  (f!0 2)\n  (f!0 3)\n  (f!1 4)\n  (f!1 5)\n  (f!0 6)\n  (f!0 7)\n  (f!0 x)\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"4d8943d91348ae03ddca84bef23f50f0e142ce2d"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"notes-26"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"supports unsat cores"),(0,l.kt)("li",{parentName:"ul"},"does not support proof terms")),(0,l.kt)("h2",{id:"tactic-reduce-bv-size"},"Tactic reduce-bv-size"),(0,l.kt)("h3",{id:"short-description-55"},"Short Description"),(0,l.kt)("p",null,"Rry to reduce bit-vector sizes using inequalities."),(0,l.kt)("h3",{id:"long-description-27"},"Long Description"),(0,l.kt)("p",null,"Reduce the number of bits used to encode constants, by using signed bounds.\nExample: suppose ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("mi",{parentName:"mrow"},"x")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"x")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"x")))))," is a bit-vector of size 8, and we have\nsigned bounds for ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("mi",{parentName:"mrow"},"x")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"x")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"x")))))," such that:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"        -2 <= x <= 2\n")),(0,l.kt)("p",null,"Then, ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("mi",{parentName:"mrow"},"x")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"x")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"x")))))," can be replaced by  ",(0,l.kt)("inlineCode",{parentName:"p"},"((sign-extend 5) k)"),"\nwhere ",(0,l.kt)("inlineCode",{parentName:"p"},"k")," is a fresh bit-vector constant of size 3."),(0,l.kt)("h3",{id:"example-44"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x (_ BitVec 32))\n(assert (bvsle (bvneg (_ bv2 32)) x))\n(assert (bvsle x (_ bv2 32)))\n(assert (= (bvmul x x) (_ bv9 32)))\n(apply (and-then simplify reduce-bv-size))",result:{output:"(goals\n(goal\n  (bvsle #xfffffffe ((_ sign_extend 29) k!0))\n  (bvsle ((_ sign_extend 29) k!0) #x00000002)\n  (= (bvmul ((_ sign_extend 29) k!0) ((_ sign_extend 29) k!0)) #x00000009)\n  :precision precise :depth 2)\n)\n",error:"",status:"z3-ran",hash:"635afac22d9573592c0712e7284baa084d244564"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"notes-27"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"does not support proofs, nor unsat cores")),(0,l.kt)("h2",{id:"tactic-sat"},"Tactic sat"),(0,l.kt)("h3",{id:"short-description-56"},"Short Description"),(0,l.kt)("p",null,"Try to solve goal using a SAT solver"),(0,l.kt)("h2",{id:"tactic-sat-preprocess"},"Tactic sat-preprocess"),(0,l.kt)("h3",{id:"short-description-57"},"Short Description"),(0,l.kt)("p",null,"Apply SAT solver preprocessing procedures (bounded resolution, Boolean constant propagation, 2-SAT, subsumption, subsumption resolution)."),(0,l.kt)("h3",{id:"example-45"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const a Bool)\n(declare-const b Bool)\n(declare-const c Bool)\n(declare-const d Bool)\n(declare-const e Bool)\n(declare-const f Bool)\n(declare-fun p (Bool) Bool)\n(assert (=> a b))\n(assert (=> b c))\n(assert a)\n(assert (not c))\n(apply sat-preprocess)",result:{output:"(goals\n(goal\n  false\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"1c01519c89b1c5f6cbeabaa6314d0677320d69f3"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"parameters-36"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"abce"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate blocked clauses using asymmetric literals"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"acce"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate covered clauses using asymmetric added literals"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"anf"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable ANF based simplification in-processing"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"anf.delay"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"delay ANF simplification by in-processing round"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"anf.exlin"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable extended linear simplification"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"asymm_branch"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"asymmetric branching"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"asymm_branch.all"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"asymmetric branching on all literals per clause"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"asymm_branch.delay"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of simplification rounds to wait until invoking asymmetric branch simplification"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"asymm_branch.limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"approx. maximum number of literals visited during asymmetric branching"),(0,l.kt)("td",{parentName:"tr",align:null},"100000000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"asymm_branch.rounds"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximal number of rounds to run asymmetric branch simplifications if progress is made"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"asymm_branch.sampled"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use sampling based asymmetric branching based on binary implication graph"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ate"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"asymmetric tautology elimination"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"backtrack.conflicts"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of conflicts before enabling chronological backtracking"),(0,l.kt)("td",{parentName:"tr",align:null},"4000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"backtrack.scopes"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of scopes to enable chronological backtracking"),(0,l.kt)("td",{parentName:"tr",align:null},"100")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bca"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"blocked clause addition - add blocked binary clauses"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bce"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate blocked clauses"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bce_at"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate blocked clauses only once at the given simplification round"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bce_delay"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"delay eliminate blocked clauses until simplification round"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"binspr"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable SPR inferences of binary propagation redundant clauses. This inprocessing step eliminates models"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blocked_clause_limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum number of literals visited during blocked clause elimination"),(0,l.kt)("td",{parentName:"tr",align:null},"100000000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"branching.anti_exploration"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"apply anti-exploration heuristic for branch selection"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"branching.heuristic"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"branching heuristic vsids, chb"),(0,l.kt)("td",{parentName:"tr",align:null},"vsids")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"burst_search"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of conflicts before first global simplification"),(0,l.kt)("td",{parentName:"tr",align:null},"100")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cardinality.encoding"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit"),(0,l.kt)("td",{parentName:"tr",align:null},"grouped")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cardinality.solver"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use cardinality solver"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cce"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate covered clauses"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"core.minimize"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"minimize computed core"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"core.minimize_partial"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"apply partial (cheap) core minimization"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cut"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable AIG based simplification in-processing"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cut.aig"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extract aigs (and ites) from cluases for cut simplification"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cut.delay"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"delay cut simplification by in-processing round"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cut.dont_cares"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"integrate dont cares with cuts"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cut.force"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"force redoing cut-enumeration until a fixed-point"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cut.lut"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extract luts from clauses for cut simplification"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cut.npn3"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extract 3 input functions from clauses for cut simplification"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cut.redundancies"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"integrate redundancy checking of cuts"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cut.xor"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extract xors from clauses for cut simplification"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ddfw.init_clause_weight"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"initial clause weight for DDFW local search"),(0,l.kt)("td",{parentName:"tr",align:null},"8")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ddfw.reinit_base"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"increment basis for geometric backoff scheme of re-initialization of weights"),(0,l.kt)("td",{parentName:"tr",align:null},"10000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ddfw.restart_base"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of flips used a starting point for hessitant restart backoff"),(0,l.kt)("td",{parentName:"tr",align:null},"100000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ddfw.threads"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of ddfw threads to run in parallel with sat solver"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ddfw.use_reward_pct"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"percentage to pick highest reward variable when it has reward 0"),(0,l.kt)("td",{parentName:"tr",align:null},"15")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ddfw_search"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use ddfw local search instead of CDCL"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"dimacs.core"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extract core from DIMACS benchmarks"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"drat.activity"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"dump variable activities"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"drat.binary"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use Binary DRAT output format"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"drat.check_sat"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"build up internal trace, check satisfying model"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"drat.check_unsat"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"build up internal proof and check"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"drat.disable"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"override anything that enables DRAT"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"drat.file"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"file to dump DRAT proofs"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"dyn_sub_res"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"dynamic subsumption resolution for minimizing learned clauses"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_vars"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable variable elimination using resolution during simplification"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_vars_bdd"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable variable elimination using BDD recompilation during simplification"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_vars_bdd_delay"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"delay elimination of variables using BDDs until after simplification round"),(0,l.kt)("td",{parentName:"tr",align:null},"3")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"enable_pre_simplify"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable pre simplifications before the bounded search"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"euf"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable euf solver (this feature is preliminary and not ready for general consumption)"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"force_cleanup"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"force cleanup to remove tautologies and simplify clauses"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"gc"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"garbage collection strategy: psm, glue, glue_psm, dyn_psm"),(0,l.kt)("td",{parentName:"tr",align:null},"glue_psm")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"gc.burst"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"perform eager garbage collection during initialization"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"gc.defrag"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"defragment clauses when garbage collecting"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"gc.increment"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"increment to the garbage collection threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"500")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"gc.initial"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"learned clauses garbage collection frequency"),(0,l.kt)("td",{parentName:"tr",align:null},"20000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"gc.k"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm)"),(0,l.kt)("td",{parentName:"tr",align:null},"7")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"gc.small_lbd"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"learned clauses with small LBD are never deleted (only used in dyn_psm)"),(0,l.kt)("td",{parentName:"tr",align:null},"3")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"inprocess.max"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximal number of inprocessing passes"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"inprocess.out"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"file to dump result of the first inprocessing step and exit"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ite_extra"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"learned"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: false) collect also learned clauses."),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_search"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use local search instead of CDCL"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_search_dbg_flips"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"write debug information for number of flips"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_search_mode"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"local search algorithm, either default wsat or qsat"),(0,l.kt)("td",{parentName:"tr",align:null},"wsat")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_search_threads"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of local search threads to find satisfiable solution"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead.cube.cutoff"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat"),(0,l.kt)("td",{parentName:"tr",align:null},"depth")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead.cube.depth"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth."),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead.cube.fraction"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat"),(0,l.kt)("td",{parentName:"tr",align:null},"0.4")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead.cube.freevars"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"cube free variable fraction. Used when lookahead.cube.cutoff is freevars"),(0,l.kt)("td",{parentName:"tr",align:null},"0.8")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead.cube.psat.clause_base"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"clause base for PSAT cutoff"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead.cube.psat.trigger"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat"),(0,l.kt)("td",{parentName:"tr",align:null},"5")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead.cube.psat.var_exp"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"free variable exponent for PSAT cutoff"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead.delta_fraction"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"number between 0 and 1, the smaller the more literals are selected for double lookahead"),(0,l.kt)("td",{parentName:"tr",align:null},"1.0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead.double"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"enable doubld lookahead"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead.global_autarky"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"prefer to branch on variables that occur in clauses that are reduced"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead.preselect"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use pre-selection of subset of variables for branching"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead.reward"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu"),(0,l.kt)("td",{parentName:"tr",align:null},"march_cu")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead.use_learned"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use learned clauses when selecting lookahead literal"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead_scores"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extract lookahead scores. A utility that can only be used from the DIMACS front-end"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead_simplify"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use lookahead solver during simplification"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lookahead_simplify.bca"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"add learned binary clauses as part of lookahead simplification"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_conflicts"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum number of conflicts"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum amount of memory in megabytes."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"minimize_lemmas"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"minimize learned clauses"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"override_incremental"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pb.lemma_format"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"generate either cardinality or pb lemmas"),(0,l.kt)("td",{parentName:"tr",align:null},"cardinality")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pb.min_arity"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"minimal arity to compile pb/cardinality constraints to CNF"),(0,l.kt)("td",{parentName:"tr",align:null},"9")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pb.resolve"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"resolution strategy for boolean algebra solver: cardinality, rounding"),(0,l.kt)("td",{parentName:"tr",align:null},"cardinality")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pb.solver"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver)"),(0,l.kt)("td",{parentName:"tr",align:null},"solver")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"phase"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"phase selection strategy: always_false, always_true, basic_caching, random, caching"),(0,l.kt)("td",{parentName:"tr",align:null},"caching")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"phase.sticky"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use sticky phase caching"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"prob_search"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use probsat local search instead of CDCL"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"probing"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"apply failed literal detection during simplification"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"probing_binary"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"probe binary clauses"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"probing_cache"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"add binary literals as lemmas"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"probing_cache_limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"cache binaries unless overall memory usage exceeds cache limit"),(0,l.kt)("td",{parentName:"tr",align:null},"1024")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"probing_limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"limit to the number of probe calls"),(0,l.kt)("td",{parentName:"tr",align:null},"5000000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"propagate.prefetch"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"prefetch watch lists for assigned literals"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"random_freq"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"frequency of random case splits"),(0,l.kt)("td",{parentName:"tr",align:null},"0.01")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"random_seed"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"random seed"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"reorder.activity_scale"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"scaling factor for activity update"),(0,l.kt)("td",{parentName:"tr",align:null},"100")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"reorder.base"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of conflicts per random reorder"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"reorder.itau"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"inverse temperature for softmax"),(0,l.kt)("td",{parentName:"tr",align:null},"4.0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"rephase.base"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of conflicts per rephase"),(0,l.kt)("td",{parentName:"tr",align:null},"1000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"resolution.cls_cutoff1"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination"),(0,l.kt)("td",{parentName:"tr",align:null},"100000000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"resolution.cls_cutoff2"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination"),(0,l.kt)("td",{parentName:"tr",align:null},"700000000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"resolution.limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"approx. maximum number of literals visited during variable elimination"),(0,l.kt)("td",{parentName:"tr",align:null},"500000000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"resolution.lit_cutoff_range1"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses"),(0,l.kt)("td",{parentName:"tr",align:null},"700")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"resolution.lit_cutoff_range2"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2"),(0,l.kt)("td",{parentName:"tr",align:null},"400")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"resolution.lit_cutoff_range3"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2"),(0,l.kt)("td",{parentName:"tr",align:null},"300")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"resolution.occ_cutoff"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"first cutoff (on number of positive/negative occurrences) for Boolean variable elimination"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"resolution.occ_cutoff_range1"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses"),(0,l.kt)("td",{parentName:"tr",align:null},"8")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"resolution.occ_cutoff_range2"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2"),(0,l.kt)("td",{parentName:"tr",align:null},"5")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"resolution.occ_cutoff_range3"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2"),(0,l.kt)("td",{parentName:"tr",align:null},"3")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"restart"),(0,l.kt)("td",{parentName:"tr",align:null},"symbol"),(0,l.kt)("td",{parentName:"tr",align:null},"restart strategy: static, luby, ema or geometric"),(0,l.kt)("td",{parentName:"tr",align:null},"ema")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"restart.emafastglue"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"ema alpha factor for fast moving average"),(0,l.kt)("td",{parentName:"tr",align:null},"0.03")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"restart.emaslowglue"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"ema alpha factor for slow moving average"),(0,l.kt)("td",{parentName:"tr",align:null},"1e-05")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"restart.factor"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"restart increment factor for geometric strategy"),(0,l.kt)("td",{parentName:"tr",align:null},"1.5")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"restart.fast"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use fast restart approach only removing less active literals."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"restart.initial"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"initial restart (number of conflicts)"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"restart.margin"),(0,l.kt)("td",{parentName:"tr",align:null},"double"),(0,l.kt)("td",{parentName:"tr",align:null},"margin between fast and slow restart factors. For ema"),(0,l.kt)("td",{parentName:"tr",align:null},"1.1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"restart.max"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximal number of restarts."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"retain_blocked_clauses"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"retain blocked clauses as lemmas"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"scc"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate Boolean variables by computing strongly connected components"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"scc.tr"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"apply transitive reduction, eliminate redundant binary clauses"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"search.sat.conflicts"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"period for solving for sat (in number of conflicts)"),(0,l.kt)("td",{parentName:"tr",align:null},"400")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"search.unsat.conflicts"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"period for solving for unsat (in number of conflicts)"),(0,l.kt)("td",{parentName:"tr",align:null},"400")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"simplify.delay"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"set initial delay of simplification by a conflict count"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"smt"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use the SAT solver based incremental SMT core"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"smt.proof.check"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"check SMT proof while it is created"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"smt.proof.check_rup"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"apply forward RUP proof checking"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"subsumption"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate subsumed clauses"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"subsumption.limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"approx. maximum number of literals visited during subsumption (and subsumption resolution)"),(0,l.kt)("td",{parentName:"tr",align:null},"100000000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"threads"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"number of parallel threads to use"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"variable_decay"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"multiplier (divided by 100) for the VSIDS activity increment"),(0,l.kt)("td",{parentName:"tr",align:null},"110")))),(0,l.kt)("h2",{id:"tactic-simplify"},"Tactic simplify"),(0,l.kt)("h3",{id:"short-description-58"},"Short Description:"),(0,l.kt)("p",null,"The tactic performs algebraic simplifcations on formulas"),(0,l.kt)("h3",{id:"long-description-28"},"Long Description"),(0,l.kt)("p",null,"The simplify tactic invokes z3's main rewriting engine.\nThe rewriting engine contains support for theory specific simplifications.\nThe set of simplifications invoked is open ended. Useful algebraic simplifications\nare added to the rewrite engine as they are discovered to be useful."),(0,l.kt)("p",null,"Note that the simplifier does not ensure that equivalent formulas are simplified to the same form.\nIn other words it does not guarantee canonicity. This contrasts with BDD packages where BDDs constructed\nfrom two equivalent formulas are guaranteed to be equal."),(0,l.kt)("h3",{id:"example-46"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"  (declare-const x Int)\n  (declare-const y Int)\n  (assert (> x (+ x y)))\n  (apply simplify)",result:{output:"(goals\n(goal\n  (not (<= 0 y))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"15a039d11438505d9334cb04e01fd3c96772bbfb"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("p",null,"The simplifier is also exposed as a stand-alone command.\nThere are several options to control its behavior."),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const x Int)\n(declare-const y Int)\n(declare-const z Int)\n(declare-const u Int)\n(declare-fun p (Int) Bool)\n(assert (p (* (+ x y) (+ z u))))\n(apply simplify)\n(apply (with simplify :som true))\n\n(simplify (* (+ x y) (+ z u)) :som false)\n(simplify (* (+ x y) (+ z u)) :som true)",result:{output:"(goals\n(goal\n  (p (* (+ x y) (+ z u)))\n  :precision precise :depth 1)\n)\n(goals\n(goal\n  (p (+ (* x z) (* y z) (* u x) (* u y)))\n  :precision precise :depth 1)\n)\n(* (+ x y) (+ z u))\n(+ (* x z) (* y z) (* u x) (* u y))\n",error:"",status:"z3-ran",hash:"7bdfee4c1aba2c8630e3eb0ffdde5880a9409a85"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"notes-28"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"supports unsat cores, proof terms")),(0,l.kt)("h3",{id:"parameters-37"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"algebraic_number_evaluator"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"simplify/evaluate expressions containing (algebraic) irrational numbers."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith_ineq_lhs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite inequalities so that right-hand-side is a constant."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith_lhs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"all monomials are moved to the left-hand-side, and the right-hand-side is just a constant."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bit2bool"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"try to convert bit-vector terms of size 1 into Boolean terms"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_distinct"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand a distinct predicate into a quadratic number of disequalities"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_distinct_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_eq_value"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"blast (some) Bit-vector equalities into bits"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_select_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eagerly replace all (select (store ..) ..) term by an if-then-else term"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_extract_prop"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"attempt to partially propagate extraction inwards"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_ineq_consistency_test_max"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"max size of conjunctions on which to perform consistency test based on inequalities on bitvectors."),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_ite2id"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite ite that can be simplified to identity"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_le2extract"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"disassemble bvule to extract"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_le_extra"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"additional bu_(u/s)le simplifications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_not_simpl"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"apply simplifications for bvnot"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_sort_ac"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort the arguments of all AC operators"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cache_all"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"cache all intermediate results."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_and"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"conjunctions are rewritten using negation and disjunctions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate ite in favor of and/or"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_rem"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace (rem x y) with (ite (",">","= y 0) (mod x y) (- (mod x y)))."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_sign_ext"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand sign-ext operator using concat and extract"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_to_real"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate to_real from arithmetic predicates that contain only integers."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"eq2ineq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand equalities into two inequalities"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_nested_stores"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace nested stores by a lambda expression"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_power"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand (^ t k) into (* t ... t) if  1 ","<"," k ","<","= max_degree."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_select_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand select over ite expressions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_select_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"conservatively replace a (select (store ...) ...) term by an if-then-else term"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_store_eq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"reduce (store ...) = (store ...) with a common base into selects"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_tan"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace (tan x) with (/ (sin x) (cos x))."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"flat"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"flat_and_or"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"create nary applications for and,or"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"gcd_rounding"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use gcd rounding on integer arithmetic atoms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hi_div0"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use the 'hardware interpretation' for division by zero (for bit-vector terms)"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hoist_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"hoist shared summands under ite expressions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hoist_mul"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"hoist multiplication over summation to minimize number of multiplications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ignore_patterns_on_ground_qbody"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"ignores patterns on quantifiers that don't mention their bound variables."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ite_extra_rules"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extra ite simplifications, these additional simplifications may reduce size locally but increase globally"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_ctx"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"perform local (i.e., cheap) context simplifications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_ctx_limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"limit for applying local context simplifier"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_degree"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"max degree of algebraic numbers (and power operators) processed by simplifier."),(0,l.kt)("td",{parentName:"tr",align:null},"64")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum amount of memory in megabytes"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_steps"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum number of steps"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mul2concat"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace multiplication by a power of two into a concatenation"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mul_to_power"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"collpase (* t ... t) into (^ t k), it is ignored if expand_power is true."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pull_cheap_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"pull if-then-else terms when cheap."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_ite_arith"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"push if-then-else over arithmetic terms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_ite_bv"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"push if-then-else over bit-vector terms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_to_real"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"distribute to_real over * and +."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"rewrite_patterns"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite patterns."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"som"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"put polynomials in sum-of-monomials form"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"som_blowup"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sort_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort nested stores when the indices are known to be different"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sort_sums"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort the arguments of + application."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"split_concat_eq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"split equalities of the form (= (concat t1 t2) t3)"),(0,l.kt)("td",{parentName:"tr",align:null},"false")))),(0,l.kt)("h2",{id:"tactic-solve-eqs"},"Tactic solve-eqs"),(0,l.kt)("h3",{id:"short-description-59"},"Short Description"),(0,l.kt)("p",null,"Solve for variables"),(0,l.kt)("h3",{id:"long-description-29"},"Long Description"),(0,l.kt)("p",null,"The tactic eliminates variables that can be brought into solved form.\nFor example, the assertion ",(0,l.kt)("inlineCode",{parentName:"p"},"x = f(y + z)")," can be solved for ",(0,l.kt)("inlineCode",{parentName:"p"},"x"),", replacing ",(0,l.kt)("inlineCode",{parentName:"p"},"x"),"\neverywhere by ",(0,l.kt)("inlineCode",{parentName:"p"},"f(x + y)"),". It depends on a set of theory specific equality solvers"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Basic equations"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"equations between uninterpreted constants and terms. "),(0,l.kt)("li",{parentName:"ul"},"equations written as ",(0,l.kt)("inlineCode",{parentName:"li"},"(if p (= x t) (= x s))")," are solved as ",(0,l.kt)("inlineCode",{parentName:"li"},"(= x (if p t s))"),"."),(0,l.kt)("li",{parentName:"ul"},"asserting ",(0,l.kt)("inlineCode",{parentName:"li"},"p")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"(not p)")," where ",(0,l.kt)("inlineCode",{parentName:"li"},"p")," is uninterpreted, causes ",(0,l.kt)("inlineCode",{parentName:"li"},"p")," to be replaced by ",(0,l.kt)("inlineCode",{parentName:"li"},"true")," (or ",(0,l.kt)("inlineCode",{parentName:"li"},"false"),")."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Arithmetic equations"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"It solves ",(0,l.kt)("inlineCode",{parentName:"li"},"x mod k = s")," to ",(0,l.kt)("inlineCode",{parentName:"li"},"x = k * m' + s"),", where m'` is a fresh constant. "),(0,l.kt)("li",{parentName:"ul"},"It finds variables with unit coefficients in integer linear equations."),(0,l.kt)("li",{parentName:"ul"},"It solves for ",(0,l.kt)("inlineCode",{parentName:"li"},"x * Y = Z")," under the side-condition ",(0,l.kt)("inlineCode",{parentName:"li"},"Y != 0")," as ",(0,l.kt)("inlineCode",{parentName:"li"},"x = Z/Y"),".")))),(0,l.kt)("p",null,"It also allows solving for uninterpreted constants that only appear in a single disjuction. For example,\n",(0,l.kt)("inlineCode",{parentName:"p"},"(or (= x (+ 5 y)) (= y (+ u z)))")," allows solving for ",(0,l.kt)("inlineCode",{parentName:"p"},"x"),". "),(0,l.kt)("h3",{id:"example-47"},"Example"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"(declare-const x Int)\n(declare-const y Int)\n(declare-const z Int)\n(declare-const u Int)\n(assert (or (and (= x (+ 5 y)) (> u z)) (= y (+ u z))))\n(apply solve-eqs)\n")),(0,l.kt)("p",null,"It produces the goal"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"(goal\n  (or (not (<= u z)) (= y (+ u z)))\n  :precision precise :depth 1)\n")),(0,l.kt)("p",null,"where ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," was solved as ",(0,l.kt)("inlineCode",{parentName:"p"},"(+ 5 y)"),"."),(0,l.kt)("h3",{id:"notes-29"},"Notes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"supports unsat cores"),(0,l.kt)("li",{parentName:"ul"},"does not support fine-grained proofs")),(0,l.kt)("h3",{id:"parameters-38"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"context_solve"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"solve equalities under disjunctions."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"eliminate_mod"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate modulus from equations"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ite_solver"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use if-then-else solver."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"solve_eqs_max_occs"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum number of occurrences for considering a variable for gaussian eliminations."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"theory_solver"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"theory solvers."),(0,l.kt)("td",{parentName:"tr",align:null},"true")))),(0,l.kt)("h2",{id:"tactic-split-clause"},"Tactic split-clause"),(0,l.kt)("h3",{id:"short-description-60"},"Short Description"),(0,l.kt)("p",null,"Tactic that creates a subgoal for each literal in a clause ",(0,l.kt)("inlineCode",{parentName:"p"},"(l_1 or ... or l_n)"),".\nThe tactic fails if the main goal does not contain any clause."),(0,l.kt)("h3",{id:"example-48"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const p Bool)\n(declare-const q Bool)\n(assert (or p q))\n(apply split-clause)",result:{output:"(goals\n(goal\n  p\n  :precision precise :depth 1)\n(goal\n  q\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"014dac6bbca6d99261666946114c4d2faadbc064"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"parameters-39"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"split_largest_clause"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: false) split the largest clause in the goal."),(0,l.kt)("td",{parentName:"tr",align:null})))),(0,l.kt)("h2",{id:"tactic-symmetry-reduce"},"Tactic symmetry-reduce"),(0,l.kt)("h3",{id:"short-description-61"},"Short Description"),(0,l.kt)("p",null,"Apply symmetry reduction"),(0,l.kt)("h3",{id:"long-description-30"},"Long Description"),(0,l.kt)("p",null,"The tactic applies symmetry reduction for uninterpreted functions and equalities.\nIt applies a straight-forward adaption of an algorithm proposed for veriT."),(0,l.kt)("h2",{id:"tactic-tseitin-cnf"},"Tactic tseitin-cnf"),(0,l.kt)("h3",{id:"short-description-62"},"Short Description"),(0,l.kt)("p",null,"Convert goal into CNF using tseitin-like encoding (note: quantifiers are ignored)."),(0,l.kt)("h3",{id:"long-description-31"},"Long Description"),(0,l.kt)("p",null,"Puts an assertion set in CNF.\nAuxiliary variables are used to avoid blowup."),(0,l.kt)("p",null,"Features:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Efficient encoding is used for commonly used patterns such as:\n",(0,l.kt)("inlineCode",{parentName:"p"},"(iff a (iff b c))"),"\n",(0,l.kt)("inlineCode",{parentName:"p"},"(or (not (or a b)) (not (or a c)) (not (or b c)))"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Efficient encoding is used for chains of if-then-elses ")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Distributivity is applied to non-shared nodes if the blowup is acceptable.\n")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The features above can be disabled/enabled using parameters.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},'The assertion-set is only modified if the resultant set of clauses is "acceptable".'))),(0,l.kt)("p",null,"Notes: "),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Term-if-then-else expressions are not handled by this strategy.\nThis kind of expression should be processed by other strategies.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},'Quantifiers are treated as "theory" atoms. They are viewed\nas propositional variables by this strategy.\n')),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The assertion set may contain free variables. ")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},'This strategy assumes the assertion_set_rewriter was used before invoking it.\nIn particular, it is more effective when "and" operators\nwere eliminated.'))),(0,l.kt)("h3",{id:"example-49"},"Example"),(0,l.kt)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const a Bool)\n(declare-const b Bool)\n(declare-const c Bool)\n\n(assert (= a (= b c)))\n(apply tseitin-cnf)",result:{output:"(goals\n(goal\n  (or a b c)\n  (or a (not b) (not c))\n  (or b (not a) (not c))\n  (or c (not a) (not b))\n  :precision precise :depth 1)\n)\n",error:"",status:"z3-ran",hash:"cfdebff0e3e1c5c6130879a17ea36c3d3f86d23b"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,l.kt)("h3",{id:"parameters-40"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"algebraic_number_evaluator"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"simplify/evaluate expressions containing (algebraic) irrational numbers."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith_ineq_lhs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite inequalities so that right-hand-side is a constant."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arith_lhs"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"all monomials are moved to the left-hand-side, and the right-hand-side is just a constant."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bit2bool"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"try to convert bit-vector terms of size 1 into Boolean terms"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_distinct"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand a distinct predicate into a quadratic number of disequalities"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_distinct_threshold"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_eq_value"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"blast (some) Bit-vector equalities into bits"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"blast_select_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eagerly replace all (select (store ..) ..) term by an if-then-else term"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_extract_prop"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"attempt to partially propagate extraction inwards"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_ineq_consistency_test_max"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"max size of conjunctions on which to perform consistency test based on inequalities on bitvectors."),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_ite2id"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite ite that can be simplified to identity"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_le2extract"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"disassemble bvule to extract"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_le_extra"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"additional bu_(u/s)le simplifications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_not_simpl"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"apply simplifications for bvnot"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bv_sort_ac"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort the arguments of all AC operators"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"cache_all"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"cache all intermediate results."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"common_patterns"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"minimize the number of auxiliary variables during CNF encoding by identifing commonly used patterns"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"distributivity"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"minimize the number of auxiliary variables during CNF encoding by applying distributivity over unshared subformulas"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"distributivity_blowup"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum overhead for applying distributivity during CNF encoding"),(0,l.kt)("td",{parentName:"tr",align:null},"32")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_and"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"conjunctions are rewritten using negation and disjunctions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate ite in favor of and/or"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_rem"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace (rem x y) with (ite (",">","= y 0) (mod x y) (- (mod x y)))."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_sign_ext"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand sign-ext operator using concat and extract"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"elim_to_real"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"eliminate to_real from arithmetic predicates that contain only integers."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"eq2ineq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand equalities into two inequalities"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_nested_stores"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace nested stores by a lambda expression"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_power"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand (^ t k) into (* t ... t) if  1 ","<"," k ","<","= max_degree."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_select_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"expand select over ite expressions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_select_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"conservatively replace a (select (store ...) ...) term by an if-then-else term"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_store_eq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"reduce (store ...) = (store ...) with a common base into selects"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"expand_tan"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace (tan x) with (/ (sin x) (cos x))."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"flat"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"flat_and_or"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"create nary applications for and,or"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"gcd_rounding"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use gcd rounding on integer arithmetic atoms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hi_div0"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"use the 'hardware interpretation' for division by zero (for bit-vector terms)"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hoist_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"hoist shared summands under ite expressions"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"hoist_mul"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"hoist multiplication over summation to minimize number of multiplications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ignore_patterns_on_ground_qbody"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"ignores patterns on quantifiers that don't mention their bound variables."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ite_chaing"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"minimize the number of auxiliary variables during CNF encoding by identifing if-then-else chains"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ite_extra"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"add redundant clauses (that improve unit propagation) when encoding if-then-else formulas"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ite_extra_rules"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"extra ite simplifications, these additional simplifications may reduce size locally but increase globally"),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_ctx"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"perform local (i.e., cheap) context simplifications"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"local_ctx_limit"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"limit for applying local context simplifier"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_degree"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"max degree of algebraic numbers (and power operators) processed by simplifier."),(0,l.kt)("td",{parentName:"tr",align:null},"64")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_memory"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"(default: infty) maximum amount of memory in megabytes."),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_steps"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum number of steps"),(0,l.kt)("td",{parentName:"tr",align:null},"4294967295")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mul2concat"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"replace multiplication by a power of two into a concatenation"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mul_to_power"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"collpase (* t ... t) into (^ t k), it is ignored if expand_power is true."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pull_cheap_ite"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"pull if-then-else terms when cheap."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_ite_arith"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"push if-then-else over arithmetic terms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_ite_bv"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"push if-then-else over bit-vector terms."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"push_to_real"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"distribute to_real over * and +."),(0,l.kt)("td",{parentName:"tr",align:null},"true")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"rewrite_patterns"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"rewrite patterns."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"som"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"put polynomials in sum-of-monomials form"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"som_blowup"),(0,l.kt)("td",{parentName:"tr",align:null},"unsigned int"),(0,l.kt)("td",{parentName:"tr",align:null},"maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form"),(0,l.kt)("td",{parentName:"tr",align:null},"10")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sort_store"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort nested stores when the indices are known to be different"),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sort_sums"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"sort the arguments of + application."),(0,l.kt)("td",{parentName:"tr",align:null},"false")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"split_concat_eq"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"split equalities of the form (= (concat t1 t2) t3)"),(0,l.kt)("td",{parentName:"tr",align:null},"false")))),(0,l.kt)("h2",{id:"tactic-unit-subsume-simplify"},"Tactic unit-subsume-simplify"),(0,l.kt)("h3",{id:"short-description-63"},"Short Description"),(0,l.kt)("p",null,"implify goal using subsumption based on unit propagation"),(0,l.kt)("h3",{id:"long-description-32"},"Long Description"),(0,l.kt)("p",null,"Background: PDR generates several clauses that subsume each-other.\nSimplify a goal assuming it is a conjunction of clauses.\nSubsumed clauses are simplified by using unit-propagation\nIt uses the default SMT solver."))}k.isMDXComponent=!0}}]);