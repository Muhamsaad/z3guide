"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[324],{3591:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>f,frontMatter:()=>s,metadata:()=>d,toc:()=>c});var t=i(3117),a=(i(7294),i(3905)),r=i(7689);const s={title:"Division"},o=void 0,d={unversionedId:"guide/Arithmetic/division",id:"guide/Arithmetic/division",title:"Division",description:"Z3 also has support for division, integer division, modulo and remainder operators. Internally, they are all mapped to multiplication.",source:"@site/docs/guide/05 - Arithmetic/03 - division.md",sourceDirName:"guide/05 - Arithmetic",slug:"/guide/Arithmetic/division",permalink:"/rise4fun/docs/guide/Arithmetic/division",draft:!1,editUrl:"https://github.com/microsoft/rise4fun/tree/main/website/docs/guide/05 - Arithmetic/03 - division.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Division"},sidebar:"tutorialSidebar",previous:{title:"Nonlinear Arithmetic",permalink:"/rise4fun/docs/guide/Arithmetic/nonlinear-arithmetic"},next:{title:"Bitvectors",permalink:"/rise4fun/docs/guide/Bitvectors"}},l={},c=[],u={toc:c};function f(e){let{components:n,...i}=e;return(0,a.kt)("wrapper",(0,t.Z)({},u,i,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Z3 also has support for division, integer division, modulo and remainder operators. Internally, they are all mapped to multiplication."),(0,a.kt)(r.Z,{input:{code:"(declare-const a Int)\n(declare-const r1 Int)\n(declare-const r2 Int)\n(declare-const r3 Int)\n(declare-const r4 Int)\n(declare-const r5 Int)\n(declare-const r6 Int)\n(assert (= a 10))\n(assert (= r1 (div a 4))) ; integer division\n(assert (= r2 (mod a 4))) ; mod\n(assert (= r3 (rem a 4))) ; remainder\n(assert (= r4 (div a (- 4)))) ; integer division\n(assert (= r5 (mod a (- 4)))) ; mod\n(assert (= r6 (rem a (- 4)))) ; remainder\n(declare-const b Real)\n(declare-const c Real)\n(assert (= b (/ c 3.0)))\n(assert (= c 20.0))\n(check-sat)\n(get-model)",result:{output:"sat\n(\n  (define-fun c () Real\n    20.0)\n  (define-fun b () Real\n    (/ 20.0 3.0))\n  (define-fun r6 () Int\n    (- 2))\n  (define-fun r5 () Int\n    2)\n  (define-fun r4 () Int\n    (- 2))\n  (define-fun r3 () Int\n    2)\n  (define-fun r2 () Int\n    2)\n  (define-fun r1 () Int\n    2)\n  (define-fun a () Int\n    10)\n)\n",error:"",status:"z3-ran",hash:"161ccb00caa62dab24d2167d1fe36f2874880d34"}},mdxType:"Z3CodeBlock"}),(0,a.kt)("p",null,"In Z3, division by zero is allowed, but the result is not specified. Division is not a partial function. Actually, in Z3 all functions are total, although the result may be underspecified in some cases like division by zero."),(0,a.kt)(r.Z,{input:{code:"(declare-const a Real)\n; The following formula is satisfiable since division by zero is not specified.\n(assert (= (/ a 0.0) 10.0)) \n(check-sat)\n(get-model)\n\n; Although division by zero is not specified, division is still a function.\n; So, (/ a 0.0) cannot evaluated to 10.0 and 2.0.\n(assert (= (/ a 0.0) 2.0)) \n(check-sat)",result:{output:"sat\n(\n  (define-fun a () Real\n    38.0)\n  (define-fun /0 ((x!0 Real) (x!1 Real)) Real\n    10.0)\n)\nunsat\n",error:"",status:"z3-ran",hash:"4801cddbe22392bb6d7b37156562f214af60f268"}},mdxType:"Z3CodeBlock"}),(0,a.kt)("p",null,"If you are not happy with this behavior, you may use ite (if-then-else) operator to guard every division, and assign whatever intepretation you like to the division by zero. This example uses define-fun constructor to create a new operator mydiv. This is essentially a macro, and Z3 will expand its definition for every application of mydiv."),(0,a.kt)(r.Z,{input:{code:"; defining my own division operator where x0.0 == 0.0 for every x.\n(define-fun mydiv ((x Real) (y Real)) Real\n  (if (not (= y 0.0))\n      (/ x y)\n      0.0))\n(declare-const a Real)\n(declare-const b Real)\n(assert (= (mydiv a b) 1.0))\n(assert (= b 0.0))\n(check-sat)",result:{output:"unsat\n",error:"",status:"z3-ran",hash:"ad5fe92ff8ad576a6fd92f037c82f651a515a120"}},mdxType:"Z3CodeBlock"}))}f.isMDXComponent=!0}}]);