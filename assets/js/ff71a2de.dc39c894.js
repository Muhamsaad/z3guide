"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6772],{2129:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var a=i(3117),n=(i(7294),i(3905));i(3234);const r={title:"Fixedpoints",sidebar_position:4},s=void 0,o={unversionedId:"Programming Z3/Using Z3 from Python/Fixedpoints",id:"Programming Z3/Using Z3 from Python/Fixedpoints",title:"Fixedpoints",description:"Fixedpoints",source:"@site/docs/07 - Programming Z3/01 - Using Z3 from Python/04 - Fixedpoints.md",sourceDirName:"07 - Programming Z3/01 - Using Z3 from Python",slug:"/Programming Z3/Using Z3 from Python/Fixedpoints",permalink:"/z3guide/docs/Programming Z3/Using Z3 from Python/Fixedpoints",draft:!1,editUrl:"https://github.com/microsoft/z3guide/tree/main/website/docs/07 - Programming Z3/01 - Using Z3 from Python/04 - Fixedpoints.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Fixedpoints",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Strategies",permalink:"/z3guide/docs/Programming Z3/Using Z3 from Python/Strategies"},next:{title:"Cores and Satisfying Subsets",permalink:"/z3guide/docs/Programming Z3/Using Z3 from Python/Cores and Satisfying Subsets"}},l={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Basic Datalog",id:"basic-datalog",level:2},{value:"Relations, rules and queries",id:"relations-rules-and-queries",level:3}],u={toc:d};function c(e){let{components:t,...i}=e;return(0,n.kt)("wrapper",(0,a.Z)({},u,i,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",null,"Fixedpoints"),(0,n.kt)("p",null,"This tutorial illustrates uses of Z3's fixedpoint engine.\nThe following papers"),(0,n.kt)("a",{href:"http://research.microsoft.com/en-us/people/nbjorner/z3fix.pdf"},"\u03bcZ - An Efficient Engine for Fixed-Points with Constraints."),"(CAV 2011) and",(0,n.kt)("a",{href:"http://research.microsoft.com/en-us/people/nbjorner/z3pdr.pdf"},"Generalized Property Directed Reachability")," (SAT 2012) describe some of the main features of the engine.",(0,n.kt)("h2",{id:"introduction"},"Introduction"),(0,n.kt)("p",null,"This tutorial covers some of the fixedpoint utilities available with Z3.\nThe main features are a basic Datalog engine, an engine with relational\nalgebra and an engine based on a generalization of the Property\nDirected Reachability algorithm."),(0,n.kt)("h2",{id:"basic-datalog"},"Basic Datalog"),(0,n.kt)("p",null,"The default fixed-point engine is a bottom-up Datalog engine.\nIt works with finite relations and uses finite table representations\nas hash tables as the default way to represent finite relations."),(0,n.kt)("h3",{id:"relations-rules-and-queries"},"Relations, rules and queries"),(0,n.kt)("p",null,"The first example illustrates how to declare relations, rules and\nhow to pose queries."),(0,n.kt)("pre",{pref:"fixedpoint.1"}),"The example illustrates some of the basic constructs. ``` fp = Fixedpoint() ``` creates a context for fixed-point computation. ``` fp.register_relation(a.decl(), b.decl(), c.decl()) ``` Register the relations ",(0,n.kt)("tt",null,"a, b, c")," as recursively defined. ``` fp.rule(a,b) ``` Create the rule that ",(0,n.kt)("tt",null,"a")," follows from ",(0,n.kt)("tt",null,"b"),". In general you can create a rule with multiple premises and a name using the format ``` fp.rule(_head_,[_body1,...,bodyN_],_name_) ``` The _name_ is optional. It is used for tracking the rule in derivation proofs. Continuing with the example, ",(0,n.kt)("tt",null,"a")," is false unless ",(0,n.kt)("tt",null,"b")," is established. ``` fp.query(a) ``` Asks if ",(0,n.kt)("tt",null,"a")," can be derived. The rules so far say that ",(0,n.kt)("tt",null,"a"),"follows if ",(0,n.kt)("tt",null,"b")," is established and that ",(0,n.kt)("tt",null,"b")," follows if ",(0,n.kt)("tt",null,"c"),"is established. But nothing establishes ",(0,n.kt)("tt",null,"c")," and ",(0,n.kt)("tt",null,"b")," is also not established, so ",(0,n.kt)("tt",null,"a")," cannot be derived. ``` fp.fact(c) ``` Add a fact (shorthand for ",(0,n.kt)("tt",null,"fp.rule(c,True)"),"). Now it is the case that ",(0,n.kt)("tt",null,"a")," can be derived. ### Explanations It is also possible to get an explanation for a derived query. For the finite Datalog engine, an explanation is a trace that provides information of how a fact was derived. The explanation is an expression whose function symbols are Horn rules and facts used in the derivation.",(0,n.kt)("pre",{pref:"fixedpoint.2"}),"### Relations with arguments Relations can take arguments. We illustrate relations with arguments using edges and paths in a graph.",(0,n.kt)("pre",{pref:"fixedpoint.3"}),"The example uses the declaration ``` fp.declare_var(a,b,c) ``` to instrument the fixed-point engine that ",(0,n.kt)("tt",null,"a, b, c"),"should be treated as variables when they appear in rules. Think of the convention as they way bound variables are passed to quantifiers in Z3Py. ### Procedure Calls McCarthy's 91 function illustrates a procedure that calls itself recursively twice. The Horn clauses below encode the recursive function: ``` mc(x) = if x > 100 then x - 10 else mc(mc(x+11)) ``` The general scheme for encoding recursive procedures is by creating a predicate for each procedure and adding an additional output variable to the predicate. Nested calls to procedures within a body can be encoded as a conjunction of relations.",(0,n.kt)("pre",{pref:"fixedpoint.8"}),"The first two queries are unsatisfiable. The PDR engine produces the same proof of unsatisfiability. The proof is an inductive invariant for each recursive predicate. The PDR engine introduces a special query predicate for the query. ### Bakery We can also prove invariants of reactive systems. It is convenient to encode reactive systems as guarded transition systems. It is perhaps for some not as convenient to directly encode guarded transitions as recursive Horn clauses. But it is fairly easy to write a translator from guarded transition systems to recursive Horn clauses. We illustrate a translator and Lamport's two process Bakery algorithm in the next example.",(0,n.kt)("pre",{pref:"fixedpoint.9"}),"The rather verbose (and in no way minimal) inductive invariants are produced as answers. ### Functional Programs We can also verify some properties of functional programs using Z3's generalized PDR. Let us here consider an example from",(0,n.kt)("a",{href:"http://www.kb.is.s.u-tokyo.ac.jp/~uhiro/"},"_Predicate Abstraction and CEGAR for Higher-Order Model Checking, Kobayashi et.al. PLDI 2011_"),". We encode functional programs by taking a suitable operational semantics and encoding an evaluator that is specialized to the program being verified (we don't encode a general purpose evaluator, you should partial evaluate it to help verification). We use algebraic data-types to encode the current closure that is being evaluated.",(0,n.kt)("pre",{pref:"fixedpoint.10"}))}c.isMDXComponent=!0}}]);