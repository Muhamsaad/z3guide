"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2760],{8649:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>u,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>d,toc:()=>c});var t=n(8168),a=(n(6540),n(5680)),s=n(2317),i=n.n(s);const r={title:"Propositional Logic",sidebar_position:3},l=void 0,d={unversionedId:"logic/propositional-logic",id:"logic/propositional-logic",title:"Propositional Logic",description:"The pre-defined sort Bool is the sort (type) of all Boolean propositional expressions. Z3 supports the usual Boolean operators and, or, xor, not, => (implication), ite (if-then-else). Bi-implications are represented using equality =. The following example shows how to prove that if p implies q and q implies r, then p implies r. We accomplish that by showing that the negation is unsatisfiable. The command define-fun is used to define a macro (aka alias). In this example, conjecture is an alias for the conjecture we want to prove.",source:"@site/docs-smtlib/01 - logic/03 - propositional-logic.md",sourceDirName:"01 - logic",slug:"/logic/propositional-logic",permalink:"/z3guide/docs/logic/propositional-logic",draft:!1,editUrl:"https://github.com/microsoft/z3guide/tree/main/website/docs-smtlib/01 - logic/03 - propositional-logic.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Propositional Logic",sidebar_position:3},sidebar:"smtlibSidebar",previous:{title:"Basic Commands",permalink:"/z3guide/docs/logic/basiccommands"},next:{title:"Uninterpreted Functions and Constants",permalink:"/z3guide/docs/logic/Uninterpreted-functions-and-constants"}},u={},c=[{value:"Satisfiability and Validity",id:"satisfiability-and-validity",level:3},{value:"Cardinality Constraints",id:"cardinality-constraints",level:2},{value:"Pseudo Boolean Constraints",id:"pseudo-boolean-constraints",level:2}],p={toc:c},f="wrapper";function m(e){let{components:o,...n}=e;return(0,a.yg)(f,(0,t.A)({},p,n,{components:o,mdxType:"MDXLayout"}),(0,a.yg)("p",null,"The pre-defined sort Bool is the sort (type) of all Boolean propositional expressions. Z3 supports the usual Boolean operators and, or, xor, not, => (implication), ite (if-then-else). Bi-implications are represented using equality =. The following example shows how to prove that if p implies q and q implies r, then p implies r. We accomplish that by showing that the negation is unsatisfiable. The command define-fun is used to define a macro (aka alias). In this example, conjecture is an alias for the conjecture we want to prove."),(0,a.yg)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const p Bool)\n(declare-const q Bool)\n(declare-const r Bool)\n(define-fun conjecture () Bool\n\t(=> (and (=> p q) (=> q r))\n\t\t(=> p r)))\n(assert (not conjecture))\n(check-sat)",result:{output:"unsat\n",error:"",status:"z3-ran",hash:"ec03e286cdf347c05fd11e1eed581ae01c7dad0f"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,a.yg)("h3",{id:"satisfiability-and-validity"},"Satisfiability and Validity"),(0,a.yg)("p",null,"A formula F is valid if F always evaluates to true for any assignment of appropriate values to its uninterpreted function and constant symbols. A formula F is satisfiable if there is some assignment of appropriate values to its uninterpreted function and constant symbols under which F evaluates to true. Validity is about finding a proof of a statement; satisfiability is about finding a solution to a set of constraints. Consider a formula F with some uninterpreted constants, say a and b. We can ask whether F is valid, that is whether it is always true for any combination of values for a and b. If F is always true, then not F is always false, and then not F will not have any satisfying assignment; that is, not F is unsatisfiable. That is, F is valid precisely when not F is not satisfiable (is unsatisfiable). Alternately, F is satisfiable if and only if not F is not valid (is invalid). Z3 finds satisfying assignments (or report that there are none). To determine whether a formula F is valid, we ask Z3 whether not F is satisfiable. Thus, to check the deMorgan's law is valid (i.e., to prove it), we show its negation to be unsatisfiable."),(0,a.yg)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const a Bool)\n(declare-const b Bool)\n(define-fun demorgan () Bool\n    (= (and a b) (not (or (not a) (not b)))))\n(assert (not demorgan))\n(check-sat)",result:{output:"unsat\n",error:"",status:"z3-ran",hash:"ed17ba03c402812ee5312ff7122518ecf9ff70de"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,a.yg)("h2",{id:"cardinality-constraints"},"Cardinality Constraints"),(0,a.yg)("p",null,"Logical disjunction ",(0,a.yg)("inlineCode",{parentName:"p"},"(or p q r)")," is true when at least one of the arguments ",(0,a.yg)("inlineCode",{parentName:"p"},"p"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"q"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"r")," is true. If you want to express that at least two of the arguments hold, then\nit is possible to encode using formulas such as ",(0,a.yg)("inlineCode",{parentName:"p"},"(or (and p q) (and p r) (and q r))"),". However, you can also express the constraint directly using a ",(0,a.yg)("em",{parentName:"p"},"cardinality")," constraint."),(0,a.yg)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const p Bool)\n(declare-const q Bool)\n(declare-const r Bool)\n(assert ((_ at-least 2) p q r))\n(check-sat)\n(get-model)",result:{output:"sat\n(\n  (define-fun p () Bool\n    true)\n  (define-fun q () Bool\n    true)\n  (define-fun r () Bool\n    false)\n)\n",error:"",status:"z3-ran",hash:"49c568fe8303f24dfb373138e45de645d195030f"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,a.yg)("p",null,"Dually, if at most one of the arguments should be true, you can express it as"),(0,a.yg)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const p Bool)\n(declare-const q Bool)\n(declare-const r Bool)\n(assert ((_ at-most 1) p q r))\n(check-sat)\n(get-model)",result:{output:"sat\n(\n  (define-fun p () Bool\n    false)\n  (define-fun q () Bool\n    false)\n  (define-fun r () Bool\n    true)\n)\n",error:"",status:"z3-ran",hash:"4e7579d0155d6f2ed7bed399f56151fb510a54cf"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,a.yg)("h2",{id:"pseudo-boolean-constraints"},"Pseudo Boolean Constraints"),(0,a.yg)("p",null,"A generalization of cardinality constraints are Pseudo-Boolean formulas where\nthe sum of Boolean variables with coefficients are bounded."),(0,a.yg)("p",null,"The sum ",(0,a.yg)("inlineCode",{parentName:"p"},"2p + q + 3r + 3s + 2t")," as at least ",(0,a.yg)("inlineCode",{parentName:"p"},"4"),"."),(0,a.yg)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const p Bool)\n(declare-const q Bool)\n(declare-const r Bool)\n(declare-const s Bool)\n(declare-const t Bool)\n(assert ((_ pbge 4 2 1 3 3 2) p q r s t))\n(check-sat)\n(get-model)",result:{output:"sat\n(\n  (define-fun p () Bool\n    true)\n  (define-fun q () Bool\n    false)\n  (define-fun s () Bool\n    false)\n  (define-fun t () Bool\n    false)\n  (define-fun r () Bool\n    true)\n)\n",error:"",status:"z3-ran",hash:"61e5ca811d77dae052e20f982415973e8f2de517"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,a.yg)("p",null,"The sum ",(0,a.yg)("inlineCode",{parentName:"p"},"2p + q + 3r + 3s + 2t")," as at most ",(0,a.yg)("inlineCode",{parentName:"p"},"5"),"."),(0,a.yg)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const p Bool)\n(declare-const q Bool)\n(declare-const r Bool)\n(declare-const s Bool)\n(declare-const t Bool)\n(assert ((_ pble 5 2 1 3 3 2) p q r s t))\n(check-sat)\n(get-model)",result:{output:"sat\n(\n  (define-fun p () Bool\n    false)\n  (define-fun q () Bool\n    false)\n  (define-fun r () Bool\n    false)\n  (define-fun s () Bool\n    true)\n  (define-fun t () Bool\n    true)\n)\n",error:"",status:"z3-ran",hash:"f3cecda1b8c0c6fb3955d69979da76393b86219c"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,a.yg)("p",null,"The sum ",(0,a.yg)("inlineCode",{parentName:"p"},"2p + q + 3r + 3s + 2t")," equals ",(0,a.yg)("inlineCode",{parentName:"p"},"5"),"."),(0,a.yg)(i(),{input:{lang:"z3",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const p Bool)\n(declare-const q Bool)\n(declare-const r Bool)\n(declare-const s Bool)\n(declare-const t Bool)\n(assert ((_ pbeq 5 2 1 3 3 2) p q r s t))\n(check-sat)\n(get-model)",result:{output:"sat\n(\n  (define-fun p () Bool\n    true)\n  (define-fun q () Bool\n    false)\n  (define-fun s () Bool\n    false)\n  (define-fun t () Bool\n    false)\n  (define-fun r () Bool\n    true)\n)\n",error:"",status:"z3-ran",hash:"d7a229325ffd453afb25d19dd75347a6cfe0b8de"},githubRepo:"Z3Prover/z3",editable:!1,readonly:!1,showLineNumbers:!0,langVersion:"4.12.1",tool:"z3-solver"},mdxType:"CustomCodeBlock"}),(0,a.yg)("p",null,"Cardinality, and Pseudo-Boolean, constraints can be\nmuch more succinct than CNF versions. Can you guess the secret\nformula? Hint: you can block clauses one by one for models\nof your failed guess, and see if you can find a pattern by counting\nthe number of variables that are true and false."),(0,a.yg)(i(),{input:{lang:"z3-duo",highlight:"clojure",statusCodes:{success:"z3-ran",timeout:"z3-timed-out",runError:"z3-failed",runtimeError:"z3-runtime-error"},code:"(declare-const a0 Bool)\n(declare-const a1 Bool)\n(declare-const a2 Bool)\n(declare-const a3 Bool)\n(declare-const a4 Bool)\n(declare-const a5 Bool)",result:{output:"(declare-const a0 Bool)\n(declare-const a1 Bool)\n(declare-const a2 Bool)\n(declare-const a3 Bool)\n(declare-const a4 Bool)\n(declare-const a5 Bool)\n(assert ((_ pbeq 3 1 1 1 1 1 1) a0 a1 a2 a3 a4 a5))"},githubRepo:"Z3Prover/z3",editable:!0,readonly:!1,showLineNumbers:!0},mdxType:"CustomCodeBlock"}))}m.isMDXComponent=!0}}]);