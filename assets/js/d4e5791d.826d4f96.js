"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7654],{9875:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>f,frontMatter:()=>s,metadata:()=>c,toc:()=>d});var a=n(3117),o=(n(7294),n(3905)),i=n(7634),r=n.n(i);const s={title:"Proof Logs",sidebar_position:6},l="Inference logs and proofs",c={unversionedId:"Proof Logs",id:"Proof Logs",title:"Proof Logs",description:"Z3 version 12.0 exposes new functionality to capture inferences.",source:"@site/docs-programming/06 - Proof Logs.md",sourceDirName:".",slug:"/Proof Logs",permalink:"/z3guide/programming/Proof Logs",draft:!1,editUrl:"https://github.com/microsoft/z3guide/tree/main/website/docs-programming/06 - Proof Logs.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{title:"Proof Logs",sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"API Reference",permalink:"/z3guide/programming/API Reference"}},p={},d=[{value:"Callbacks for clause inferences",id:"callbacks-for-clause-inferences",level:2},{value:"Print inferences created during search",id:"print-inferences-created-during-search",level:3},{value:"Capture just quantifier instantiations",id:"capture-just-quantifier-instantiations",level:3},{value:"Monitor clauses annotated with detailed justifications",id:"monitor-clauses-annotated-with-detailed-justifications",level:3},{value:"Monitor proof objects from the new core",id:"monitor-proof-objects-from-the-new-core",level:3},{value:"Saving and restoring inferences to and from files",id:"saving-and-restoring-inferences-to-and-from-files",level:2},{value:"Parse the logged inferences and replay them",id:"parse-the-logged-inferences-and-replay-them",level:3},{value:"Parse the logged inferences and check them",id:"parse-the-logged-inferences-and-check-them",level:3},{value:"Verify and self-validate on the fly",id:"verify-and-self-validate-on-the-fly",level:3},{value:"Verify and self-validate on the fly, but don&#39;t check rup",id:"verify-and-self-validate-on-the-fly-but-dont-check-rup",level:3},{value:"Command line uses",id:"command-line-uses",level:2}],u={toc:d};function f(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"inference-logs-and-proofs"},"Inference logs and proofs"),(0,o.kt)("p",null,"Z3 version 12.0 exposes new functionality to capture inferences.\nThere is an API extension to register a callback that is invoked\nwhenever the main SMT engine infers a clause. It is also possible to\nsave inferred clauses together with proof ",(0,o.kt)("em",{parentName:"p"},"hints")," that justify them.\nWe use the terminology ",(0,o.kt)("em",{parentName:"p"},"hint")," because the justifications are ",(0,o.kt)("em",{parentName:"p"},"big step"),"\ninferences. Some of the steps can be checked by lean self-contained\nproof checkers, other steps do not contain detailed guidance that would allow\nefficient validation. They require checking using general purpose SMT solving."),(0,o.kt)("p",null,"Proof terms have been supported from Z3 since 2008. They have been used in various settings,\nincluding for replaying tactics in Isabelle, for generation of interpolants, and for extracting\nseparating hyper-planes from linear programming proofs (Farkas lemma). A separate format\nis used to trace inference steps for proof mining. Proof logs allow to simplify some of the\ninfrastructure around proof reconstruction during search and for proof mining. The same logs\ncan be targetted for the different use cases. "),(0,o.kt)("h2",{id:"callbacks-for-clause-inferences"},"Callbacks for clause inferences"),(0,o.kt)("p",null,"The API exposes a function ",(0,o.kt)("inlineCode",{parentName:"p"},"Z3_solver_register_on_clause"),"\nthat is first exposed for C, C++, .Net and Python. We here illustrate using\nit from Python. The function lets a client register a callback function that is\ninvoked whenever the main SMT search engine makes an inference. The main inference\nsteps are (1) introducing an ",(0,o.kt)("em",{parentName:"p"},"assumption"),", that is, a clause that is entained from the\ninput formula (formally, the clause is satisfiability preserving when added to the input formula),\n(2) ",(0,o.kt)("em",{parentName:"p"},"deleting")," a clause from the set of active clauses,\n(3) ",(0,o.kt)("em",{parentName:"p"},"rup"),", inferring a clause through propositional reasoning, the clause can be justified using\n",(0,o.kt)("em",{parentName:"p"},"reverse unit propagation"),",\n(4) ",(0,o.kt)("em",{parentName:"p"},"smt"),", or other ",(0,o.kt)("em",{parentName:"p"},"theory")," rule, when a clause is added as a theory tautology."),(0,o.kt)("h3",{id:"print-inferences-created-during-search"},"Print inferences created during search"),(0,o.kt)(r(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:'def monitor_plain():\n    print("Monitor all inferred clauses")\n    s = Solver()\n    s.from_string(example1)\n    onc = OnClause(s, lambda pr, clause : print(pr, clause))\n    print(s.check())',result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,o.kt)("h3",{id:"capture-just-quantifier-instantiations"},"Capture just quantifier instantiations"),(0,o.kt)("p",null,"Applications that only need to monitor quantifier instantiations can filter the stream\nbased on the name of the proof hint."),(0,o.kt)(r(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:'def log_instance(pr, clause):\n    if pr.decl().name() == "inst":\n        q = pr.arg(0).arg(0) # first argument is Not(q)\n        for ch in pr.children():\n            if ch.decl().name() == "bind":\n                print("Binding")\n                print(q)\n                print(ch.children())\n                break\n\ndef monitor_instances():\n    print("Monitor just quantifier bindings")\n    s = Solver()\n    s.from_string(example1)\n    onc = OnClause(s, log_instance)\n    print(s.check())',result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,o.kt)("h3",{id:"monitor-clauses-annotated-with-detailed-justifications"},"Monitor clauses annotated with detailed justifications"),(0,o.kt)("p",null,"If you set proof mode to ",(0,o.kt)("em",{parentName:"p"},"true"),", then the inferred clauses\nare annotated by more detailed proof terms. The detailed proof terms\nuse a repetorire or low level inference rules."),(0,o.kt)(r(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"def monitor_with_proofs():\n    set_param(proof=True)\n    s = Solver()\n    s.from_string(example1)\n    onc = OnClause(s, lambda pr, clause : print(pr, clause))\n    print(s.check())",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,o.kt)("h3",{id:"monitor-proof-objects-from-the-new-core"},"Monitor proof objects from the new core"),(0,o.kt)("p",null,"An SMT core based on Z3's better tuned SAT solver is accessible if you set the option\n",(0,o.kt)("inlineCode",{parentName:"p"},"sat.euf=true")," and force it by setting ",(0,o.kt)("inlineCode",{parentName:"p"},"tactic.default_tactic=sat")," (or to ",(0,o.kt)("inlineCode",{parentName:"p"},"smt"),").\nProof logs have a different format from the ",(0,o.kt)("em",{parentName:"p"},"legacy")," core. Many inferences in this format\ncan be checked efficiently by built-in validators."),(0,o.kt)(r(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:'def monitor_new_core():\n    set_param("sat.euf", True)\n    set_param("tactic.default_tactic", "sat")\n    s = Solver()\n    s.from_string(example1)\n    onc = OnClause(s, lambda pr, clause : print(pr, clause))\n    print(s.check())',result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,o.kt)("h2",{id:"saving-and-restoring-inferences-to-and-from-files"},"Saving and restoring inferences to and from files"),(0,o.kt)("p",null,"Inference logging, replay, and checking is supported for\nthe core enabled by setting sat.euf = true.\nsetting the default tactic to 'sat' bypasses other tactics that could\nend up using different solvers.  "),(0,o.kt)(r(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:'    set_param("sat.euf", True)\n    set_param("tactic.default_tactic", "sat")\n\n    # Set a log file to trace inferences\n    set_param("sat.smt.proof", "proof_log.smt2")\n    s = Solver()\n    s.from_string(example1)\n    print(s.check())',result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,o.kt)("h3",{id:"parse-the-logged-inferences-and-replay-them"},"Parse the logged inferences and replay them"),(0,o.kt)("p",null,"You can also replay inferences when parsing a previously saved inferences."),(0,o.kt)(r(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:'    # Turn off proof checking. It is on by default when parsing proof logs.\n    set_param("solver.proof.check", False)      \n    s = Solver()\n    onc = OnClause(s, lambda pr, clause : print(pr, clause))\n    s.from_file("proof_log.smt2")',result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,o.kt)("p",null,"This feature can be used when proof logs are produced using a command-line process.\nLog reconstruction is decoupled form the shell process."),(0,o.kt)("h3",{id:"parse-the-logged-inferences-and-check-them"},"Parse the logged inferences and check them"),(0,o.kt)("p",null,"Now turn on proof checking. It invokes the self-validator.\nThe self-validator produces log lines of the form:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"   (proofs +tseitin 60 +alldiff 8 +euf 3 +rup 5 +inst 6 -quant 3 -inst 2)\n   (verified-smt\n     (inst (forall (vars (x T) (y T) (z T)) (or (subtype (:var 2) (:var 1)) ...\n")),(0,o.kt)("p",null,"The 'proofs' line summarizes inferences that were self-validated.\nThe pair +tseitin 60 indicates that 60 inferences were validated as Tseitin\nencodings.\nThe pair ",(0,o.kt)("inlineCode",{parentName:"p"},"-inst 2")," indicates that two quantifier instantiations were not self-validated\nThey were instead validated using a call to SMT solving. A log for an smt invocation\nis exemplified in the next line.\nNote that the pair ",(0,o.kt)("inlineCode",{parentName:"p"},"+inst 6")," indicates that 6 quantifier instantations were validated\nusing a syntactic (cheap) check. Some quantifier instantiations based on quantifier elimination\nare not simple substitutions and therefore a simple syntactic check does not suffice."),(0,o.kt)(r(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:'    s = Solver()\n    set_param("solver.proof.check", True)\n    s.from_file("proof_log.smt2")',result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,o.kt)("h3",{id:"verify-and-self-validate-on-the-fly"},"Verify and self-validate on the fly"),(0,o.kt)("p",null,"Proof checking (self-validation) is on by default. In case someone turned it off we force it to be on in the following."),(0,o.kt)(r(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:'    set_param("sat.smt.proof.check", True)\n    s = Solver()\n    s.from_string(example1)\n    print(s.check())',result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,o.kt)("h3",{id:"verify-and-self-validate-on-the-fly-but-dont-check-rup"},"Verify and self-validate on the fly, but don't check rup"),(0,o.kt)("p",null,"Self-validation checks all inferences. Inferences that use theory lemmas can be checked locally without considering other inferences. Inferences that are annotated by ",(0,o.kt)("inlineCode",{parentName:"p"},"rup")," (reverse unit propagation) are justified using global inferences (unit propagation). Checking ",(0,o.kt)("inlineCode",{parentName:"p"},"rup")," during search can be very expensive. You can turn off ",(0,o.kt)("inlineCode",{parentName:"p"},"rup")," checking\nselectively to speed up validation for theory lemmas."),(0,o.kt)(r(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:'    set_param("sat.smt.proof.check", True)\n    set_param("sat.smt.proof.check_rup", False)\n    s = Solver()\n    s.from_string(example1)\n    print(s.check())',result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,o.kt)("h2",{id:"command-line-uses"},"Command line uses"),(0,o.kt)("p",null,"From the command-line you can enable self-validation using the parameters"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"   z3 <file.smt2> sat.euf=true tactic.default_tactic=smt sat.smt.proof.check=true\n")),(0,o.kt)("p",null,"You can disable ",(0,o.kt)("inlineCode",{parentName:"p"},"rup")," checking "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"   z3 <file.smt2> sat.euf=true tactic.default_tactic=smt sat.smt.proof.check=true sat.smt.proof.check_rup=false\n")),(0,o.kt)("p",null,"To save proof logs, but not check them, use"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"z3 <file.smt2> sat.euf=true tactic.default_tactic=smt sat.smt.proof=<logfile.smt2>\n")),(0,o.kt)("p",null,"Inferences are printed in a mild extension of SMTLIB2. The extension has three new commands"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"(infer clause proof_hint)\n(del clause)\n(assume clause)\n")),(0,o.kt)("p",null,"where a proof hint is a proof term that is either a detailed set of inference steps or a\ngeneric inference that requires a proof checker that understands more than a set of simple\nsyntactic inferences."))}f.isMDXComponent=!0}}]);