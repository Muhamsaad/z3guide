<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-intro">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.21">
<title data-rh="true">Tutorial Intro | RiSE4Fun</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://microsoft.github.io//rise4fun/docs/intro"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Tutorial Intro | RiSE4Fun"><meta data-rh="true" name="description" content="Guide"><meta data-rh="true" property="og:description" content="Guide"><link data-rh="true" rel="icon" href="/rise4fun/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://microsoft.github.io//rise4fun/docs/intro"><link data-rh="true" rel="alternate" href="https://microsoft.github.io//rise4fun/docs/intro" hreflang="en"><link data-rh="true" rel="alternate" href="https://microsoft.github.io//rise4fun/docs/intro" hreflang="x-default"><link rel="stylesheet" href="/rise4fun/assets/css/styles.5e5e4ef2.css">
<link rel="preload" href="/rise4fun/assets/js/runtime~main.39fc671f.js" as="script">
<link rel="preload" href="/rise4fun/assets/js/main.a98a3a30.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/rise4fun/"><div class="navbar__logo"><img src="/rise4fun/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/rise4fun/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">RiSE4Fun</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/rise4fun/docs/intro">Tutorial</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/microsoft/rise4fun" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/rise4fun/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/rise4fun/docs/category/tutorial---basics">Tutorial - Basics</a><button aria-label="Toggle the collapsible sidebar category &#x27;Tutorial - Basics&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/rise4fun/docs/category/tutorial---extras">Tutorial - Extras</a><button aria-label="Toggle the collapsible sidebar category &#x27;Tutorial - Extras&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/rise4fun/docs/test">test</a></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_GujU"><div class="docItemContainer_Adtb"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/rise4fun/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Tutorial Intro</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_aoJ5"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>Tutorial Intro</h1><p>Guide</p><h1>Getting Started with Z3 A Guide</h1><p>Be sure to follow along with the examples by clicking the edit link in the corner. See what the tool says, try your own formulas, and experiment!</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="introduction">Introduction<a class="hash-link" href="#introduction" title="Direct link to heading">​</a></h2><p>Z3 is a state-of-the art theorem prover from Microsoft Research. It can be used to check the satisfiability of logical formulas over one or more theories. Z3 offers a compelling match for software analysis and verification tools, since several common software constructs map directly into supported theories.</p><p>The main objective of the tutorial is to introduce the reader on how to use Z3 effectively for logical modeling and solving. The tutorial provides some general background on logical modeling, but we have to defer a full introduction to first-order logic and decision procedures to text-books.</p><p>Z3 is a low level tool. It is best used as a component in the context of other tools that require solving logical formulas. Consequently, Z3 exposes a number of API facilities to make it convenient for tools to map into Z3, but there are no stand-alone editors or user-centric facilities for interacting with Z3. The language syntax used in the front ends favor simplicity in contrast to linguistic convenience.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="basic-commands">Basic Commands<a class="hash-link" href="#basic-commands" title="Direct link to heading">​</a></h2><p>The Z3 input format is an extension of the one defined by the <a href="/rise4fun/docs/httpwww.smtlib.org">SMT-LIB 2.0 standard</a>. A Z3 script is a sequence of commands. The help command displays a list of all available commands. The command echo displays a message. Internally, Z3 maintains a stack of user provided formulas and declarations. We say these are the assertions provided by the user. The command declare-const declares a constant of a given type (aka sort). The command declare-fun declares a function. In the following example, we declared a function that receives an integer and a boolean, and returns an integer.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(echo starting Z3...)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun f (Int Bool) Int)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The command assert adds a formula into the Z3 internal stack. We say the set of formulas in the Z3 stack is satisfiable if there is an interpretation (for the user declared constants and functions) that makes all asserted formulas true.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun f (Int Bool) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert ( a 10))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert ( (f a true) 100))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The first asserted formula states that the constant a must be greater than 10. The second one states that the function f applied to a and true must return a value less than 100. The command check-sat determines whether the current formulas on the Z3 stack are satisfiable or not. If the formulas are satisfiable, Z3 returns sat. If they are not satisfiable (i.e., they are unsatisfiable), Z3 returns unsat. Z3 may also return unknown when it can&#x27;t determine whether a formula is satisfiable or not.</p><p>When the command check-sat returns sat, the command get-model can be used to retrieve an interpretation that makes all formulas on the Z3 internal stack true.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun f (Int Bool) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert ( a 10))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert ( (f a true) 100))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The interpretation is provided using definitions. For example, the definition</p><blockquote><p> define-fun a () Int <!-- -->[val]<!-- -->)</p></blockquote><p>states that the value of a in the model is <!-- -->[val]<!-- -->. The definition</p><blockquote><p>(define-fun f ((x!1 Int) (x!2 Bool)) Int
...
)</p></blockquote><p>is very similar to a function definition used in programming languages. In this example, x1 and x2 are the arguments of the function interpretation created by Z3. For this simple example, the definition of f is based on ite&#x27;s (aka if-then-elses or conditional expressions). For example, the expression</p><blockquote><p>(ite (and (= x!1 11) (= x!2 false)) 21 0)</p></blockquote><p>evaluates (returns) 21 when x!1 is equal to 11, and x!2 is equal to false. Otherwise, it returns 0.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="using-scopes">Using Scopes<a class="hash-link" href="#using-scopes" title="Direct link to heading">​</a></h3><p>In some applications, we want to explore several similar problems that share several definitions and assertions. We can use the commands push and pop for doing that. Z3 maintains a global stack of declarations and assertions. The command push creates a new scope by saving the current stack size. The command pop removes any assertion or declaration performed between it and the matching push. The check-sat and get-assertions commands always operate on the content of the global stack.</p><p>In the following example, the command (assert p) signs an error because the pop command removed the declaration for p. If the last pop command is removed, then the error is corrected.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const x Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const y Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const z Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(push)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (+ x y) 10))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (+ x ( 2 y)) 20))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(pop) ; remove the two assertions</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(push) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (+ ( 3 x) y) 10))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (+ ( 2 x) ( 2 y)) 21))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const p Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(pop)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert p) ; error, since declaration of p was removed from the stack</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The push and pop commands can optionally receive a numeral argument as specifed by the SMT 2 language.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="configuration">Configuration<a class="hash-link" href="#configuration" title="Direct link to heading">​</a></h3><p>The command set-option is used to configure Z3. Z3 has several options to control its behavior. Some of these options (e.g., produce-proofs) can only be set before any declaration or assertion. We use the reset command to erase all assertions and declarations. After the reset command, all configuration options can be set.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(set-option print-success true) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(set-option produce-unsat-cores true) ; enable generation of unsat cores</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(set-option produce-models true) ; enable model generation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(set-option produce-proofs true) ; enable proof generation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const x Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(set-option produce-proofs false) ; error, cannot change this option after a declaration or assertion</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(echo before reset)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(reset)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(set-option produce-proofs false) ; ok</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The option print-success true is particularly useful when Z3 is being controlled by another application using pipes. In this mode, commands, that otherwise would not print any output, will print success.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="additional-commands">Additional commands<a class="hash-link" href="#additional-commands" title="Direct link to heading">​</a></h3><p>The command (display t) just applies the Z3 pretty printer to the given expression. The command (simplify t) displays a possibly simpler expression equivalent to t. This command accepts many different options, (help simplify) will display all available options.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a (Array Int Int))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const x Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const y Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(display (+ x 2 x 1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(simplify (+ x 2 x 1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(simplify ( (+ x y) (+ x y)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(simplify ( (+ x y) (+ x y)) som true) ; put all expressions in sum-of-monomials form.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(simplify (= x (+ y 2)) arith-lhs true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(simplify (= (store (store a 1 2) 4 3)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             (store (store a 4 3) 1 2)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(simplify (= (store (store a 1 2) 4 3)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             (store (store a 4 3) 1 2))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          sort-store true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(help simplify)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The define-sort command defines a new sort symbol that is an abbreviation for a sort expression. The new sort symbol can be parameterized, in which case the names of the parameters are specified in the command and the sort expression uses the sort parameters. The form of the command is this</p><blockquote><p>(define-sort <!-- -->[symbol]<!-- --> (<!-- -->[symbol]<!-- -->+) <!-- -->[sort]<!-- -->)</p></blockquote><p>The following example defines several abbreviations for sort expressions.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(define-sort Set (T) (Array T Bool))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(define-sort IList () (List Int))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(define-sort List-Set (T) (Array (List T) Bool))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(define-sort I () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const s1 (Set I))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const s2 (List-Set Int))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a I)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const l IList)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (select s1 a) true))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (select s2 l) false))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="propositional-logic">Propositional Logic<a class="hash-link" href="#propositional-logic" title="Direct link to heading">​</a></h2><p>The pre-defined sort Bool is the sort (type) of all Boolean propositional expressions. Z3 supports the usual Boolean operators and, or, xor, not, = (implication), ite (if-then-else). Bi-implications are represented using equatity =. The following example shows how to prove that if p implies q and q implies r, then p implies r. We accomplish that by showing that the negation is unsatisfiable. The command define-fun is used to define a macro (aka alias). In this example, conjecture is an alias for the conjecture we want to prove.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const p Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const q Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const r Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(define-fun conjecture () Bool</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (= (and (= p q) (= q r))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (= p r)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not conjecture))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="satisfiability-and-validity">Satisfiability and Validity<a class="hash-link" href="#satisfiability-and-validity" title="Direct link to heading">​</a></h3><p>A formula F is valid if F always evaluates to true for any assignment of appropriate values to its uninterpreted function and constant symbols. A formula F is satisfiable if there is some assignment of appropriate values to its uninterpreted function and constant symbols under which F evaluates to true. Validity is about finding a proof of a statement; satisfiability is about finding a solution to a set of constraints. Consider a formula F with some uninterpreted constants, say a and b. We can ask whether F is valid, that is whether it is always true for any combination of values for a and b. If F is always true, then not F is always false, and then not F will not have any satisfying assignment; that is, not F is unsatisfiable. That is, F is valid precisely when not F is not satisfiable (is unsatisfiable). Alternately, F is satisfiable if and only if not F is not valid (is invalid). Z3 finds satisfying assignments (or report that there are none). To determine whether a formula F is valid, we ask Z3 whether not F is satisfiable. Thus, to check the deMorgan&#x27;s law is valid (i.e., to prove it), we show its negation to be unsatisfiable.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const b Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(define-fun demorgan () Bool</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (= (and a b) (not (or (not a) (not b)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not demorgan))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="uninterpreted-functions-and-constants">Uninterpreted functions and constants<a class="hash-link" href="#uninterpreted-functions-and-constants" title="Direct link to heading">​</a></h2><p>The basic building blocks of SMT formulas are constants and functions. Constants are just functions that take no arguments. So everything is really just a function.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun f (Int) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun a () Int) ; a is a constant</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const b Int) ; syntax sugar for (declare-fun b () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert ( a 20))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert ( b a))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (f 10) 1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Unlike programming languages, where functions have side-effects, can throw exceptions, or never return, functions in classical first-order logic have no side-effects and are total. That is, they are defined on all input values. This includes functions, such as division.</p><p>Function and constant symbols in pure first-order logic are <em>uninterpreted</em> or <em>free</em>, which means that no a priori interpretation is attached. This is in contrast to functions belonging to the signature of theories, such as arithmetic where the function + has a fixed standard interpretation (it adds two numbers). Uninterpreted functions and constants are maximally flexible; they allow any interpretation that is consistent with the constraints over the function or constant.</p><p>To illustrate uninterpreted functions and constants let us introduce an (uninterpreted) sort A, and the constants x, y ranging over A. Finally let f be an uninterpreted function that takes one argument of sort A and results in a value of sort A. The example illustrates how one can force an interpretation where f applied twice to x results in x again, but f applied once to x is different form x.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(declare-sort A)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const x A)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const y A)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun f (A) A)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (f (f x)) x))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (f x) y))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (= x y)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The resulting model introduces abstract values for the elements in A, because the sort A is uninterpreted. The interpretation for f in the model toggles between the two values for x and y, which are different.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="arithmetic">Arithmetic<a class="hash-link" href="#arithmetic" title="Direct link to heading">​</a></h2><p>Z3 has builtin support for integer and real constants. This two types should not be confused with machine integers (32-bit or 64-bit) and floating point numbers. These two types (sorts) represent the mathematical integers and reals. The command declare-const is used to declare integer and real constants.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const b Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const c Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const d Real)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const e Real)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>After constants are declared, the user can assert.smt formulas containing these constants. The formulas contain arithmetic operators such as +, -, , and so on. The command check-sat will instruct Z3 to try to find an interpretation for the declared constants that makes all formulas true. The interpretation is basically assigning a number to each constant. If such interpretation exists, we say it is a model for the asserted formulas. The command get-model displays the model built by Z3.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const b Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const c Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const d Real)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const e Real)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert ( a (+ b 2)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= a (+ ( 2 c) 10)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (+ c b) 1000))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= d e))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Real constants should contain a decimal point. Unlike most programming languages, Z3 will not convert automatically integers into reals and vice-versa. The function to-real can be used to convert an integer expression into a real one.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const b Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const c Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const d Real)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const e Real)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert ( e (+ (to_real (+ a b)) 2.0)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= d (+ (to_real c) 0.5)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert ( a b))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="nonlinear-arithmetic">Nonlinear arithmetic<a class="hash-link" href="#nonlinear-arithmetic" title="Direct link to heading">​</a></h3><p>We say a formula is nonlinear if it contains expressions of the form ( t s) where t and s are not numbers. Nonlinear real arithmetic is very expensive, and Z3 is not complete for this kind of formula. The command check-sat may return unknown or loop. Nonlinear integer arithmetic is undecidable there is no procedure that is correct and terminates (for every input) with a sat or unsat answer. Yes, it is impossible to build such procedure. Note that, this does not prevent Z3 from returning an answer for many nonlinear problems. The real limit is that there will always be a nonlinear integer arithmetic formula that it will fail produce an answer.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert ( ( a a) 3))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(echo Z3 does not always find solutions to non-linear problems)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const b Real)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const c Real)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (+ ( b b b) ( b c)) 3.0))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(echo yet it can show unsatisfiabiltiy for some nontrivial nonlinear problems...)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const x Real)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const y Real)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const z Real)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= ( x x) (+ x 2.0)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= ( x y) x))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= ( (- y 1.0) z) 1.0))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(reset)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(echo When presented only non-linear constraints over reals, Z3 uses a specialized complete solver)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const b Real)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const c Real)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (+ ( b b b) ( b c)) 3.0))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="division">Division<a class="hash-link" href="#division" title="Direct link to heading">​</a></h3><p>Z3 also has support for division, integer division, modulo and remainder operators. Internally, they are all mapped to multiplication.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const r1 Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const r2 Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const r3 Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const r4 Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const r5 Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const r6 Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= a 10))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= r1 (div a 4))) ; integer division</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= r2 (mod a 4))) ; mod</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= r3 (rem a 4))) ; remainder</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= r4 (div a (- 4)))) ; integer division</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= r5 (mod a (- 4)))) ; mod</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= r6 (rem a (- 4)))) ; remainder</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const b Real)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const c Real)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= b ( c 3.0)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= c 20.0))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In Z3, division by zero is allowed, but the result is not specified. Division is not a partial function. Actually, in Z3 all functions are total, although the result may be underspecified in some cases like division by zero.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a Real)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">; The following formula is satisfiable since division by zero is not specified.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= ( a 0.0) 10.0)) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">; Although division by zero is not specified, division is still a function.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">; So, ( a 0.0) cannot evaluated to 10.0 and 2.0.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= ( a 0.0) 2.0)) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>If you are not happy with this behavior, you may use ite (if-then-else) operator to guard every division, and assign whatever intepretation you like to the division by zero. This example uses define-fun constructor to create a new operator mydiv. This is essentially a macro, and Z3 will expand its definition for every application of mydiv.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">; defining my own division operator where x0.0 == 0.0 for every x.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(define-fun mydiv ((x Real) (y Real)) Real</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  (if (not (= y 0.0))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ( x y)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      0.0))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a Real)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const b Real)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (mydiv a b) 1.0))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= b 0.0))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="bitvectors">Bitvectors<a class="hash-link" href="#bitvectors" title="Direct link to heading">​</a></h2><p>Modern CPUs and main-stream programming languages use arithmetic over fixed-size bit-vectors. The theory of bit-vectors allows modeling the precise semantics of unsigned and of signed two-complements arithmetic. There are a large number of supported functions and relations over bit-vectors. They are summarized on Z3&#x27;s documentation link here! of the binary APIs and they are summarized on the SMT-LIB link here!  web-site. We will not try to give a comprehensive overview here, but touch on some of the main features.</p><p>In contrast to programming languages, such as C, C++, C#, Java, there is no distinction between signed and unsigned bit-vectors as numbers. Instead, the theory of bit-vectors provides special signed versions of arithmetical operations where it makes a difference whether the bit-vector is treated as signed or unsigned.</p><p>Z3 supports Bitvectors of arbitrary size. (<em> BitVec n) is the sort of bitvectors whose length is n. Bitvector literals may be defined using binary, decimal and hexadecimal notation. In the binary and hexadecimal cases, the bitvector size is inferred from the number of characters. For example, the bitvector literal #b010 in binary format is a bitvector of size 3, and the bitvector literal #x0a0 in hexadecimal format is a bitvector of size 12. The size must be specified for bitvector literals in decimal format. For example, (</em> bv10 32) is a bitvector of size 32 that representes the numeral 10. By default, Z3 display bitvectors in hexadecimal format if the bitvector size is a multiple of 4, and in binary otherwise. The command (set-option pp.bv-literals false) can be used to force Z3 to display bitvector literals in decimal format.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(display #b0100)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(display (_ bv20 8))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(display (_ bv20 7))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(display #x0a) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(set-option pp.bv-literals false)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(display #b0100)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(display (_ bv20 8))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(display (_ bv20 7))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(display #x0a) </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="basic-bitvector-arithmetic">Basic Bitvector Arithmetic<a class="hash-link" href="#basic-bitvector-arithmetic" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(simplify (bvadd #x07 #x03)) ; addition</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(simplify (bvsub #x07 #x03)) ; subtraction</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(simplify (bvneg #x07)) ; unary minus</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(simplify (bvmul #x07 #x03)) ; multiplication</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(simplify (bvurem #x07 #x03)) ; unsigned remainder</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(simplify (bvsrem #x07 #x03)) ; signed remainder</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(simplify (bvsmod #x07 #x03)) ; signed modulo</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(simplify (bvshl #x07 #x03)) ; shift left</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(simplify (bvlshr #xf0 #x03)) ; unsigned (logical) shift right</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(simplify (bvashr #xf0 #x03)) ; signed (arithmetical) shift right</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="bitwise-operations">Bitwise Operations<a class="hash-link" href="#bitwise-operations" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(simplify (bvor #x6 #x3))   ; bitwise or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(simplify (bvand #x6 #x3))  ; bitwise and</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(simplify (bvnot #x6)) ; bitwise not</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(simplify (bvnand #x6 #x3)) ; bitwise nand</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(simplify (bvnor #x6 #x3)) ; bitwise nor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(simplify (bvxnor #x6 #x3)) ; bitwise xnor</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We can prove a bitwise version of deMorgan&#x27;s law</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const x (_ BitVec 64))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const y (_ BitVec 64))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (= (bvand (bvnot x) (bvnot y)) (bvnot (bvor x y)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Let us illustrate a simple property of bit-wise arithmetic. There is a fast way to check that fixed size numbers are powers of two. It turns out that a bit-vector x is a power of two or zero if and only if x &amp; (x - 1) is zero, where &amp; represents the bitwise and. We check this for four bits below.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(define-fun is-power-of-two ((x (_ BitVec 4))) Bool </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  (= #x0 (bvand x (bvsub x #x1))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a (_ BitVec 4))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> (not (= (is-power-of-two a) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         (or (= a #x0) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             (= a #x1) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             (= a #x2) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             (= a #x4) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             (= a #x8)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="predicates-over-bitvectors">Predicates over Bitvectors<a class="hash-link" href="#predicates-over-bitvectors" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(simplify (bvule #x0a #xf0))  ; unsigned less or equal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(simplify (bvult #x0a #xf0))  ; unsigned less than</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(simplify (bvuge #x0a #xf0))  ; unsigned greater or equal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(simplify (bvugt #x0a #xf0))  ; unsigned greater than</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(simplify (bvsle #x0a #xf0))  ; signed less or equal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(simplify (bvslt #x0a #xf0))  ; signed less than</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(simplify (bvsge #x0a #xf0))  ; signed greater or equal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(simplify (bvsgt #x0a #xf0))  ; signed greater than</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Signed comparison, such as bvsle, takes the sign bit of bitvectors into account for comparison, while unsigned comparison treats the bitvector as unsigned (treats the bitvector as a natural number).</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a (_ BitVec 4))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const b (_ BitVec 4))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (= (bvule a b) (bvsle a b))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="arrays">Arrays<a class="hash-link" href="#arrays" title="Direct link to heading">​</a></h2><p>As part of formulating a programme of a mathematical theory of computation McCarthy proposed a <em>basic</em> theory of arrays as characterized by the select-store axioms. The expression (select a i) returns the value stored at position i of the array a; and (store a i v) returns a new array identical to a, but on position i it contains the value v.</p><p>Z3 contains a decision procedure for the basic theory of arrays. By default, Z3 assumes that arrays are extensional over select. In other words, Z3 also enforces that if two arrays agree on all reads, then the arrays are equal.</p><p>It also contains various extensions for operations on arrays that remain decidable and amenable to efficient saturation procedures (here efficient means, with an NP-complete satisfiability complexity). We describe these extensions in the following using a collection of examples. Additional background on these extensions is available in the paper <a href="/rise4fun/docs/httpresearch.microsoft.comen-usumpeopleleonardofmcad09.pdf">Generalized and Efficient Array Decision Procedures</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="select-and-store">Select and Store<a class="hash-link" href="#select-and-store" title="Direct link to heading">​</a></h3><p>Let us first check a basic property of arrays. Suppose a1 is an array of integers, then the constraint (and (= (select a1 x) x) (= (store a1 x y) a1)) is satisfiable for an array that contains an index x that maps to x, and when x = y (because the first equality forced the range of x to be x). We can check this constraint.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const x Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const y Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const z Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a1 (Array Int Int))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a2 (Array Int Int))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a3 (Array Int Int))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (select a1 x) x))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (store a1 x y) a1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>On the other hand, the constraints become unsatisfiable when asserting (not (= x y)).</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const x Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const y Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const z Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a1 (Array Int Int))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a2 (Array Int Int))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a3 (Array Int Int))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (select a1 x) x))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (store a1 x y) a1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (= x y)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="constant-arrays">Constant Arrays<a class="hash-link" href="#constant-arrays" title="Direct link to heading">​</a></h3><p>The array that maps all indices to some fixed value can be specified in Z3 using the const construct. It takes one value from the range type of the array and creates an array. Z3 cannot infer what kind of array must be returned by the const construct by just inspecting the argument type. Thus, a qualified identifier (as const (Array T1 T2)) must be used. The following example defines a constant array containing only ones.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const all1 (Array Int Int))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const i Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= all1 ((as const (Array Int Int)) 1)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= a (select all1 i)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (= a 1)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="array-models">Array models<a class="hash-link" href="#array-models" title="Direct link to heading">​</a></h3><p>Models provide interpretations of the uninterpreted (aka free) constants and functions that appear in the satisfiable formula. An interpretation for arrays is very similar to the interpretation of a function. Z3 uses the construct (<em> as-array f) to give the interpretation for arrays. If the array a is equal to (</em> as-array f), then for every index i, (select a i) is equal to (f i). In the previous example, Z3 creates the auxiliary function k!0 to assign an interpretation to the array constant all1.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="mapping-functions-on-arrays">Mapping Functions on Arrays<a class="hash-link" href="#mapping-functions-on-arrays" title="Direct link to heading">​</a></h3><p>In the following, we will simulate basic Boolean algebra (set theory) using the array theory extensions in Z3. Z3 provides a parametrized map function on arrays. It allows applying arbitrary functions to the range of arrays. The following example illustrates how to use the map function.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(define-sort Set (T) (Array T Bool))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a (Set Int))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const b (Set Int))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const c (Set Int))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const x Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(push)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (= ((_ map and) a b) ((_ map not) ((_ map or) ((_ map not) b) ((_ map not) a))))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(pop)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(push) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (and (select ((_ map and) a b) x) (not (select a x))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(pop)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(push) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (and (select ((_ map or) a b) x) (not (select a x))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (and (not (select b x))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="bags-as-arrays">Bags as Arrays<a class="hash-link" href="#bags-as-arrays" title="Direct link to heading">​</a></h3><p>We can use the parametrized map function to encode finite sets and finite bags. Finite bags can be modeled similarly to sets. A bag is here an array that maps elements to their multiplicity. Main bag operations include union, obtained by adding multiplicity, intersection, by taking the minimum multiplicity, and a dual join operation that takes the maximum multiplicity. In the following example, we define the bag-union using map. Notice that we need to specify the full signature of + since it is an overloaded operator.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(define-sort A () (Array Int Int Int))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(define-fun bag-union ((x A) (y A)) A</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ((_ map (+ (Int Int) Int)) x y))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const s1 A)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const s2 A)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const s3 A)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= s3 (bag-union s1 s2)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (select s1 0 0) 5))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (select s2 0 0) 3))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (select s2 1 2) 4))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="datatypes">Datatypes<a class="hash-link" href="#datatypes" title="Direct link to heading">​</a></h2><p>Algebraic datatypes, known from programming languages such as ML, offer a convenient way for specifying common data structures. Records and tuples are special cases of algebraic datatypes, and so are scalars (enumeration types). But algebraic datatypes are more general. They can be used to specify finite lists, trees and other recursive structures.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="records">Records<a class="hash-link" href="#records" title="Direct link to heading">​</a></h3><p>A record is specified as a datatype with a single constructor and as many arguments as record elements. The number of arguments to a record are always the same. The type system does not allow to extend records and there is no record subtyping.</p><p>The following example illustrates that two records are equal only if all the arguments are equal. It introduces the parametric type Pair, with constructor mk-pair and two arguments that can be accessed using the selector functions first and second.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(declare-datatypes (T1 T2) ((Pair (mk-pair (first T1) (second T2)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const p1 (Pair Int Int))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const p2 (Pair Int Int))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= p1 p2))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert ( (second p1) 20))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (= (first p1) (first p2))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="scalars-enumeration-types">Scalars (enumeration types)<a class="hash-link" href="#scalars-enumeration-types" title="Direct link to heading">​</a></h3><p>A scalar sort is a finite domain sort. The elements of the finite domain are enumerated as distinct constants. For example, the sort S is a scalar type with three values A, B and C. It is possible for three constants of sort S to be distinct, but not for four constants.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(declare-datatypes () ((S A B C)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const x S)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const y S)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const z S)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const u S)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (distinct x y z))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (distinct x y z u))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="recursive-datatypes">Recursive datatypes<a class="hash-link" href="#recursive-datatypes" title="Direct link to heading">​</a></h3><p>A recursive datatype declaration includes itself directly (or indirectly) as a component. A standard example of a recursive data-type is the one of lists. A parametric list can be specified in Z3 as</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(declare-datatypes (T) ((Lst nil (cons (hd T) (tl Lst)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const l1 (Lst Int))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const l2 (Lst Bool))</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The List recursive datatype is builtin in Z3. The empty list is nil, and the constructor insert is used to build new lists. The accessors head and tail are defined as usual.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const l1 (List Int))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const l2 (List Int))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const l3 (List Int))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const x Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (= l1 nil)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (= l2 nil)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (head l1) (head l2)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (= l1 l2)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= l3 (insert x l2)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert ( x 100))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (tail l1) (tail l2)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In the example above, we also assert that l1 and l2 are not nil. This is because the interpretation of head and tail is underspecified on nil. So then head and tail would not be able to distinguish nil from (insert (head nil) (tail nil)).</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="mutually-recursive-datatypes">Mutually recursive datatypes<a class="hash-link" href="#mutually-recursive-datatypes" title="Direct link to heading">​</a></h3><p>You can also specify mutually recursive datatypes for Z3. We list one example below.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">; declare a mutually recursive parametric datatype</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-datatypes (T) ((Tree leaf (node (value T) (children TreeList)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        (TreeList nil (cons (car Tree) (cdr TreeList)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const t1 (Tree Int))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const t2 (Tree Bool))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">; we must use the &#x27;as&#x27; construct to distinguish the leaf (Tree Int) from leaf (Tree Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (= t1 (as leaf (Tree Int)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert ( (value t1) 20))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (is-leaf t2)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (value t2)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In the example above, we have a tree of Booleans and a tree of integers. The leaf constant must return a tree of a specific sort. To specify the result sort, we use the qualified identifier (as leaf (Tree Int)). Note that, we do not need to use a qualified identifer for value, since Z3 can infer the intended declaration using the sort of the argument.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="z3-will-not-prove-inductive-facts">Z3 will not prove inductive facts<a class="hash-link" href="#z3-will-not-prove-inductive-facts" title="Direct link to heading">​</a></h3><p>The ground decision procedures for recursive datatypes don&#x27;t lift to establishing inductive facts. Z3 does not contain methods for producing proofs by induction. This may change in the future. In particular, consider the following example where the function p is true on all natural numbers, which can be proved by induction over Nat. Z3 enters a matching loop as it attempts instantiating the universally quantified implication.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(set-option timeout 2000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-datatypes () ((Nat zero (succ (pred Nat)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p (Nat) Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (p zero))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x Nat)) (implies (p (pred x)) (p x))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (forall ((x Nat)) (p x))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-info all-statistics)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="quantifiers">Quantifiers<a class="hash-link" href="#quantifiers" title="Direct link to heading">​</a></h2><p>Z3 is a <em>decision procedure</em> for the combination of the previous quantifier-free theories. That is, it can answer whether a quantifier-free formula, modulo the theories referenced by the formula, is satisfiable or whether it is unsatisfiable. Z3 also accepts and can work with formulas that use quantifiers. It is no longer a decision procedure for such formulas in general (and for good reasons, as there can be no decision procedure for first-order logic).</p><p>Nevertheless, Z3 is often able to handle formulas involving quantifiers. It uses several approaches to handle quantifiers. The most prolific approach is using <em>pattern-based</em> quantifier instantiation. This approach allows instantiating quantified formulas with ground terms that appear in the current search context based on <em>pattern annotations</em> on quantifiers. Another approach is based on <em>saturation theorem proving</em> using a superposition calculus which is a modern method for applying resolution style rules with equalities. The pattern-based instantiation method is quite effective, even though it is inherently incomplete. The saturation based approach is complete for pure first-order formulas, but does not scale as nicely and is harder to predict.</p><p>Z3 also contains a model-based quantifier instantiation component that uses a model construction to find good terms to instantiate quantifiers with; and Z3 also handles many decidable fragments.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="modeling-with-quantifiers">Modeling with Quantifiers<a class="hash-link" href="#modeling-with-quantifiers" title="Direct link to heading">​</a></h3><p>Suppose we want to model an object oriented type system with single inheritance. We would need a predicate for sub-typing. Sub-typing should be a partial order, and respect single inheritance. For some built-in type constructors, such as for array-of, sub-typing should be monotone.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(declare-sort Type)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun subtype (Type Type) Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun array-of (Type) Type)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x Type)) (subtype x x)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x Type) (y Type) (z Type))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          (= (and (subtype x y) (subtype y z)) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              (subtype x z)))) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x Type) (y Type))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          (= (and (subtype x y) (subtype y x)) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              (= x y))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x Type) (y Type) (z Type))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          (= (and (subtype x y) (subtype x z)) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              (or (subtype y z) (subtype z y))))) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x Type) (y Type))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          (= (subtype x y) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              (subtype (array-of x) (array-of y)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const root-type Type)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x Type)) (subtype x root-type)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="patterns">Patterns<a class="hash-link" href="#patterns" title="Direct link to heading">​</a></h3><p>The Stanford Pascal verifier and the subsequent Simplify theorem prover pioneered the use of pattern-based quantifier instantiation. The basic idea behind pattern-based quantifier instantiation is in a sense straight-forward Annotate a quantified formula using a <em>pattern</em> that contains all the bound variables. So a pattern is an expression (that does not contain binding operations, such as quantifiers) that contains variables bound by a quantifier. Then instantiate the quantifier whenever a term that matches the pattern is created during search. This is a conceptually easy starting point, but there are several subtleties that are important.</p><p>In the following example, the first two options make sure that Model-based quantifier instantiation and saturation engines are disabled. We also annotate the quantified formula with the pattern (f (g x)). Since there is no ground instance of this pattern, the quantifier is not instantiated, and Z3 fails to show that the formula is unsatisfiable.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(set-option smt.auto-config false) ; disable automatic self configuration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(set-option smt.mbqi false) ; disable model-based quantifier instantiation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun f (Int) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun g (Int) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const b Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const c Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x Int))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                (! (= (f (g x)) x)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   pattern ((f (g x))))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (g a) c))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (g b) c))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (= a b)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>When the more permissive pattern (g x) is used. Z3 proves the formula to be unsatisfiable. More restrive patterns minimize the number of instantiations (and potentially improve performance), but they may also make Z3 less complete.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(set-option smt.auto-config false) ; disable automatic self configuration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(set-option smt.mbqi false) ; disable model-based quantifier instantiation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun f (Int) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun g (Int) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const b Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const c Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x Int))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                (! (= (f (g x)) x)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   pattern ((g x)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (g a) c))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (g b) c))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (= a b)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Some patterns may also create long instantiation chains. Consider the following assertion.</p><blockquote><p>(assert (forall (x Type) (y Type)
(! (= (subtype x y) (subtype (array-of x) (array-of y)))
pattern ((subtype x y))
))</p></blockquote><p>The axiom gets instantiated whenever there is some ground term of the form (subtype s t). The instantiation causes a fresh ground term (subtype (array-of s) (array-of t)), which enables a new instantiation. This undesirable situation is called a matching loop. Z3 uses many heuristics to break matching loops.</p><p>Before elaborating on the subtleties, we should address an important first question. What defines the terms that are created during search In the context of most SMT solvers, and of the Simplify theorem prover, terms exist as part of the input formula, they are of course also created by instantiating quantifiers, but terms are also implicitly created when equalities are asserted. The last point means that terms are considered up to congruence and pattern matching takes place modulo ground equalities. We call the matching problem E-matching. For example, if we have the following equalities</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(set-option smt.auto-config false) ; disable automatic self configuration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(set-option smt.mbqi false) ; disable model-based quantifier instantiation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun f (Int) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun g (Int) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const b Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const c Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x Int))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                (! (= (f (g x)) x)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   pattern ((f (g x))))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= a (g b)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= b c))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (= (f a) c)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The terms (f a) and (f (g b)) are equal modulo the equalities. The pattern (f (g x)) can be matched and x bound to b (and the equality (= (f (g b)) b) is deduced.</p><p>While E-matching is an NP-complete problem, the main sources of overhead in larger verification problems comes from matching thousands of patterns in the context of an evolving set of terms and equalities. Z3 integrates an efficient E-matching engine using term indexing techniques.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="multi-patterns">Multi-patterns<a class="hash-link" href="#multi-patterns" title="Direct link to heading">​</a></h3><p>In some cases, there is no pattern that contains all bound variables and does not contain interpreted symbols. In these cases, we use multi-patterns. In the following example, the quantified formula states that f is injective. This quantified formula is annotated with the multi-pattern (f x) (f y)</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(declare-sort A)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-sort B)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun f (A) B)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x A) (y A))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                (! (= (= (f x) (f y)) (= x y))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   pattern ((f x) (f y))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   )))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a1 A)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a2 A)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const b B)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (= a1 a2)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (f a1) b))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (f a2) b))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The quantified formula is instantiated for every pair of occurrences of f. A simple trick allows formulating injectivity of f in such a way that only a linear number of instantiations is required. The trick is to realize that f is injective if and only if it has a partial inverse.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(declare-sort A)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-sort B)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun f (A) B)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun f-inv (B) A)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x A))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                (! (= (f-inv (f x)) x)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   pattern ((f x))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   )))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a1 A)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a2 A)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const b B)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (= a1 a2)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (f a1) b))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (f a2) b))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="no-patterns">No patterns<a class="hash-link" href="#no-patterns" title="Direct link to heading">​</a></h3><p>The annotation no-pattern can be used to instrument Z3 not to use a certain sub-expression as a pattern. The pattern inference engine may otherwise choose arbitrary sub-expressions as patterns to direct quantifier instantiation.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="model-based-quantifier-instantiation">Model-based Quantifier Instantiation<a class="hash-link" href="#model-based-quantifier-instantiation" title="Direct link to heading">​</a></h3><p>The model-based quantifier instantiation (MBQI) is essentially a counter-example based refinement loop, where candidate models are built and checked. When the model checking step fails, it creates new quantifier instantiations. The models are returned as simple functional programs. In the following example, the model provides an interpretation for function f and constants a and b. One can easily check that the returned model does indeed satisfy the quantifier.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(set-option smt.mbqi true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun f (Int Int) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const b Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x Int)) (= (f x x) (+ x a))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert ( (f a b) a))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert ( a 0))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(echo evaluating (f (+ a 10) 20)...)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(eval (f (+ a 10) 20))</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The command eval evaluates an expression in the last model produced by Z3. It is essentially executing the function program produced by Z3.</p><p>MBQI is a decision procedure for several useful fragments. It may find models even for formulas that are not in any of these fragments. We describe some of these fragments.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="effectively-propositional">Effectively Propositional<a class="hash-link" href="#effectively-propositional" title="Direct link to heading">​</a></h4><p>The effectively propositional class of formulas (aka The Bernays-Schonfinkel class) is a decidable fragment of first-order logic formulas. It corresponds to formulas which, when written in prenex normal form contain only constants, universal quantifiers, and functions that return boolean values (aka predicates).</p><p>Problems arising from program verification often involve establishing facts of quantifier-free formulas, but the facts themselves use relations and functions that are conveniently axiomatized using a background theory that uses quantified formulas. One set of examples of this situation comprise of formulas involving partial-orders. The following example axiomatizes a subtype partial order relation that has the tree property. That is, if x and y are subtypes of z, then x is a subtype of y or y is a subtype of x. The option (set-option model.compact true) instructs Z3 to eliminate trivial redundancies from the generated model. In this example, Z3 also creates a finite interpretation for the uninterpreted sort T.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(set-option smt.mbqi true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(set-option model.compact true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; T is an uninterpreted sort</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-sort T) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun subtype (T T) Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; subtype is reflexive</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x T)) (subtype x x)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; subtype is antisymmetric</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x T) (y T)) (= (and (subtype x y)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                       (subtype y x))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                       (= x y))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; subtype is transitive</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x T) (y T) (z T)) (= (and (subtype x y)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                             (subtype y z))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                             (subtype x z))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; subtype has the tree-property</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x T) (y T) (z T)) (= (and (subtype x z)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                             (subtype y z))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                        (or (subtype x y)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                            (subtype y x)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; now we define a simple example using the axiomatization above.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const obj-type T)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const int-type T)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const real-type T)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const complex-type T)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const string-type T)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; we have an additional axiom every type is a subtype of obj-type</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x T)) (subtype x obj-type)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (subtype int-type real-type))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (subtype real-type complex-type))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (subtype string-type real-type)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const root-type T)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (subtype obj-type root-type))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(echo Is int-type a subtype of complex-type)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(eval (subtype int-type complex-type))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(echo Is int-type = obj-type)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(eval (= int-type obj-type))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(echo Is int-type a subtype of root-type)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(eval (subtype int-type root-type))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(echo Is root-type = obj-type)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(eval (= root-type obj-type))</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Note that it uses two auxiliary functions (subtype!25 and k!24) that were not part of your formula. They are auxiliary definitions created by Z3 during the model construction procedure. We can also ask questions by using the eval command. For example,</p><blockquote><p>(eval (subtype int-type complex-type))</p></blockquote><p>executes (evaluates) the given expression using the produced functional program (model).</p><p>Constraints over sets (Boolean Algebras) can be encoded into this fragment by treating sets as unary predicates and lifting equalities between sets as formula equivalence.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(set-option smt.mbqi true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(set-option model.compact true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; A, B, C and D are sets of Int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun A (Int) Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun B (Int) Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun C (Int) Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun D (Int) Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; A union B is a subset of C</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x Int)) (= (or (A x) (B x)) (C x))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; B minus A is not empty</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; That is, there exists an integer e that is B but not in A</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const e Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (and (B e) (not (A e))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; D is equal to C</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x Int)) (iff (D x) (C x))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; 0, 1 and 2 are in B</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (B 0))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (B 1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (B 2))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(echo Is e an element of D)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(eval (D e))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(echo Now proving that A is a strict subset of D)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; This is true if the negation is unsatisfiable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(push)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (and </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              ;; A is a subset of D</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              (forall ((x Int)) (= (A x) (D x)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              ;; but, D has an element that is not in A.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              (exists ((x Int)) (and (D x) (not (A x)))))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(pop)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="stratified-sorts-fragment">Stratified Sorts Fragment<a class="hash-link" href="#stratified-sorts-fragment" title="Direct link to heading">​</a></h4><p>The statified sorts fragment is another decidable fragment of many sorted first-order logic formulas. It corresponds to formulas which, when written in prenex normal form, there is a function level from sorts to naturals, and for every function</p><blockquote><p>declare-fun f (S_1 ... S_n) R)</p><p>level(R)  level(S_i).</p></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="array-property-fragment">Array Property Fragment<a class="hash-link" href="#array-property-fragment" title="Direct link to heading">​</a></h4><p>The array property fragment can encode properties about unidimensional, and is strong enough to say an array is sorted. More information about this fragment can be found in the paper <a href="/rise4fun/docs/httpacademic.research.microsoft.comPaper1843442.aspx">What&#x27;s Decidable About Arrays</a>.</p><p>(set-option smt.mbqi true)
(set-option model.compact true)</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">;; A0, A1, A2, A3, A4 are arrays from Integers to Integers.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun A0 (Int) Int) (declare-fun A1 (Int) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun A2 (Int) Int) (declare-fun A3 (Int) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun A4 (Int) Int) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const n Int) (declare-const l Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const k Int) (declare-const x Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const y Int) (declare-const w Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const z Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; A1 = A0[k - w]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (A1 k) w))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x Int)) (or (= x k) (= (A1 x) (A0 x)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; A2 = A1[l - x] = A0[k - w][l - x]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (A2 l) x))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x Int)) (or (= x l) (= (A2 x) (A1 x)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; A3 = A0[k - y]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (A3 k) y))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x Int)) (or (= x k) (= (A3 x) (A0 x)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; A4 = A3[l - z] = A0[k - y][l - z] </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (A3 l) z))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x Int)) (or (= x l) (= (A4 x) (A3 x)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (and ( w x) ( x y) ( y z)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (and ( 0 k) ( k l) ( l n)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert ( (- l k) 1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; A2 is sorted in the interval [0,n-1]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((i Int) (j Int))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                (= (and (= 0 i) (= i j) (= j (- n 1)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    (= (A2 i) (A2 j)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; A4 is sorted in the interval [0,n-1]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((i Int) (j Int))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                (= (and (= 0 i) (= i j) (= j (- n 1)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    (= (A4 i) (A4 j)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="list-fragment">List Fragment<a class="hash-link" href="#list-fragment" title="Direct link to heading">​</a></h4><p>The list fragment can encode properties about data-structures such as lists. For each quantified axiom q in this fragment, there is an easy way to satisfy q. More information about this fragment can be found in the paper <a href="/rise4fun/docs/httpwww.cs.berkeley.edu~neculaPapersverifier-cav05.pdf">Data Structure Specifications via Local Equality Axioms</a>.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(set-option smt.mbqi true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; Ptr is the pointer sort.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-sort Ptr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; (next p) represents p.next</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; The pointer reached by following the field next of p.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun next  (Ptr) Ptr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun prev  (Ptr) Ptr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun state (Ptr) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun prio  (Ptr) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const null Ptr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const RUN  Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const SLP  Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (distinct RUN SLP))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; Asserting data-structure invariants in the current state.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; p != null &amp;&amp; p.next != null = p.next.prev = p</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((p Ptr))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                (= (and (not (= p null))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         (not (= (next p) null)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    (= (prev (next p)) p))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; p != null &amp;&amp; p.prev != null = p.prev.next = p</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((p Ptr))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                (= (and (not (= p null))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         (not (= (prev p) null)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    (= (next (prev p)) p))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;;  p != null &amp;&amp; p.prev != null = p.state = p.next.state</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((p Ptr))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                (= (and (not (= p null))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         (not (= (next p) null)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    (= (state p) (state (next p))))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;;  p != null &amp;&amp; p.prev != null &amp;&amp; p.state = RUN = p.prio = p.next.prio</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((p Ptr))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                (= (and (not (= p null))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         (not (= (next p) null))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         (= (state p) RUN))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    (= (prio p) (prio (next p))))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; Verifying Verification Conditions (VCs) for remove procdure</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const x Ptr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; new-state, new-next, new-prev and new-prio represent the state </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; of the system after executing the remove procedure.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun new-state (Ptr) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun new-next  (Ptr) Ptr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun new-prev  (Ptr) Ptr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun new-prio  (Ptr) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; pre-conditions</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (= x null)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (= (prev x) null)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (state x) RUN))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; updates</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; --- new-prev = prev</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((p Ptr)) (= (new-prev p) (prev p))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; --- new-prio = prio</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((p Ptr)) (= (new-prio p) (prio p))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; --- new-state = state[x - SLP]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (new-state x) SLP))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((p Ptr)) (or (= p x) (= (new-state p) (state p)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; ----</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; --- new-next  = next[(prev x) - (next x); x - null]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (new-next x) null))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (new-next (prev x)) (next x)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((p Ptr)) (or (= p x) (= p (prev x)) (= (new-next p) (next p)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; ---</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; Proving the data-structure invariants in the new state.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(push)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (forall ((p Ptr))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     (= (and (not (= p null))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              (not (= (new-next p) null)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         (= (new-prev (new-next p)) p)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(pop)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(echo Why it is not valid)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(echo Trying again using a fresh constant bad-ptr as an witness for the failure...)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(push)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const bad-ptr Ptr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (= (and (not (= bad-ptr null))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      (not (= (new-next bad-ptr) null)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 (= (new-prev (new-next bad-ptr)) bad-ptr))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(echo null is)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(eval null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(echo bad-ptr is)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(eval bad-ptr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(echo In the new state, bad-ptr.next is)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(eval (new-next bad-ptr))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(echo In the new state, bad-ptr.next.prev is)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(eval (new-prev (new-next bad-ptr)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(pop)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="essentially-almost-uninterpreted-fragment">Essentially (Almost) Uninterpreted Fragment<a class="hash-link" href="#essentially-almost-uninterpreted-fragment" title="Direct link to heading">​</a></h4><p>The essentiallyalmost uninterpreted fragment subsumes the previous fragments, and uses a more relaxed notion of stratification. More information about this fragment can be found in the paper <a href="/rise4fun/docs/httpresearch.microsoft.comen-usumpeopleleonardoci.pdf">Complete instantiation for quantified formulas in Satisfiabiliby Modulo Theories.</a> The model based quantifier instantiation approach used in Z3 is also described in this paper. Stratified data-structures (such as arrays of pointers) can be encoded in this fragment.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(set-option smt.mbqi true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; Ptr is the pointer sort.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-sort Ptr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; (next p) represents p.next</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; The pointer reached by following the field next of p.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun next  (Ptr) Ptr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun prev  (Ptr) Ptr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun state (Ptr) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun prio  (Ptr) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const null Ptr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const RUN  Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const SLP  Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (distinct RUN SLP))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; Asserting data-structure invariants in the current state.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; p != null &amp;&amp; p.next != null = p.next.prev = p</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((p Ptr))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                (= (and (not (= p null))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         (not (= (next p) null)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    (= (prev (next p)) p))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; p != null &amp;&amp; p.prev != null = p.prev.next = p</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((p Ptr))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                (= (and (not (= p null))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         (not (= (prev p) null)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    (= (next (prev p)) p))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;;  p != null &amp;&amp; p.prev != null = p.state = p.next.state</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((p Ptr))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                (= (and (not (= p null))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         (not (= (next p) null)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    (= (state p) (state (next p))))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;;  p != null &amp;&amp; p.prev != null &amp;&amp; p.state = RUN = p.prio = p.next.prio</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((p Ptr))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                (= (and (not (= p null))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         (not (= (next p) null))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         (= (state p) RUN))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    (= (prio p) (prio (next p))))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; Verifying Verification Conditions (VCs) for remove procdure</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const x Ptr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; new-state, new-next, new-prev and new-prio represent the state </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; of the system after executing the remove procedure.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun new-state (Ptr) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun new-next  (Ptr) Ptr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun new-prev  (Ptr) Ptr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun new-prio  (Ptr) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; pre-conditions</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (= x null)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (= (prev x) null)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (state x) RUN))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; updates</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; --- new-prev = prev</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((p Ptr)) (= (new-prev p) (prev p))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; --- new-prio = prio</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((p Ptr)) (= (new-prio p) (prio p))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; --- new-state = state[x - SLP]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (new-state x) SLP))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((p Ptr)) (or (= p x) (= (new-state p) (state p)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; ----</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; --- new-next  = next[(prev x) - (next x); x - null]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (new-next x) null))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (new-next (prev x)) (next x)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((p Ptr)) (or (= p x) (= p (prev x)) (= (new-next p) (next p)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; ---</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; Proving the data-structure invariants in the new state.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(push)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (forall ((p Ptr))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     (= (and (not (= p null))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              (not (= (new-next p) null)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         (= (new-prev (new-next p)) p)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(pop)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(echo Why it is not valid)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(echo Trying again using a fresh constant bad-ptr as an witness for the failure...)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(push)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const bad-ptr Ptr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (not (= (and (not (= bad-ptr null))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      (not (= (new-next bad-ptr) null)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 (= (new-prev (new-next bad-ptr)) bad-ptr))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(echo null is)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(eval null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(echo bad-ptr is)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(eval bad-ptr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(echo In the new state, bad-ptr.next is)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(eval (new-next bad-ptr))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(echo In the new state, bad-ptr.next.prev is)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(eval (new-prev (new-next bad-ptr)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(pop)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Shifts on streams (or arrays) can also be encoded.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(set-option smt.mbqi true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; f an g are streams</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun f (Int) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun g (Int) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; the segment [a, n + a] of stream f is equal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; to the segment [0, n] of stream g.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const n Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x Int)) (= (and (= 0 x) (= x n))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              (= (f (+ x a)) (g x)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;; adding some constraints to a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert ( a 10))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (f a) 2))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (g 3) (- 10)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="quantified-bit-vector-formulas">Quantified Bit-Vector Formulas<a class="hash-link" href="#quantified-bit-vector-formulas" title="Direct link to heading">​</a></h4><p>A quantified bit-Vector formula (QBVF) is a many sorted first-order logic formula where the sort of every variable is a bit-vector sort. The QBVF satisfiability problem, is the problem of deciding whether a QBVF is satisfiable modulo the theory of bit-vectors. This problem is decidable because every universal (existental) quantifier can be expanded into a conjunction (disjunction) of potentially exponential, but finite size. A distinguishing feature in QBVF is the support for uninterpreted function and predicate symbols. More information about this fragment can be found in the paper <a href="/rise4fun/docs/httpresearch.microsoft.comen-usumpeopleleonardofmcad10.pdf">Efficiently Solving Quantified Bit-Vector Formulas</a>.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(set-option smt.mbqi true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(define-sort Char () (_ BitVec 8))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun f  (Char) Char)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun f1 (Char) Char)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a Char)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (bvugt a #x00))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (= (f1 (bvadd a #x01)) #x00))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x Char)) (or (= x (bvadd a #x01)) (= (f1 x) (f x)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="conditional-and-pseudo-macros">Conditional (and Pseudo) Macros<a class="hash-link" href="#conditional-and-pseudo-macros" title="Direct link to heading">​</a></h4><p>Quantifiers defining macros are also automatically detected by the Model Finder. In the following example, the first three quantifiers are defining f by cases.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(set-option smt.mbqi true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun f (Int) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p (Int) Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p2 (Int) Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const b Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const c Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x Int)) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                (= (not (p x)) (= (f x) (+ x 1)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x Int)) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                (= (and (p x) (not (p2 x))) (= (f x) x))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x Int)) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                (= (p2 x) (= (f x) (- x 1)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (p b))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (p c))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (p2 a))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert ( (f a) b))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="my-formula-is-not-in-any-of-the-fragments-above">My formula is not in any of the fragments above<a class="hash-link" href="#my-formula-is-not-in-any-of-the-fragments-above" title="Direct link to heading">​</a></h4><p>Even if your formula is not in any of the fragments above. Z3 may still find a model for it. For example, The following simple example is not in the fragments described above.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(set-option smt.mbqi true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun n () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun a_1 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun f (Int) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun g_1 (Int) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert ( n 0))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((i Int))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (= (and (= 0 i) (= i n))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            (and (= (f 0) 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 (= (f 2) 2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 (= 0 (f i))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 (= (f i) 2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 (= (= (f i) 2) (= i n))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 (= (= (f i) 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     (or (= (f (+ i 1)) 1) (= (f (+ i 1)) 2)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 (= (= (f i) 1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     (or (= (f (+ i 1)) 1) (= (f (+ i 1)) 2)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 (= (g_1 0) 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 (= (= (f i) 0) (= (g_1 (+ i 1)) 0))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 (= (= (f i) 1) (= (g_1 (+ i 1)) (+ (g_1 i) 1)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 (= (= (f i) 2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     (= (g_1 (+ i 1)) (g_1 i)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 (= (= (f i) 1) ( (g_1 i) a_1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 (= (= (f i) 2) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     (and (= (g_1 i) a_1) ( (g_1 i) 2)))))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(echo Property does not hold for n  1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert ( n 1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The Z3 preprocessor has many options that may improve the performace of the model finder. In the following example, macro-finder will expand quantifiers representing macros at preprocessing time.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(set-option smt.mbqi true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(set-option smt.macro-finder true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-sort Action)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-sort Role)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-sort Permission)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-sort Id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun Client () Role)  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun FinAdmin () Role)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun FinClerk () Role)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun Manager () Role)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun POAdmin () Role)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun POClerk () Role)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun action2int (Action) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun id1 () Id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun id2 () Id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun id2int (Id) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun id3 () Id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun id4 () Id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun id5 () Id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun id6 () Id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun id7 () Id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p1 () Permission)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p2 () Permission)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p3 () Permission)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p4 () Permission)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p5 () Permission)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p6 () Permission)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun permission2int (Permission) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun role2int (Role) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun role_level (Role) Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun t1_receive () Action)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun t2_invoke () Action)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun t3_split () Action)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun t4_join () Action)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun t5_invoke () Action)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun t6_invoke () Action)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun t7_invokeO () Action)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun t8_invokeI () Action)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun t9_invoke () Action)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun in_creator_ctrPay_0 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun in_creator_ctrPay_1 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun in_customer_crtPO_0 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun in_customer_crtPO_1 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun out_approverPOPayment_apprPay_0 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun out_approverPOPayment_apprPay_1 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun out_approverPO_apprPO_0 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun out_approverPO_apprPO_1 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun out_creator_ctrPay_0 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun out_creator_ctrPay_1 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun out_signerGRN_ctrsignGRN_0 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun out_signerGRN_ctrsignGRN_1 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun out_signerGRN_signGRN_0 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun out_signerGRN_signGRN_1 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p10_final_0 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p10_final_1 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p11_final_0 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p11_final_1 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p1_final_0 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p1_final_1 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p2_final_0 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p2_final_1 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p3_running_0 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p3_running_1 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p4_final_0 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p4_final_1 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p5_final_0 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p5_final_1 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p6_initial_0 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p6_initial_1 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p7_final_0 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p7_final_1 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p8_initial_0 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p8_initial_1 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p9_initial_0 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun p9_initial_1 () Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;PREDICATES</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun has_permission (Id Action) Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun permission (Permission Action) Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun role (Role) Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun role_le (Role Role) Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun role_permission_assign (Role Permission) Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun user (Id) Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun user_role_assign (Id Role) Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun can_exec_0 (Id Action) Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun can_exec_1 (Id Action) Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun executed_0 (Id Action) Bool) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun executed_1 (Id Action) Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun initial_pm_0 () Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun initial_wf_0 () Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun t1_receive_0_1 (Id) Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun t2_invoke_0_1 (Id) Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun t3_split_0_1 (Id) Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun t4_join_0_1 (Id) Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun t5_invoke_0_1 (Id) Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun t6_invoke_0_1 (Id) Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun t7_invokeO_0_1 (Id) Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun t8_invokeI_0_1 (Id) Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun t9_invoke_0_1 (Id) Bool)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(forall ((U Action) (V Action)) (implies (= (action2int U) (action2int V)) (= U V))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(forall ((U Action)) (and (= 1 (action2int U)) (= (action2int U) 9))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (action2int t1_receive) 1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (action2int t2_invoke) 2))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (action2int t3_split) 3))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (action2int t4_join) 4))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (action2int t5_invoke) 5))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (action2int t6_invoke) 6))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (action2int t7_invokeO) 7))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (action2int t8_invokeI) 8))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (action2int t9_invoke) 9))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(forall ((U Role) (V Role)) (implies (= (role2int U) (role2int V)) (= U V))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(forall ((U Role)) (and (= 1 (role2int U)) (= (role2int U) 6))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 14</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (role2int Manager) 1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (role2int FinAdmin) 2))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (role2int FinClerk) 3))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 17</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (role2int POAdmin) 4))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (role2int POClerk) 5))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (role2int Client) 6))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(forall ((U Permission) (V Permission)) (implies (= (permission2int U) (permission2int V)) (= U V))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 21</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(forall ((U Permission)) (and (= 1 (permission2int U)) (= (permission2int U) 6))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 22</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (permission2int p1) 1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 23</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (permission2int p2) 2))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 24</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (permission2int p3) 3))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 25</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (permission2int p4) 4))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 26</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (permission2int p5) 5))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 27</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (permission2int p6) 6))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 28</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(forall ((U Permission) (V Action)) (iff (permission U V) (or (and (= U p1) (= V t2_invoke)) (or (and (= U p2) (= V t5_invoke)) (or (and (= U p3) (= V t6_invoke)) (or (and (= U p4) (or (= V t7_invokeO) (= V t8_invokeI))) (or (and (= U p5) (= V t9_invoke)) (and (= U p6) (= V t1_receive))))))))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 29</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(forall ((U Id) (V Role)) (iff (user_role_assign U V) (or (and (= U id7) (= V Manager)) (or (and (= U id1) (= V Manager)) (or (and (= U id2) (= V FinAdmin)) (or (and (= U id3) (= V FinClerk)) (or (and (= U id4) (= V POAdmin)) (or (and (= U id5) (= V POClerk)) (and (= U id6) (= V Client)))))))))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 30</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(forall ((U Role) (V Permission)) (iff (role_permission_assign U V) (or (and (= U POClerk) (= V p3)) (or (and (= U FinClerk) (= V p4)) (or (and (= U POAdmin) (or (= V p1) (= V p3))) (or (and (= U FinAdmin) (or (= V p5) (= V p4))) (or (and (= U Client) (or (= V p6) (= V p2))) (and (= U Manager) (or (= V p1) (or (= V p3) (or (= V p4) (= V p5)))))))))))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 31</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(forall ((U Id) (V Action)) (iff (has_permission U V) (or (and (user_role_assign U Manager) (and (role_permission_assign Manager p1) (permission p1 V))) (or (and (user_role_assign U Manager) (and (role_permission_assign Manager p2) (permission p2 V))) (or (and (user_role_assign U Manager) (and (role_permission_assign Manager p3) (permission p3 V))) (or (and (user_role_assign U Manager) (and (role_permission_assign Manager p4) (permission p4 V))) (or (and (user_role_assign U Manager) (and (role_permission_assign Manager p5) (permission p5 V))) (or (and (user_role_assign U Manager) (and (role_permission_assign Manager p6) (permission p6 V))) (or (and (user_role_assign U POClerk) (and (role_permission_assign POClerk p1) (permission p1 V))) (or (and (user_role_assign U POClerk) (and (role_permission_assign POClerk p2) (permission p2 V))) (or (and (user_role_assign U POClerk) (and (role_permission_assign POClerk p3) (permission p3 V))) (or (and (user_role_assign U POClerk) (and (role_permission_assign POClerk p4) (permission p4 V))) (or (and (user_role_assign U POClerk) (and (role_permission_assign POClerk p5) (permission p5 V))) (or (and (user_role_assign U POClerk) (and (role_permission_assign POClerk p6) (permission p6 V))) (or (and (user_role_assign U FinClerk) (and (role_permission_assign FinClerk p1) (permission p1 V))) (or (and (user_role_assign U FinClerk) (and (role_permission_assign FinClerk p2) (permission p2 V))) (or (and (user_role_assign U FinClerk) (and (role_permission_assign FinClerk p3) (permission p3 V))) (or (and (user_role_assign U FinClerk) (and (role_permission_assign FinClerk p4) (permission p4 V))) (or (and (user_role_assign U FinClerk) (and (role_permission_assign FinClerk p5) (permission p5 V))) (or (and (user_role_assign U FinClerk) (and (role_permission_assign FinClerk p6) (permission p6 V))) (or (and (user_role_assign U FinAdmin) (and (role_permission_assign FinAdmin p1) (permission p1 V))) (or (and (user_role_assign U FinAdmin) (and (role_permission_assign FinAdmin p2) (permission p2 V))) (or (and (user_role_assign U FinAdmin) (and (role_permission_assign FinAdmin p3) (permission p3 V))) (or (and (user_role_assign U FinAdmin) (and (role_permission_assign FinAdmin p4) (permission p4 V))) (or (and (user_role_assign U FinAdmin) (and (role_permission_assign FinAdmin p5) (permission p5 V))) (or (and (user_role_assign U FinAdmin) (and (role_permission_assign FinAdmin p6) (permission p6 V))) (or (and (user_role_assign U POAdmin) (and (role_permission_assign POAdmin p1) (permission p1 V))) (or (and (user_role_assign U POAdmin) (and (role_permission_assign POAdmin p2) (permission p2 V))) (or (and (user_role_assign U POAdmin) (and (role_permission_assign POAdmin p3) (permission p3 V))) (or (and (user_role_assign U POAdmin) (and (role_permission_assign POAdmin p4) (permission p4 V))) (or (and (user_role_assign U POAdmin) (and (role_permission_assign POAdmin p5) (permission p5 V))) (or (and (user_role_assign U POAdmin) (and (role_permission_assign POAdmin p6) (permission p6 V))) (or (and (user_role_assign U Client) (and (role_permission_assign Client p1) (permission p1 V))) (or (and (user_role_assign U Client) (and (role_permission_assign Client p2) (permission p2 V))) (or (and (user_role_assign U Client) (and (role_permission_assign Client p3) (permission p3 V))) (or (and (user_role_assign U Client) (and (role_permission_assign Client p4) (permission p4 V))) (or (and (user_role_assign U Client) (and (role_permission_assign Client p5) (permission p5 V))) (and (user_role_assign U Client) (and (role_permission_assign Client p6) (permission p6 V)))))))))))))))))))))))))))))))))))))))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(forall ((U Role) (V Role)) (iff (role_le U V) ( (role_level U) (role_level V)))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 33</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (role_level Manager) 3))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 34</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (role_level FinAdmin) 2))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 35</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (role_level FinClerk) 1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 36</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (role_level POAdmin) 2))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 37</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (role_level POClerk) 1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 38</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (role_level Client) 0))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 39</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(forall ((U Id) (V Id)) (implies (= (id2int U) (id2int V)) (= U V))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 40</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(forall ((U Id)) (and (= 1 (id2int U)) (= (id2int U) 7))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 41</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (id2int id1) 1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 42</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (id2int id2) 2))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 43</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (id2int id3) 3))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 44</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (id2int id4) 4))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 45</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (id2int id5) 5))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 46</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (id2int id6) 6))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 47</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(= (id2int id7) 7))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 48</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(iff initial_wf_0 (and (= p1_final_0 0) (and (= p2_final_0 0) (and (= p3_running_0 0) (and (= p4_final_0 0) (and (= p5_final_0 0) (and (= p6_initial_0 0) (and (= p7_final_0 0) (and (= p8_initial_0 0) (and (= p9_initial_0 1) (and (= p10_final_0 0) (and (= p11_final_0 0) (and (= in_customer_crtPO_0 1) (and (= in_creator_ctrPay_0 1) (and (= out_approverPO_apprPO_0 0) (and (= out_approverPOPayment_apprPay_0 0) (and (= out_creator_ctrPay_0 0) (and (= out_signerGRN_ctrsignGRN_0 0) (= out_signerGRN_signGRN_0 0))))))))))))))))))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 49</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(iff initial_pm_0 (forall ((U Id) (V Action)) (iff (executed_0 U V) false))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> ))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 50</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(forall ((U Id) (V Action)) (iff (can_exec_0 U V) (or (and (= V t5_invoke) (and (has_permission U t5_invoke) (or (and (not (= U id1)) (executed_0 id1 t2_invoke)) (or (and (not (= U id2)) (executed_0 id2 t2_invoke)) (or (and (not (= U id3)) (executed_0 id3 t2_invoke)) (or (and (not (= U id4)) (executed_0 id4 t2_invoke)) (or (and (not (= U id5)) (executed_0 id5 t2_invoke)) (or (and (not (= U id6)) (executed_0 id6 t2_invoke)) (and (not (= U id7)) (executed_0 id7 t2_invoke)))))))))) (or (and (= V t6_invoke) (and (and (has_permission U t6_invoke) (or (and (not (= U id1)) (executed_0 id1 t2_invoke)) (or (and (not (= U id2)) (executed_0 id2 t2_invoke)) (or (and (not (= U id3)) (executed_0 id3 t2_invoke)) (or (and (not (= U id4)) (executed_0 id4 t2_invoke)) (or (and (not (= U id5)) (executed_0 id5 t2_invoke)) (or (and (not (= U id6)) (executed_0 id6 t2_invoke)) (and (not (= U id7)) (executed_0 id7 t2_invoke))))))))) (and (has_permission U t6_invoke) (or (and (not (= U id1)) (executed_0 id1 t5_invoke)) (or (and (not (= U id2)) (executed_0 id2 t5_invoke)) (or (and (not (= U id3)) (executed_0 id3 t5_invoke)) (or (and (not (= U id4)) (executed_0 id4 t5_invoke)) (or (and (not (= U id5)) (executed_0 id5 t5_invoke)) (or (and (not (= U id6)) (executed_0 id6 t5_invoke)) (and (not (= U id7)) (executed_0 id7 t5_invoke))))))))))) (or (and (= V t9_invoke) (and (has_permission U t9_invoke) (exists ((W Role))  (and (user_role_assign U W) (and (or (and (user_role_assign id1 Manager) (and (role_le Manager W) (executed_0 id1 t7_invokeO))) (or (and (user_role_assign id2 Manager) (and (role_le Manager W) (executed_0 id2 t7_invokeO))) (or (and (user_role_assign id3 Manager) (and (role_le Manager W) (executed_0 id3 t7_invokeO))) (or (and (user_role_assign id4 Manager) (and (role_le Manager W) (executed_0 id4 t7_invokeO))) (or (and (user_role_assign id5 Manager) (and (role_le Manager W) (executed_0 id5 t7_invokeO))) (or (and (user_role_assign id6 Manager) (and (role_le Manager W) (executed_0 id6 t7_invokeO))) (or (and (user_role_assign id7 Manager) (and (role_le Manager W) (executed_0 id7 t7_invokeO))) (or (and (user_role_assign id1 POClerk) (and (role_le POClerk W) (executed_0 id1 t7_invokeO))) (or (and (user_role_assign id2 POClerk) (and (role_le POClerk W) (executed_0 id2 t7_invokeO))) (or (and (user_role_assign id3 POClerk) (and (role_le POClerk W) (executed_0 id3 t7_invokeO))) (or (and (user_role_assign id4 POClerk) (and (role_le POClerk W) (executed_0 id4 t7_invokeO))) (or (and (user_role_assign id5 POClerk) (and (role_le POClerk W) (executed_0 id5 t7_invokeO))) (or (and (user_role_assign id6 POClerk) (and (role_le POClerk W) (executed_0 id6 t7_invokeO))) (or (and (user_role_assign id7 POClerk) (and (role_le POClerk W) (executed_0 id7 t7_invokeO))) (or (and (user_role_assign id1 FinClerk) (and (role_le FinClerk W) (executed_0 id1 t7_invokeO))) (or (and (user_role_assign id2 FinClerk) (and (role_le FinClerk W) (executed_0 id2 t7_invokeO))) (or (and (user_role_assign id3 FinClerk) (and (role_le FinClerk W) (executed_0 id3 t7_invokeO))) (or (and (user_role_assign id4 FinClerk) (and (role_le FinClerk W) (executed_0 id4 t7_invokeO))) (or (and (user_role_assign id5 FinClerk) (and (role_le FinClerk W) (executed_0 id5 t7_invokeO))) (or (and (user_role_assign id6 FinClerk) (and (role_le FinClerk W) (executed_0 id6 t7_invokeO))) (or (and (user_role_assign id7 FinClerk) (and (role_le FinClerk W) (executed_0 id7 t7_invokeO))) (or (and (user_role_assign id1 FinAdmin) (and (role_le FinAdmin W) (executed_0 id1 t7_invokeO))) (or (and (user_role_assign id2 FinAdmin) (and (role_le FinAdmin W) (executed_0 id2 t7_invokeO))) (or (and (user_role_assign id3 FinAdmin) (and (role_le FinAdmin W) (executed_0 id3 t7_invokeO))) (or (and (user_role_assign id4 FinAdmin) (and (role_le FinAdmin W) (executed_0 id4 t7_invokeO))) (or (and (user_role_assign id5 FinAdmin) (and (role_le FinAdmin W) (executed_0 id5 t7_invokeO))) (or (and (user_role_assign id6 FinAdmin) (and (role_le FinAdmin W) (executed_0 id6 t7_invokeO))) (or (and (user_role_assign id7 FinAdmin) (and (role_le FinAdmin W) (executed_0 id7 t7_invokeO))) (or (and (user_role_assign id1 POAdmin) (and (role_le POAdmin W) (executed_0 id1 t7_invokeO))) (or (and (user_role_assign id2 POAdmin) (and (role_le POAdmin W) (executed_0 id2 t7_invokeO))) (or (and (user_role_assign id3 POAdmin) (and (role_le POAdmin W) (executed_0 id3 t7_invokeO))) (or (and (user_role_assign id4 POAdmin) (and (role_le POAdmin W) (executed_0 id4 t7_invokeO))) (or (and (user_role_assign id5 POAdmin) (and (role_le POAdmin W) (executed_0 id5 t7_invokeO))) (or (and (user_role_assign id6 POAdmin) (and (role_le POAdmin W) (executed_0 id6 t7_invokeO))) (or (and (user_role_assign id7 POAdmin) (and (role_le POAdmin W) (executed_0 id7 t7_invokeO))) (or (and (user_role_assign id1 Client) (and (role_le Client W) (executed_0 id1 t7_invokeO))) (or (and (user_role_assign id2 Client) (and (role_le Client W) (executed_0 id2 t7_invokeO))) (or (and (user_role_assign id3 Client) (and (role_le Client W) (executed_0 id3 t7_invokeO))) (or (and (user_role_assign id4 Client) (and (role_le Client W) (executed_0 id4 t7_invokeO))) (or (and (user_role_assign id5 Client) (and (role_le Client W) (executed_0 id5 t7_invokeO))) (or (and (user_role_assign id6 Client) (and (role_le Client W) (executed_0 id6 t7_invokeO))) (and (user_role_assign id7 Client) (and (role_le Client W) (executed_0 id7 t7_invokeO)))))))))))))))))))))))))))))))))))))))))))) (or (and (user_role_assign id1 Manager) (and (role_le Manager W) (executed_0 id1 t8_invokeI))) (or (and (user_role_assign id2 Manager) (and (role_le Manager W) (executed_0 id2 t8_invokeI))) (or (and (user_role_assign id3 Manager) (and (role_le Manager W) (executed_0 id3 t8_invokeI))) (or (and (user_role_assign id4 Manager) (and (role_le Manager W) (executed_0 id4 t8_invokeI))) (or (and (user_role_assign id5 Manager) (and (role_le Manager W) (executed_0 id5 t8_invokeI))) (or (and (user_role_assign id6 Manager) (and (role_le Manager W) (executed_0 id6 t8_invokeI))) (or (and (user_role_assign id7 Manager) (and (role_le Manager W) (executed_0 id7 t8_invokeI))) (or (and (user_role_assign id1 POClerk) (and (role_le POClerk W) (executed_0 id1 t8_invokeI))) (or (and (user_role_assign id2 POClerk) (and (role_le POClerk W) (executed_0 id2 t8_invokeI))) (or (and (user_role_assign id3 POClerk) (and (role_le POClerk W) (executed_0 id3 t8_invokeI))) (or (and (user_role_assign id4 POClerk) (and (role_le POClerk W) (executed_0 id4 t8_invokeI))) (or (and (user_role_assign id5 POClerk) (and (role_le POClerk W) (executed_0 id5 t8_invokeI))) (or (and (user_role_assign id6 POClerk) (and (role_le POClerk W) (executed_0 id6 t8_invokeI))) (or (and (user_role_assign id7 POClerk) (and (role_le POClerk W) (executed_0 id7 t8_invokeI))) (or (and (user_role_assign id1 FinClerk) (and (role_le FinClerk W) (executed_0 id1 t8_invokeI))) (or (and (user_role_assign id2 FinClerk) (and (role_le FinClerk W) (executed_0 id2 t8_invokeI))) (or (and (user_role_assign id3 FinClerk) (and (role_le FinClerk W) (executed_0 id3 t8_invokeI))) (or (and (user_role_assign id4 FinClerk) (and (role_le FinClerk W) (executed_0 id4 t8_invokeI))) (or (and (user_role_assign id5 FinClerk) (and (role_le FinClerk W) (executed_0 id5 t8_invokeI))) (or (and (user_role_assign id6 FinClerk) (and (role_le FinClerk W) (executed_0 id6 t8_invokeI))) (or (and (user_role_assign id7 FinClerk) (and (role_le FinClerk W) (executed_0 id7 t8_invokeI))) (or (and (user_role_assign id1 FinAdmin) (and (role_le FinAdmin W) (executed_0 id1 t8_invokeI))) (or (and (user_role_assign id2 FinAdmin) (and (role_le FinAdmin W) (executed_0 id2 t8_invokeI))) (or (and (user_role_assign id3 FinAdmin) (and (role_le FinAdmin W) (executed_0 id3 t8_invokeI))) (or (and (user_role_assign id4 FinAdmin) (and (role_le FinAdmin W) (executed_0 id4 t8_invokeI))) (or (and (user_role_assign id5 FinAdmin) (and (role_le FinAdmin W) (executed_0 id5 t8_invokeI))) (or (and (user_role_assign id6 FinAdmin) (and (role_le FinAdmin W) (executed_0 id6 t8_invokeI))) (or (and (user_role_assign id7 FinAdmin) (and (role_le FinAdmin W) (executed_0 id7 t8_invokeI))) (or (and (user_role_assign id1 POAdmin) (and (role_le POAdmin W) (executed_0 id1 t8_invokeI))) (or (and (user_role_assign id2 POAdmin) (and (role_le POAdmin W) (executed_0 id2 t8_invokeI))) (or (and (user_role_assign id3 POAdmin) (and (role_le POAdmin W) (executed_0 id3 t8_invokeI))) (or (and (user_role_assign id4 POAdmin) (and (role_le POAdmin W) (executed_0 id4 t8_invokeI))) (or (and (user_role_assign id5 POAdmin) (and (role_le POAdmin W) (executed_0 id5 t8_invokeI))) (or (and (user_role_assign id6 POAdmin) (and (role_le POAdmin W) (executed_0 id6 t8_invokeI))) (or (and (user_role_assign id7 POAdmin) (and (role_le POAdmin W) (executed_0 id7 t8_invokeI))) (or (and (user_role_assign id1 Client) (and (role_le Client W) (executed_0 id1 t8_invokeI))) (or (and (user_role_assign id2 Client) (and (role_le Client W) (executed_0 id2 t8_invokeI))) (or (and (user_role_assign id3 Client) (and (role_le Client W) (executed_0 id3 t8_invokeI))) (or (and (user_role_assign id4 Client) (and (role_le Client W) (executed_0 id4 t8_invokeI))) (or (and (user_role_assign id5 Client) (and (role_le Client W) (executed_0 id5 t8_invokeI))) (or (and (user_role_assign id6 Client) (and (role_le Client W) (executed_0 id6 t8_invokeI))) (and (user_role_assign id7 Client) (and (role_le Client W) (executed_0 id7 t8_invokeI))))))))))))))))))))))))))))))))))))))))))))) )) )) (or (and (= V t1_receive) (has_permission U t1_receive)) (or (and (= V t2_invoke) (has_permission U t2_invoke)) (or (and (= V t7_invokeO) (has_permission U t7_invokeO)) (and (= V t8_invokeI) (has_permission U t8_invokeI)))))))))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 51</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(forall ((U Id) (V Action)) (iff (can_exec_1 U V) (or (and (= V t5_invoke) (and (has_permission U t5_invoke) (or (and (not (= U id1)) (executed_1 id1 t2_invoke)) (or (and (not (= U id2)) (executed_1 id2 t2_invoke)) (or (and (not (= U id3)) (executed_1 id3 t2_invoke)) (or (and (not (= U id4)) (executed_1 id4 t2_invoke)) (or (and (not (= U id5)) (executed_1 id5 t2_invoke)) (or (and (not (= U id6)) (executed_1 id6 t2_invoke)) (and (not (= U id7)) (executed_1 id7 t2_invoke)))))))))) (or (and (= V t6_invoke) (and (and (has_permission U t6_invoke) (or (and (not (= U id1)) (executed_1 id1 t2_invoke)) (or (and (not (= U id2)) (executed_1 id2 t2_invoke)) (or (and (not (= U id3)) (executed_1 id3 t2_invoke)) (or (and (not (= U id4)) (executed_1 id4 t2_invoke)) (or (and (not (= U id5)) (executed_1 id5 t2_invoke)) (or (and (not (= U id6)) (executed_1 id6 t2_invoke)) (and (not (= U id7)) (executed_1 id7 t2_invoke))))))))) (and (has_permission U t6_invoke) (or (and (not (= U id1)) (executed_1 id1 t5_invoke)) (or (and (not (= U id2)) (executed_1 id2 t5_invoke)) (or (and (not (= U id3)) (executed_1 id3 t5_invoke)) (or (and (not (= U id4)) (executed_1 id4 t5_invoke)) (or (and (not (= U id5)) (executed_1 id5 t5_invoke)) (or (and (not (= U id6)) (executed_1 id6 t5_invoke)) (and (not (= U id7)) (executed_1 id7 t5_invoke))))))))))) (or (and (= V t9_invoke) (and (has_permission U t9_invoke) (exists ((W Role))  (and (user_role_assign U W) (and (or (and (user_role_assign id1 Manager) (and (role_le Manager W) (executed_1 id1 t7_invokeO))) (or (and (user_role_assign id2 Manager) (and (role_le Manager W) (executed_1 id2 t7_invokeO))) (or (and (user_role_assign id3 Manager) (and (role_le Manager W) (executed_1 id3 t7_invokeO))) (or (and (user_role_assign id4 Manager) (and (role_le Manager W) (executed_1 id4 t7_invokeO))) (or (and (user_role_assign id5 Manager) (and (role_le Manager W) (executed_1 id5 t7_invokeO))) (or (and (user_role_assign id6 Manager) (and (role_le Manager W) (executed_1 id6 t7_invokeO))) (or (and (user_role_assign id7 Manager) (and (role_le Manager W) (executed_1 id7 t7_invokeO))) (or (and (user_role_assign id1 POClerk) (and (role_le POClerk W) (executed_1 id1 t7_invokeO))) (or (and (user_role_assign id2 POClerk) (and (role_le POClerk W) (executed_1 id2 t7_invokeO))) (or (and (user_role_assign id3 POClerk) (and (role_le POClerk W) (executed_1 id3 t7_invokeO))) (or (and (user_role_assign id4 POClerk) (and (role_le POClerk W) (executed_1 id4 t7_invokeO))) (or (and (user_role_assign id5 POClerk) (and (role_le POClerk W) (executed_1 id5 t7_invokeO))) (or (and (user_role_assign id6 POClerk) (and (role_le POClerk W) (executed_1 id6 t7_invokeO))) (or (and (user_role_assign id7 POClerk) (and (role_le POClerk W) (executed_1 id7 t7_invokeO))) (or (and (user_role_assign id1 FinClerk) (and (role_le FinClerk W) (executed_1 id1 t7_invokeO))) (or (and (user_role_assign id2 FinClerk) (and (role_le FinClerk W) (executed_1 id2 t7_invokeO))) (or (and (user_role_assign id3 FinClerk) (and (role_le FinClerk W) (executed_1 id3 t7_invokeO))) (or (and (user_role_assign id4 FinClerk) (and (role_le FinClerk W) (executed_1 id4 t7_invokeO))) (or (and (user_role_assign id5 FinClerk) (and (role_le FinClerk W) (executed_1 id5 t7_invokeO))) (or (and (user_role_assign id6 FinClerk) (and (role_le FinClerk W) (executed_1 id6 t7_invokeO))) (or (and (user_role_assign id7 FinClerk) (and (role_le FinClerk W) (executed_1 id7 t7_invokeO))) (or (and (user_role_assign id1 FinAdmin) (and (role_le FinAdmin W) (executed_1 id1 t7_invokeO))) (or (and (user_role_assign id2 FinAdmin) (and (role_le FinAdmin W) (executed_1 id2 t7_invokeO))) (or (and (user_role_assign id3 FinAdmin) (and (role_le FinAdmin W) (executed_1 id3 t7_invokeO))) (or (and (user_role_assign id4 FinAdmin) (and (role_le FinAdmin W) (executed_1 id4 t7_invokeO))) (or (and (user_role_assign id5 FinAdmin) (and (role_le FinAdmin W) (executed_1 id5 t7_invokeO))) (or (and (user_role_assign id6 FinAdmin) (and (role_le FinAdmin W) (executed_1 id6 t7_invokeO))) (or (and (user_role_assign id7 FinAdmin) (and (role_le FinAdmin W) (executed_1 id7 t7_invokeO))) (or (and (user_role_assign id1 POAdmin) (and (role_le POAdmin W) (executed_1 id1 t7_invokeO))) (or (and (user_role_assign id2 POAdmin) (and (role_le POAdmin W) (executed_1 id2 t7_invokeO))) (or (and (user_role_assign id3 POAdmin) (and (role_le POAdmin W) (executed_1 id3 t7_invokeO))) (or (and (user_role_assign id4 POAdmin) (and (role_le POAdmin W) (executed_1 id4 t7_invokeO))) (or (and (user_role_assign id5 POAdmin) (and (role_le POAdmin W) (executed_1 id5 t7_invokeO))) (or (and (user_role_assign id6 POAdmin) (and (role_le POAdmin W) (executed_1 id6 t7_invokeO))) (or (and (user_role_assign id7 POAdmin) (and (role_le POAdmin W) (executed_1 id7 t7_invokeO))) (or (and (user_role_assign id1 Client) (and (role_le Client W) (executed_1 id1 t7_invokeO))) (or (and (user_role_assign id2 Client) (and (role_le Client W) (executed_1 id2 t7_invokeO))) (or (and (user_role_assign id3 Client) (and (role_le Client W) (executed_1 id3 t7_invokeO))) (or (and (user_role_assign id4 Client) (and (role_le Client W) (executed_1 id4 t7_invokeO))) (or (and (user_role_assign id5 Client) (and (role_le Client W) (executed_1 id5 t7_invokeO))) (or (and (user_role_assign id6 Client) (and (role_le Client W) (executed_1 id6 t7_invokeO))) (and (user_role_assign id7 Client) (and (role_le Client W) (executed_1 id7 t7_invokeO)))))))))))))))))))))))))))))))))))))))))))) (or (and (user_role_assign id1 Manager) (and (role_le Manager W) (executed_1 id1 t8_invokeI))) (or (and (user_role_assign id2 Manager) (and (role_le Manager W) (executed_1 id2 t8_invokeI))) (or (and (user_role_assign id3 Manager) (and (role_le Manager W) (executed_1 id3 t8_invokeI))) (or (and (user_role_assign id4 Manager) (and (role_le Manager W) (executed_1 id4 t8_invokeI))) (or (and (user_role_assign id5 Manager) (and (role_le Manager W) (executed_1 id5 t8_invokeI))) (or (and (user_role_assign id6 Manager) (and (role_le Manager W) (executed_1 id6 t8_invokeI))) (or (and (user_role_assign id7 Manager) (and (role_le Manager W) (executed_1 id7 t8_invokeI))) (or (and (user_role_assign id1 POClerk) (and (role_le POClerk W) (executed_1 id1 t8_invokeI))) (or (and (user_role_assign id2 POClerk) (and (role_le POClerk W) (executed_1 id2 t8_invokeI))) (or (and (user_role_assign id3 POClerk) (and (role_le POClerk W) (executed_1 id3 t8_invokeI))) (or (and (user_role_assign id4 POClerk) (and (role_le POClerk W) (executed_1 id4 t8_invokeI))) (or (and (user_role_assign id5 POClerk) (and (role_le POClerk W) (executed_1 id5 t8_invokeI))) (or (and (user_role_assign id6 POClerk) (and (role_le POClerk W) (executed_1 id6 t8_invokeI))) (or (and (user_role_assign id7 POClerk) (and (role_le POClerk W) (executed_1 id7 t8_invokeI))) (or (and (user_role_assign id1 FinClerk) (and (role_le FinClerk W) (executed_1 id1 t8_invokeI))) (or (and (user_role_assign id2 FinClerk) (and (role_le FinClerk W) (executed_1 id2 t8_invokeI))) (or (and (user_role_assign id3 FinClerk) (and (role_le FinClerk W) (executed_1 id3 t8_invokeI))) (or (and (user_role_assign id4 FinClerk) (and (role_le FinClerk W) (executed_1 id4 t8_invokeI))) (or (and (user_role_assign id5 FinClerk) (and (role_le FinClerk W) (executed_1 id5 t8_invokeI))) (or (and (user_role_assign id6 FinClerk) (and (role_le FinClerk W) (executed_1 id6 t8_invokeI))) (or (and (user_role_assign id7 FinClerk) (and (role_le FinClerk W) (executed_1 id7 t8_invokeI))) (or (and (user_role_assign id1 FinAdmin) (and (role_le FinAdmin W) (executed_1 id1 t8_invokeI))) (or (and (user_role_assign id2 FinAdmin) (and (role_le FinAdmin W) (executed_1 id2 t8_invokeI))) (or (and (user_role_assign id3 FinAdmin) (and (role_le FinAdmin W) (executed_1 id3 t8_invokeI))) (or (and (user_role_assign id4 FinAdmin) (and (role_le FinAdmin W) (executed_1 id4 t8_invokeI))) (or (and (user_role_assign id5 FinAdmin) (and (role_le FinAdmin W) (executed_1 id5 t8_invokeI))) (or (and (user_role_assign id6 FinAdmin) (and (role_le FinAdmin W) (executed_1 id6 t8_invokeI))) (or (and (user_role_assign id7 FinAdmin) (and (role_le FinAdmin W) (executed_1 id7 t8_invokeI))) (or (and (user_role_assign id1 POAdmin) (and (role_le POAdmin W) (executed_1 id1 t8_invokeI))) (or (and (user_role_assign id2 POAdmin) (and (role_le POAdmin W) (executed_1 id2 t8_invokeI))) (or (and (user_role_assign id3 POAdmin) (and (role_le POAdmin W) (executed_1 id3 t8_invokeI))) (or (and (user_role_assign id4 POAdmin) (and (role_le POAdmin W) (executed_1 id4 t8_invokeI))) (or (and (user_role_assign id5 POAdmin) (and (role_le POAdmin W) (executed_1 id5 t8_invokeI))) (or (and (user_role_assign id6 POAdmin) (and (role_le POAdmin W) (executed_1 id6 t8_invokeI))) (or (and (user_role_assign id7 POAdmin) (and (role_le POAdmin W) (executed_1 id7 t8_invokeI))) (or (and (user_role_assign id1 Client) (and (role_le Client W) (executed_1 id1 t8_invokeI))) (or (and (user_role_assign id2 Client) (and (role_le Client W) (executed_1 id2 t8_invokeI))) (or (and (user_role_assign id3 Client) (and (role_le Client W) (executed_1 id3 t8_invokeI))) (or (and (user_role_assign id4 Client) (and (role_le Client W) (executed_1 id4 t8_invokeI))) (or (and (user_role_assign id5 Client) (and (role_le Client W) (executed_1 id5 t8_invokeI))) (or (and (user_role_assign id6 Client) (and (role_le Client W) (executed_1 id6 t8_invokeI))) (and (user_role_assign id7 Client) (and (role_le Client W) (executed_1 id7 t8_invokeI))))))))))))))))))))))))))))))))))))))))))))) )) )) (or (and (= V t1_receive) (has_permission U t1_receive)) (or (and (= V t2_invoke) (has_permission U t2_invoke)) (or (and (= V t7_invokeO) (has_permission U t7_invokeO)) (and (= V t8_invokeI) (has_permission U t8_invokeI)))))))))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 52</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(forall ((U Id)) (iff (t1_receive_0_1 U)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   (and (and (can_exec_0 U t1_receive) (and (= 1 in_customer_crtPO_0) (= 1 p9_initial_0)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  (and (and (= p1_final_1 p1_final_0) (and (= p2_final_1 p2_final_0) (and (= p3_running_1 p3_running_0) (and (= p4_final_1 p4_final_0) (and (= p5_final_1 p5_final_0) (and (= p6_initial_1 p6_initial_0) (and (= p7_final_1 p7_final_0) (and (= p8_initial_1 p8_initial_0) (and (= p9_initial_1 (+ (~ 1) p9_initial_0)) (and (= p10_final_1 (+ 1 p10_final_0)) (and (= p11_final_1 p11_final_0) (and (= in_customer_crtPO_1 (+ (~ 1) in_customer_crtPO_0)) (and (= in_creator_ctrPay_1 in_creator_ctrPay_0) (and (= out_creator_ctrPay_1 out_creator_ctrPay_0) (and (= out_approverPOPayment_apprPay_1 out_approverPOPayment_apprPay_0) (and (= out_approverPO_apprPO_1 out_approverPO_apprPO_0) (and (= out_signerGRN_signGRN_1 out_signerGRN_signGRN_0) (and (= out_signerGRN_ctrsignGRN_1 out_signerGRN_ctrsignGRN_0) true))))))))))))))))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  (forall ((V Id) (W Action)) (iff (executed_1 V W) (or (and (= V U) (= W t1_receive)) (executed_0 V W))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   )))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">;assumption 53</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> (not (and initial_wf_0 (and initial_pm_0 (t1_receive_0_1 id6))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(set-info status sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(get-model)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>It is very effective in this benchmark since it contains many quantifiers of the form</p><blockquote><p>forall x.  p(x) = ....</p></blockquote><p>The Z3 model finder is more effective if the input formula does not contain nested quantifiers. If that is not the case for your formula, you can use the option</p><blockquote><p>(set-option smt.pull-nested-quantifiers true)</p></blockquote><p>The following challenge problem from the paper <a href="/rise4fun/docs/httpacademic.research.microsoft.comPaper615910.aspx">SEM a system for enumerating models</a> is proved to be unsatisfiable in less than one second by Z3.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(set-option smt.mbqi true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-sort S)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun g (S S) S)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-fun f (S S) S)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const a S)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(declare-const b S)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x S) (y S))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                (= (g (f x y) (f x x)) x)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x S) (y S))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                (= (f (g x y) (g x x)) x)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x S) (y S) (z S))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                (= (g (g x y) z) (g (g y z) x))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (forall ((x S) (y S) (z S))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                (= (f (f x y) z) (f (f y z) x))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(assert (distinct (g a (f b a)) (f a (g b a))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(check-sat)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="conclusion">Conclusion<a class="hash-link" href="#conclusion" title="Direct link to heading">​</a></h2><p>Z3 is an efficient theorem prover used in many software testing, analysis and verification applications. In this tutorial, we covered its main capabilities using the textual interface. However, most applications use the Z3 programmatic <a href="/rise4fun/docs/httpsz3prover.github.ioapihtmlindex.html">API</a> to access these features.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/microsoft/rise4fun/tree/main/website/docs/intro.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_eYIM" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vbeJ"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--next" href="/rise4fun/docs/category/tutorial---basics"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Tutorial - Basics</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#introduction" class="table-of-contents__link toc-highlight">Introduction</a></li><li><a href="#basic-commands" class="table-of-contents__link toc-highlight">Basic Commands</a><ul><li><a href="#using-scopes" class="table-of-contents__link toc-highlight">Using Scopes</a></li><li><a href="#configuration" class="table-of-contents__link toc-highlight">Configuration</a></li><li><a href="#additional-commands" class="table-of-contents__link toc-highlight">Additional commands</a></li></ul></li><li><a href="#propositional-logic" class="table-of-contents__link toc-highlight">Propositional Logic</a><ul><li><a href="#satisfiability-and-validity" class="table-of-contents__link toc-highlight">Satisfiability and Validity</a></li></ul></li><li><a href="#uninterpreted-functions-and-constants" class="table-of-contents__link toc-highlight">Uninterpreted functions and constants</a></li><li><a href="#arithmetic" class="table-of-contents__link toc-highlight">Arithmetic</a><ul><li><a href="#nonlinear-arithmetic" class="table-of-contents__link toc-highlight">Nonlinear arithmetic</a></li><li><a href="#division" class="table-of-contents__link toc-highlight">Division</a></li></ul></li><li><a href="#bitvectors" class="table-of-contents__link toc-highlight">Bitvectors</a><ul><li><a href="#basic-bitvector-arithmetic" class="table-of-contents__link toc-highlight">Basic Bitvector Arithmetic</a></li><li><a href="#bitwise-operations" class="table-of-contents__link toc-highlight">Bitwise Operations</a></li><li><a href="#predicates-over-bitvectors" class="table-of-contents__link toc-highlight">Predicates over Bitvectors</a></li></ul></li><li><a href="#arrays" class="table-of-contents__link toc-highlight">Arrays</a><ul><li><a href="#select-and-store" class="table-of-contents__link toc-highlight">Select and Store</a></li><li><a href="#constant-arrays" class="table-of-contents__link toc-highlight">Constant Arrays</a></li><li><a href="#array-models" class="table-of-contents__link toc-highlight">Array models</a></li><li><a href="#mapping-functions-on-arrays" class="table-of-contents__link toc-highlight">Mapping Functions on Arrays</a></li><li><a href="#bags-as-arrays" class="table-of-contents__link toc-highlight">Bags as Arrays</a></li></ul></li><li><a href="#datatypes" class="table-of-contents__link toc-highlight">Datatypes</a><ul><li><a href="#records" class="table-of-contents__link toc-highlight">Records</a></li><li><a href="#scalars-enumeration-types" class="table-of-contents__link toc-highlight">Scalars (enumeration types)</a></li><li><a href="#recursive-datatypes" class="table-of-contents__link toc-highlight">Recursive datatypes</a></li><li><a href="#mutually-recursive-datatypes" class="table-of-contents__link toc-highlight">Mutually recursive datatypes</a></li><li><a href="#z3-will-not-prove-inductive-facts" class="table-of-contents__link toc-highlight">Z3 will not prove inductive facts</a></li></ul></li><li><a href="#quantifiers" class="table-of-contents__link toc-highlight">Quantifiers</a><ul><li><a href="#modeling-with-quantifiers" class="table-of-contents__link toc-highlight">Modeling with Quantifiers</a></li><li><a href="#patterns" class="table-of-contents__link toc-highlight">Patterns</a></li><li><a href="#multi-patterns" class="table-of-contents__link toc-highlight">Multi-patterns</a></li><li><a href="#no-patterns" class="table-of-contents__link toc-highlight">No patterns</a></li><li><a href="#model-based-quantifier-instantiation" class="table-of-contents__link toc-highlight">Model-based Quantifier Instantiation</a></li></ul></li><li><a href="#conclusion" class="table-of-contents__link toc-highlight">Conclusion</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Learn Z3</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/rise4fun/docs/intro">Tutorial</a></li><li class="footer__item"><a href="https://theory.stanford.edu/~nikolaj/programmingz3.html" target="_blank" rel="noopener noreferrer" class="footer__link-item">Programming Z3 in Python<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/Z3Prover/z3" target="_blank" rel="noopener noreferrer" class="footer__link-item">Z3 on GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">Stay Connected</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/microsoft/rise4fun" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/RiSE_MSR" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://www.microsoft.com/en-us/research/group/research-software-engineering-rise/" target="_blank" rel="noopener noreferrer" class="footer__link-item">RiSE @ MSR<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">Legal</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://go.microsoft.com/fwlink/?LinkId=521839" target="_blank" rel="noopener noreferrer" class="footer__link-item">Privacy &amp; Cookies<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://www.microsoft.com/en-us/legal/intellectualproperty/copyright" target="_blank" rel="noopener noreferrer" class="footer__link-item">Terms of Use<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://www.microsoft.com/en-us/legal/intellectualproperty/trademarks/usage/general" target="_blank" rel="noopener noreferrer" class="footer__link-item">Trademarks<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright"><a href="{https://github.com/microsoft/rise4fun/commit/93918507fef51b841021c24913363dd7975a95b6}" target="_blank" rel="noopener noreferrer">93918507</a> | Copyright © 2022 Microsoft Corporation.</div></div></div></footer></div>
<script src="/rise4fun/assets/js/runtime~main.39fc671f.js"></script>
<script src="/rise4fun/assets/js/main.a98a3a30.js"></script>
</body>
</html>